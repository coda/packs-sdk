<html>
  <head>
    <!-- Monaco library script is loaded from: https://cdnjs.com/libraries/monaco-editor-->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.38.0/min/vs/loader.min.js"
      integrity="sha512-A+6SvPGkIN9Rf0mUXmW4xh7rDvALXf/f0VtOUiHlDUSPknu2kcfz1KzLpOJyL2pO+nZS13hhIjLqVgiQExLJrw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script>
      require.config({
        paths: {
          vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.36.1/min/vs',
        },
      });

      require(['vs/editor/editor.main'], function () {
        var editor = monaco.editor.create(document.getElementById('container'), {
          value: "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// The domain to connect to. Can be swapped for other domains hosting Socrata.\nconst Domain = \"data.ny.gov\";\n\n// The max number of columns to include in the sync table by default.\nconst MaxFeaturedColumns = 50;\n\n// How many rows to scan when determining the which columns to feature.\nconst TableScanMaxRows = 100;\n\n// How many rows to fetch per-page.\nconst PageSize = 100;\n\n// The maximum number of datasets to return in a search.\nconst MaxDatasets = 10000;\n\n// A regular expression matching a dataset.\nconst DatasetUrlRegex = new RegExp(`^https?://${Domain}/.*/([^?#]+)`);\n\n// Schema for an address (part of a location).\nconst AddressSchema = coda.makeObjectSchema({\n  properties: {\n    address: { type: coda.ValueType.String },\n    city: { type: coda.ValueType.String },\n    state: { type: coda.ValueType.String },\n    zip: { type: coda.ValueType.String },\n  },\n  displayProperty: \"address\",\n});\n\n// Schema for a location (used for locations and points).\nconst LocationSchema = coda.makeObjectSchema({\n  properties: {\n    coordinates: {\n      type: coda.ValueType.Array,\n      items: { type: coda.ValueType.Number },\n    },\n    latitude: { type: coda.ValueType.Number },\n    longitude: { type: coda.ValueType.Number },\n    address: { ...AddressSchema, fromKey: \"human_address\" },\n  },\n  displayProperty: \"coordinates\",\n});\n\n// A mapping from Socrata types to Coda schemas.\nconst TypeSchemaMap: Record<string, coda.Schema> = {\n  text: { type: coda.ValueType.String },\n  number: { type: coda.ValueType.Number },\n  checkbox: { type: coda.ValueType.Boolean },\n  calendar_date: {\n    type: coda.ValueType.String,\n    codaType: coda.ValueHintType.Date,\n  },\n  location: LocationSchema,\n  point: LocationSchema,\n  url: { type: coda.ValueType.String, codaType: coda.ValueHintType.Url },\n};\n\n// A base row schema, extended for each dataset.\nconst BaseRowSchema = coda.makeObjectSchema({\n  properties: {\n    rowId: { type: coda.ValueType.String, fromKey: \":id\" },\n  },\n  idProperty: \"rowId\",\n  displayProperty: \"rowId\",\n});\n\n\n// Allow requests to the domain.\npack.addNetworkDomain(Domain);\n\n// Use a system-wide application token to get additional quota.\n// https://dev.socrata.com/docs/app-tokens.html\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.CustomHeaderToken,\n  headerName: \"X-App-Token\",\n});\n\n// A dynamic sync table for the rows of a dataset.\npack.addDynamicSyncTable({\n  name: \"PublicDataset\",\n  identityName: \"DatasetRow\",\n  entityName: \"Row\",\n  // If new columns are added later, don't automatically feature them.\n  defaultAddDynamicColumns: false,\n\n  // Allow the user to browse the datasets by category.\n  listDynamicUrls: async function (context, category) {\n    if (!category) {\n      // Return the list of categories.\n      let categories = await getCategories(context);\n      return categories.map(category => {\n        return {\n          display: category,\n          value: category,\n          hasChildren: true,\n        };\n      });\n    }\n\n    // Return all the datasets in that category.\n    let datasets = await searchDatasets(context, {\n      categories: category,\n      only: \"datasets\",\n      domains: Domain,\n      search_context: Domain,\n      order: \"page_views_last_month\",\n      limit: MaxDatasets,\n    });\n    if (!datasets?.length) {\n      return [];\n    }\n    return datasets.map(dataset => {\n      return {\n        display: dataset.name,\n        value: dataset.link,\n      };\n    });\n  },\n\n  searchDynamicUrls: async function (context, search) {\n    let datasets = await searchDatasets(context, {\n      q: search,\n      only: \"datasets\",\n      domains: Domain,\n      search_context: Domain,\n      order: \"relevance\",\n      limit: MaxDatasets,\n    });\n    if (!datasets?.length) {\n      return [];\n    }\n    return datasets.map(dataset => {\n      return {\n        display: dataset.name,\n        value: dataset.link,\n      };\n    });\n  },\n\n  getName: async function (context) {\n    let dataset = await getDataset(context);\n    return dataset.name;\n  },\n\n  getSchema: async function (context) {\n    let dataset = await getDataset(context);\n\n    // Copy the base schema.\n    let schema: coda.GenericObjectSchema = {\n      ...BaseRowSchema,\n    };\n\n    // Add a schema property for each column.\n    for (let column of dataset.columns) {\n      let name = column.name;\n      let fieldName = column.fieldName;\n      let dataType = column.dataTypeName;\n      let description = column.description;\n\n      if (fieldName.startsWith(\":\")) {\n        // Skip internal fields.\n        continue;\n      }\n\n      let fieldSchema = TypeSchemaMap[dataType];\n      if (!fieldSchema) {\n        throw new Error(\"Couldn't find schema for column type: \" + dataType);\n      }\n\n      schema.properties[fieldName] = {\n        ...fieldSchema,\n        displayName: name,\n        description: description,\n      };\n    }\n\n    // Determine which columns to feature.\n    schema.featuredProperties = await getFeatured(dataset, context);\n\n    // Add attribution information.\n    schema.attribution = getAttribution(dataset);\n\n    return schema;\n  },\n\n  getDisplayUrl: async function (context) {\n    return context.sync.dynamicUrl;\n  },\n\n  formula: {\n    name: \"SyncDataset\",\n    description: \"Syncs the dataset.\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"search\",\n        description: \"If specified, only rows containing this search term \" +\n          \"will be included.\",\n        optional: true,\n      }),\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"filter\",\n        description: \"A SoQL $where clause to use to filter the results. \" +\n          \"https://dev.socrata.com/docs/queries/where.html\",\n        optional: true,\n      }),\n    ],\n    execute: async function ([search, filter], context) {\n      let dataset = await getDataset(context);\n      let offset = context.sync.continuation?.offset as number || 0;\n\n      // Only fetch the selected columns.\n      let fields = coda.getEffectivePropertyKeysFromSchema(context.sync.schema);\n\n      // Fetch the row data.\n      let baseUrl = `https://${Domain}/resource/${dataset.id}.json`;\n      let url = coda.withQueryParams(baseUrl, {\n        $select: fields.join(\",\"),\n        $q: search,\n        $where: filter,\n        $limit: PageSize,\n        $offset: offset,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let rows = response.body;\n\n      // Transform the rows to match the schema.\n      for (let row of rows) {\n        for (let [key, value] of Object.entries(row)) {\n          row[key] = formatValue(value);\n        }\n      }\n\n      let continution = null;\n      if (rows.length > 0) {\n        // Keep fetching rows until we get an empty page.\n        continution = { offset: offset + PageSize };\n      }\n\n      return {\n        result: rows,\n        continuation: continution,\n      };\n    },\n  },\n});\n\n/**\n * Reformat a row value to match the schema.\n */\nfunction formatValue(value) {\n  if (typeof value === \"object\") {\n    let obj = value as Record<string, any>;\n    if (obj.url) {\n      // Pull up the URL.\n      value = obj.url;\n    } else if (obj.type === \"Point\") {\n      // Format point to LocationSchema.\n      value = {\n        latitude: obj.coordinates[1],\n        longitude: obj.coordinates[0],\n        // A point's coordinates are returned as x,y instead of lat,long.\n        coordinates: obj.coordinates.reverse(),\n      };\n    } else if (obj.latitude && obj.longitude) {\n      // Format location to LocationSchema.\n      value = {\n        ...obj,\n        coordinates: [obj.latitude, obj.longitude],\n      };\n    }\n  }\n  return value;\n}\n\n/**\n * Get the list of dataset categories.\n */\nasync function getCategories(context: coda.ExecutionContext):\n  Promise<string[]> {\n  let baseUrl = `https://${Domain}/api/catalog/v1/domain_categories`;\n  let url = coda.withQueryParams(baseUrl, {\n    domains: Domain,\n  });\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body.results.map(result => result.domain_category);\n}\n\n/**\n * Search for datasets, using a flexible set of parameters.\n */\nasync function searchDatasets(context: coda.ExecutionContext,\n  params: Record<string, any>): Promise<DatasetResult[]> {\n  let url = coda.withQueryParams(`https://${Domain}/api/catalog/v1`, params);\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body.results.map(result => {\n    return {\n      ...result.resource,\n      ...result,\n    };\n  });\n}\n\n/**\n * Get a dataset by ID.\n */\nasync function getDataset(context: coda.ExecutionContext): Promise<Dataset> {\n  let datasetUrl = context.sync.dynamicUrl;\n  let datasetId = getDatasetId(datasetUrl);\n  let url = `https://${Domain}/api/views/${datasetId}.json`;\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body;\n}\n\n/**\n * Extract the ID of the dataset from it's URL.\n */\nfunction getDatasetId(url: string): string {\n  let match = url.match(DatasetUrlRegex);\n  if (!match) {\n    throw new coda.UserVisibleError(\"Invalid dataset URL: \" + url);\n  }\n  return match[1];\n}\n\n/**\n * Determine which rows to feature (include in the table by default) for a given\n * dataset.\n */\nasync function getFeatured(dataset: Dataset, context: coda.ExecutionContext):\n  Promise<string[]> {\n  // Fetch some of the first rows from the dataset.\n  let baseUrl = `https://${Domain}/resource/${dataset.id}.json`;\n  let url = coda.withQueryParams(baseUrl, {\n    $limit: TableScanMaxRows,\n  });\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  let rows = response.body;\n\n  // Count how many times each column has a value.\n  let columnCount: Record<string, number> = {};\n  for (let row of rows) {\n    for (let [key, value] of Object.entries(row)) {\n      if (!columnCount[key]) {\n        columnCount[key] = 0;\n      }\n      if (value) {\n        columnCount[key]++;\n      }\n    }\n  }\n\n  // Return the list of columns that have at least one value in the scanned\n  // rows, up to a defined maximum.\n  return dataset.columns.map(column => column.fieldName)\n    .filter(column => columnCount[column] > 0)\n    .filter(column => !column.startsWith(\":\"))\n    .slice(0, MaxFeaturedColumns);\n}\n\n/**\n * Get the attribution node for a given dataset.\n */\nfunction getAttribution(dataset: Dataset): coda.AttributionNode[] {\n  if (!dataset.attribution) {\n    return null;\n  }\n  let node;\n  if (dataset.attributionLink) {\n    node = coda.makeAttributionNode({\n      type: coda.AttributionNodeType.Link,\n      anchorText: dataset.attribution,\n      anchorUrl: dataset.attributionLink,\n    });\n  } else {\n    node = coda.makeAttributionNode({\n      type: coda.AttributionNodeType.Text,\n      text: dataset.attribution,\n    });\n  }\n  return [node];\n}\n\n\n// A dataset search result.\ninterface DatasetResult {\n  name: string;\n  link: string;\n}\n\n// The dataset metadata.\ninterface Dataset {\n  id: string;\n  name: string;\n  description: string;\n  columns: DatasetColumn[];\n  attribution: string;\n  attributionLink: string;\n}\n\n// A dataset column definition.\ninterface DatasetColumn {\n  name: string;\n  description: string;\n  fieldName: string;\n  dataTypeName: string;\n}",
          language: 'javascript',
          minimap: {enabled: false},
          readOnly: true,
          renderValidationDecorations: 'off',
          wordWrap: 'on',
          contextmenu: false,
        });
      });
    </script>
  </head>
  <body>
    <div id="container" style="position: absolute; top: 0; right: 16; bottom: 16; left: 0"></div>
  </body>
</html>
