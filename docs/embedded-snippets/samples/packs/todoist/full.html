<html>
  <head>
    <!-- Monaco library script is loaded from: https://cdnjs.com/libraries/monaco-editor-->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.38.0/min/vs/loader.min.js"
      integrity="sha512-A+6SvPGkIN9Rf0mUXmW4xh7rDvALXf/f0VtOUiHlDUSPknu2kcfz1KzLpOJyL2pO+nZS13hhIjLqVgiQExLJrw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script>
      require.config({
        paths: {
          vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.36.1/min/vs',
        },
      });

      require(['vs/editor/editor.main'], function () {
        var editor = monaco.editor.create(document.getElementById('container'), {
          value: "import * as coda from \"@codahq/packs-sdk\";\n\n// #region Constants\n\nconst ProjectUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/project/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showProject\\\\?id=([0-9]+)\"),\n];\n\nconst TaskUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showTask\\\\?id=([0-9]+)\"),\n];\n\n// #endregion\n\n\n// #region Pack setup\n\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"todoist.com\");\n\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // OAuth2 URLs and scopes are found in the Todoist OAuth guide:\n  // https://developer.todoist.com/guides/#oauth\n  authorizationUrl: \"https://todoist.com/oauth/authorize\",\n  tokenUrl: \"https://todoist.com/oauth/access_token\",\n  scopes: [\"data:read_write\"],\n  scopeDelimiter: \",\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = coda.withQueryParams(\"https://api.todoist.com/sync/v9/sync\", {\n      resource_types: JSON.stringify([\"user\"]),\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.user?.full_name;\n  },\n});\n\n// #endregion\n\n\n// #region Schemas\n\nconst DueSchema = coda.makeObjectSchema({\n  properties: {\n    date: {\n      description: \"The date the task is due.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Date,\n    },\n    time: {\n      description: \"The specific moment the task is due.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.DateTime,\n      fromKey: \"datetime\",\n    },\n    display: {\n      description: \"The display value for the due date.\",\n      type: coda.ValueType.String,\n      fromKey: \"string\",\n    },\n  },\n  displayProperty: \"display\",\n});\n\nconst ProjectSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the project.\",\n      type: coda.ValueType.String,\n      mutable: true,\n      required: true,\n    },\n    url: {\n      description: \"A link to the project in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    shared: {\n      description: \"Is the project is shared.\",\n      type: coda.ValueType.Boolean,\n      fromKey: \"is_shared\",\n    },\n    favorite: {\n      description: \"Is the project a favorite.\",\n      type: coda.ValueType.Boolean,\n      mutable: true,\n      fromKey: \"is_favorite\",\n    },\n    id: {\n      description: \"The ID of the project.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    parentProjectId: {\n      description: \"For sub-projects, the ID of the parent project.\",\n      type: coda.ValueType.String,\n      fromKey: \"parent_id\",\n    },\n  },\n  displayProperty: \"name\",\n  // Sync table metadata.\n  idProperty: \"id\",\n  featuredProperties: [\"url\", \"favorite\"],\n  // Card metadata.\n  linkProperty: \"url\",\n  subtitleProperties: [\"shared\", \"favorite\"],\n});\n\n// Create a reference schema for projects, to use for relation columns.\nconst ProjectReferenceSchema =\n  coda.makeReferenceSchemaFromObjectSchema(ProjectSchema, \"Project\");\n\n// Using the reference schema, add a property for the parent project.\n(ProjectSchema.properties as coda.ObjectSchemaProperties)\n  .parentProject = ProjectReferenceSchema;\n\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      fromKey: \"content\",\n      required: true,\n      mutable: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Markdown,\n      mutable: true,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    completed: {\n      description: \"If the task has been completed.\",\n      type: coda.ValueType.Boolean,\n      fromKey: \"is_completed\",\n      mutable: true,\n    },\n    order: {\n      description: \"The position of the task in the project or parent task.\",\n      type: coda.ValueType.Number,\n      mutable: true,\n    },\n    priority: {\n      description: \"The priority of the task.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.SelectList,\n      options: [\"P1\", \"P2\", \"P3\", \"P4\"],\n      mutable: true,\n    },\n    due: {\n      description: \"When the task is due.\",\n      ...DueSchema,\n    },\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    projectId: {\n      description: \"The ID of the project that the task belongs to.\",\n      type: coda.ValueType.String,\n      fromKey: \"project_id\",\n    },\n    parentTaskId: {\n      description: \"For sub-tasks, the ID of the parent task it belongs to.\",\n      type: coda.ValueType.String,\n      fromKey: \"parent_id\",\n    },\n    // A reference to the project (for sync tables only).\n    project: {\n      ...ProjectReferenceSchema,\n      mutable: true,\n    },\n  },\n  displayProperty: \"name\",\n  // Sync table metadata.\n  idProperty: \"id\",\n  featuredProperties: [\"project\", \"url\", \"completed\"],\n  // Card metadata.\n  linkProperty: \"url\",\n  snippetProperty: \"description\",\n  subtitleProperties: [\n    \"priority\",\n    \"completed\",\n    { label: \"Due\", property: \"due.display\" },\n  ],\n});\n\n// Create a reference schema for tasks, to use for relation columns.\nconst TaskReferenceSchema =\n  coda.makeReferenceSchemaFromObjectSchema(TaskSchema, \"Task\");\n\n// Using the reference schema, add a property for the parent task.\n(TaskSchema.properties as coda.ObjectSchemaProperties)\n  .parentTask = TaskReferenceSchema;\n\n// Format a project from the API and return an object matching the schema.\nfunction formatProjectForSchema(project: any, withReferences = false) {\n  let result: any = {\n    ...project,\n  };\n  if (withReferences && project.parent_id) {\n    result.parentProject = {\n      id: project.parent_id,\n      name: \"Not found\", // If sync'ed, the real name will be shown instead.\n    };\n  }\n  return result;\n}\n\n// Format a task from the API and return an object matching the Task schema.\nfunction formatTaskForSchema(task: any, withReferences = false) {\n  let result: any = {\n    ...task,\n    // Convert the priority to a string like \"P1\".\n    priority: \"P\" + (5 - task.priority),\n  };\n  if (withReferences) {\n    // Add a reference to the corresponding row in the Projects sync table.\n    result.project = {\n      id: task.project_id,\n      name: \"Not found\", // If sync'ed, the real name will be shown instead.\n    };\n    if (task.parent_id) {\n      // Add a reference to the corresponding row in the Tasks sync table.\n      result.parentTask = {\n        id: task.parent_id,\n        name: \"Not found\", // If sync'ed, the real name will be shown instead.\n      };\n    }\n  }\n  return result;\n}\n\n// Format a task from a sync table and return an object matching the API.\nfunction formatTaskForAPI(task: any) {\n  let result: any = {\n    ...task,\n  };\n  if (result.priority) {\n    // Convert the priority back to a number.\n    result.priority = 5 - Number(result.priority.substring(1));\n  }\n  return result;\n}\n\n// #endregion\n\n\n// #region Formulas\n\npack.addFormula({\n  name: \"Project\",\n  description: \"Gets a Todoist project by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the project\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: ProjectSchema,\n  execute: async function ([url], context) {\n    let projectId = extractProjectId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/projects/\" + projectId,\n      method: \"GET\",\n    });\n    return formatProjectForSchema(response.body);\n  },\n});\n\npack.addFormula({\n  name: \"Task\",\n  description: \"Gets a Todoist task by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n  execute: async function ([url], context) {\n    let taskId = extractTaskId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    return formatTaskForSchema(response.body);\n  },\n});\n\n// #endregion\n\n\n// #region Column Formats\n\npack.addColumnFormat({\n  name: \"Project\",\n  formulaName: \"Project\",\n  matchers: ProjectUrlPatterns,\n});\n\npack.addColumnFormat({\n  name: \"Task\",\n  formulaName: \"Task\",\n  matchers: TaskUrlPatterns,\n});\n\n// #endregion\n\n\n// #region Actions\n\npack.addFormula({\n  name: \"AddProject\",\n  description: \"Add a new Todoist project\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the new project\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function ([name], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/projects\",\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        name: name,\n      }),\n    });\n    return response.body.url;\n  },\n});\n\npack.addFormula({\n  name: \"AddTask\",\n  description: \"Add a new task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the task.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"projectId\",\n      description: \"The ID of the project to add it to. If blank, \" +\n        \"it will be added to the user's Inbox.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function ([name, projectId], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/tasks\",\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        content: name,\n        project_id: projectId,\n      }),\n    });\n    return response.body.url;\n  },\n});\n\npack.addFormula({\n  name: \"SetDueDate\",\n  description: \"Change the due date of a task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"taskId\",\n      description: \"The ID of the task.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"date\",\n      description: \"The date the task is due.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Boolean,\n      name: \"endOfDay\",\n      description:\n        \"If the task is due at the end of the day (vs a specific time).\",\n      suggestedValue: true,\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  // To update the existing row in a sync table, return the schema with an\n  // identity matching the identityName on the sync table being updated, using\n  // the helper function coda.withIdentity().\n  schema: coda.withIdentity(TaskSchema, \"Task\"),\n  isAction: true,\n  execute: async function ([taskId, date, endOfDay = false], context) {\n    let url = \"https://api.todoist.com/rest/v2/tasks/\" + taskId;\n    let payload: any = {\n      id: taskId,\n    };\n    if (endOfDay) {\n      payload.due_date = date.toISOString().split(\"T\")[0];\n    } else {\n      payload.due_datetime = date.toISOString();\n    }\n    let response = await context.fetcher.fetch({\n      method: \"POST\",\n      url: url,\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(payload),\n    });\n    return formatTaskForSchema(response.body);\n  },\n});\n\n// #endregion\n\n\n// #region Sync tables\n\npack.addSyncTable({\n  name: \"Projects\",\n  schema: ProjectSchema,\n  identityName: \"Project\",\n  formula: {\n    name: \"SyncProjects\",\n    description: \"Sync projects\",\n    parameters: [],\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v2/projects\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results: any[] = [];\n      for (let project of response.body) {\n        results.push(formatProjectForSchema(project, true));\n      }\n      return {\n        result: results,\n      };\n    },\n    // Process row updates one at a time.\n    maxUpdateBatchSize: 1,\n    executeUpdate: async function (args, updates, context) {\n      let update = updates[0];\n      let project = update.newValue;\n      let response = await context.fetcher.fetch({\n        method: \"POST\",\n        url: `https://api.todoist.com/rest/v2/projects/${project.id}`,\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(project),\n      });\n      let updated = formatProjectForSchema(response.body, true);\n\n      return {\n        result: [updated],\n      };\n    },\n  },\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"filter\",\n        description: \"A supported filter string. See the Todoist help center.\",\n        optional: true,\n      }),\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"project\",\n        description: \"Limit tasks to a specific project.\",\n        optional: true,\n        autocomplete: async function (context, search) {\n          let url = \"https://api.todoist.com/rest/v2/projects\";\n          let response = await context.fetcher.fetch({\n            method: \"GET\",\n            url: url,\n          });\n          let projects = response.body;\n          return coda.autocompleteSearchObjects(search, projects, \"name\", \"id\");\n        },\n      }),\n    ],\n    execute: async function ([filter, project], context) {\n      let url = coda.withQueryParams(\"https://api.todoist.com/rest/v2/tasks\", {\n        filter: filter,\n        project_id: project,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results: any[] = [];\n      for (let task of response.body) {\n        results.push(formatTaskForSchema(task, true));\n      }\n      return {\n        result: results,\n      };\n    },\n    // Process row updates in batches.\n    maxUpdateBatchSize: 10,\n    executeUpdate: async function (args, updates, context) {\n      // Generate the set of commands needed to process each update.\n      let commandSets = updates.map(update => generateTaskCommands(update));\n\n      // Send all of the commands to the sync endpoint.\n      let response = await context.fetcher.fetch({\n        method: \"POST\",\n        url: \"https://api.todoist.com/sync/v9/sync\",\n        form: {\n          commands: JSON.stringify(commandSets.flat()),\n        },\n      });\n      let statuses = response.body.sync_status;\n\n      // Process the results, returning either an error or the updated task.\n      // This is done async, so the fetches can be done in parallel.\n      let jobs = updates.map(async (update, i) => {\n        let taskId = update.newValue.id;\n        let commands = commandSets[i];\n        for (let command of commands) {\n          let status = statuses[command.uuid];\n          if (status.error) {\n            return new coda.UserVisibleError(status.error);\n          }\n        }\n        // If there were no errors, fetch the updated task and return it.\n        let response = await context.fetcher.fetch({\n          method: \"GET\",\n          url: `https://api.todoist.com/rest/v2/tasks/${taskId}`,\n          cacheTtlSecs: 0,\n        });\n        return formatTaskForSchema(response.body, true);\n      });\n      let results = await Promise.all(jobs);\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// Generate a list of API commands from a Task row update.\nfunction generateTaskCommands(update: coda.GenericSyncUpdate): any[] {\n  let commands: any[] = [];\n  let { previousValue, newValue, updatedFields } = update;\n\n  // Update the task.\n  commands.push({\n    type: \"item_update\",\n    uuid: getUniqueId(),\n    args: formatTaskForAPI(newValue),\n  });\n\n  // Update the parent project, if it has changed.\n  if (updatedFields.includes(\"project\")) {\n    commands.push({\n      type: \"item_move\",\n      args: {\n        id: newValue.id,\n        project_id: newValue.project?.id,\n      },\n      uuid: getUniqueId(),\n    });\n  }\n\n  // Update the completion status, if it's changed.\n  if (previousValue.is_completed !== newValue.is_completed) {\n    commands.push({\n      type: newValue.is_completed ? \"item_complete\" : \"item_uncomplete\",\n      uuid: getUniqueId(),\n      args: {\n        id: newValue.id,\n      },\n    });\n  }\n  return commands;\n}\n\n// #endregion\n\n\n// #region Helper functions\n\nfunction extractProjectId(projectUrl: string) {\n  for (let pattern of ProjectUrlPatterns) {\n    let matches = projectUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid project URL: \" + projectUrl);\n}\n\nfunction extractTaskId(taskUrl: string) {\n  for (let pattern of TaskUrlPatterns) {\n    let matches = taskUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid task URL: \" + taskUrl);\n}\n\nfunction getUniqueId() {\n  return Math.random().toString(36);\n}\n\n// #endregion",
          language: 'javascript',
          minimap: {enabled: false},
          readOnly: true,
          renderValidationDecorations: 'off',
          wordWrap: 'on',
          contextmenu: false,
        });
      });
    </script>
  </head>
  <body>
    <div id="container" style="position: absolute; top: 0; right: 16; bottom: 16; left: 0"></div>
  </body>
</html>
