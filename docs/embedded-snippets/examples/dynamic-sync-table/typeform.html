<html>
  <head>
    <!-- Monaco library script is loaded from: https://cdnjs.com/libraries/monaco-editor-->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.27.0/min/vs/loader.min.js"
      integrity="sha512-SExj71Cw3B9C9EE8BC/ad3AKia5zQXDj/2SM4THgkeKh5GIFZhKM/R3uclUG8YZwJrjcVhydAlIHmfNvsBCKZA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script>
      require.config({
        paths: {
          vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.27.0/min/vs',
        },
      });

      require(['vs/editor/editor.main'], function () {
        var editor = monaco.editor.create(document.getElementById('container'), {
          value: "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// How many responses to fetch per-page.\nconst PageSize = 100;\n\n// Add a dynamic sync table for form responses.\npack.addDynamicSyncTable({\n  name: \"FormResponses\",\n  description: \"Responses to a form.\",\n  identityName: \"FormResponse\",\n\n  // Returns the URLs of the available forms. The user will select one when they\n  // add the table to their doc. The selected URL will be passed as\n  // `context.sync.dynamicUrl` to other methods.\n  listDynamicUrls: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.typeform.com/forms\",\n    });\n    let forms = response.body.items;\n    let results = [];\n    for (let form of forms) {\n      // Each result should include the name and URL of the form.\n      results.push({\n        display: form.title,\n        // Using the API URL of the form, not the browser URL. This makes it\n        // easier to use the URL in the code, and `getDisplayUrl` below can\n        // show the browser URL to the user.\n        value: form.self.href,\n      });\n    }\n    return results;\n  },\n\n  // Returns the name of the table, given the selected URL.\n  getName: async function (context) {\n    let formUrl = context.sync.dynamicUrl;\n    let form = await getForm(context, formUrl);\n    return form.title;\n  },\n\n  // Returns the display version of the selected URL.\n  getDisplayUrl: async function (context) {\n    let formUrl = context.sync.dynamicUrl;\n    let form = await getForm(context, formUrl);\n    return form._links.display;\n  },\n\n  // Returns the schema of the table, given the selected URL.\n  getSchema: async function (context) {\n    let formUrl = context.sync.dynamicUrl;\n    let form = await getForm(context, formUrl);\n\n    // These properties are the same for all forms.\n    let properties: coda.ObjectSchemaProperties = {\n      submittedAt: {\n        type: coda.ValueType.String,\n        codaType: coda.ValueHintType.DateTime,\n      },\n      responseId: {\n        type: coda.ValueType.String,\n      },\n    };\n    // Use them as the display value and ID of the rows.\n    let displayProperty = \"submittedAt\";\n    let idProperty = \"responseId\";\n\n    // For each field in the form, add a property to the schema.\n    let featuredProperties = [];\n    for (let field of form.fields) {\n      // Format the field name into a valid property name.\n      let name = getPropertyName(field);\n      // Generate a schema for the field and add it to the set of properties.\n      properties[name] = getPropertySchema(field);\n      // Mark the property as featured (included in the table by default).\n      featuredProperties.push(name);\n    }\n\n    // Assemble the schema for each row.\n    let schema = coda.makeObjectSchema({\n      properties: properties,\n      displayProperty: displayProperty,\n      idProperty: idProperty,\n      featuredProperties: featuredProperties,\n    });\n\n    // Return an array schema as the result.\n    return coda.makeSchema({\n      type: coda.ValueType.Array,\n      items: schema,\n    });\n  },\n\n  // The formula that syncs the records.\n  formula: {\n    name: \"SyncResponses\",\n    description: \"Sync the form responses\",\n    parameters: [],\n    execute: async function ([], context) {\n      let formUrl = context.sync.dynamicUrl;\n\n      // Retrieve the token to continue from, if any.\n      let pageToken = context.sync.continuation?.token || null;\n\n      // Construct the API URL.\n      let url = coda.withQueryParams(formUrl + \"/responses\", {\n        page_size: PageSize,\n        before: pageToken,\n      });\n\n      // Fetch a page of responses.\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n        // Disable HTTP caching, so we always get the latest results.\n        cacheTtlSecs: 0,\n      });\n      let formResponses = response.body.items;\n\n      // Reformat each response to match the schema.\n      let rows = [];\n      for (let formResponse of formResponses) {\n        // Include the metadata common to all forms.\n        let row = {\n          submittedAt: formResponse.submitted_at,\n          responseId: formResponse.response_id,\n        };\n\n        // For each answer, add it to the row.\n        for (let answer of formResponse.answers) {\n          // Get the key to return the value in.\n          let key = getPropertyKey(answer.field);\n          let value = getPropertyValue(answer);\n          row[key] = value;\n        }\n        rows.push(row);\n      }\n\n      // Determine if we need to fetch more pages.\n      let continuation;\n      if (formResponses.length > 0) {\n        // Continue onward from the token of the last response.\n        let lastToken = formResponses[formResponses.length - 1].token;\n        continuation = {\n          token: lastToken,\n        };\n      }\n\n      // Return the rows and the continuation, if any.\n      return {\n        result: rows,\n        continuation: continuation,\n      };\n    },\n  },\n});\n\n// Get metadata about a form given it's URL.\nasync function getForm(context, url) {\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n    // Disable HTTP caching, so we always get the latest result.\n    cacheTtlSecs: 0,\n  });\n  return response.body;\n}\n\n// Generates a property name given a field title.\nfunction getPropertyName(field) {\n  return (\n    field.title\n      // Replace placeholders with an X.\n      .replace(/\\{\\{.*?\\}\\}/g, \"X\")\n  );\n}\n\n// Generates a property schema based on a Typeform field.\nfunction getPropertySchema(field) {\n  let schema: any = {\n    // Use the field's full title as it's description.\n    description: field.title,\n    // The sync formula will return the value keyed using the field's ID.\n    fromKey: getPropertyKey(field),\n  };\n\n  // Set the schema type depending on the field type.\n  switch (field.type) {\n    case \"yes_no\":\n      schema.type = coda.ValueType.Boolean;\n      break;\n    case \"number\":\n    case \"opinion_scale\":\n    case \"rating\":\n      schema.type = coda.ValueType.Number;\n      break;\n    case \"date\":\n      schema.type = coda.ValueType.String;\n      schema.codaType = coda.ValueHintType.Date;\n      break;\n    case \"multiple_choice\":\n      let isMultiselect = field.properties.allow_multiple_selection;\n      if (isMultiselect) {\n        schema.type = coda.ValueType.Array;\n        schema.items = {\n          type: coda.ValueType.String,\n        };\n      } else {\n        schema.type = coda.ValueType.String;\n      }\n      break;\n    default:\n      // Default to strings.\n      schema.type = coda.ValueType.String;\n  }\n\n  return schema;\n}\n\n// Gets the key to use for this field when returning the value in the sync\n// formula.\nfunction getPropertyKey(field) {\n  return field.id;\n}\n\n// Gets the value from a Typeform answer.\nfunction getPropertyValue(answer) {\n  switch (answer.type) {\n    case \"choice\":\n      return answer.choice.label;\n    case \"choices\":\n      return answer.choices.labels;\n    default:\n      // The value is stored in a field with the same name as the type of the\n      // answer.\n      return answer[answer.type];\n  }\n}\n\n// Configure per-user authentication, using OAuth2.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // See: https://developer.typeform.com/get-started/applications/\n  authorizationUrl: \"https://api.typeform.com/oauth/authorize\",\n  tokenUrl: \"https://api.typeform.com/oauth/token\",\n  // See: https://developer.typeform.com/get-started/scopes/\n  scopes: [\"forms:read\", \"responses:read\", \"accounts:read\"],\n\n  // Get the name of the account from the Typeform API.\n  getConnectionName: async function (context) {\n    let url = \"https://api.typeform.com/me\";\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    let profile = response.body;\n    return profile.alias;\n  },\n});\n\n// Allow requests to the typeform.com domain.\npack.addNetworkDomain(\"typeform.com\");",
          language: 'javascript',
          minimap: {enabled: false},
          readOnly: true,
          renderValidationDecorations: 'off',
          wordWrap: 'on',
          contextmenu: false,
        });
      });
    </script>
  </head>
  <body>
    <div id="container" style="position: absolute; top: 0; right: 16; bottom: 16; left: 0"></div>
  </body>
</html>
