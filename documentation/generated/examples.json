[
  {
    "name": "addColumnFormat()",
    "triggerTokens": [
      "addColumnFormat"
    ],
    "sdkReferencePath": "/classes/PackDefinitionBuilder.html#addColumnFormat",
    "content": "A **column format** is a custom column type that you apply to any column in any Coda table. A column format& tells Coda to interpret the value in a cell by executing a **formula** using that value, typically looking up data related to that value from a third-party API.\n\nFor example, the Weather pack has a column format `Current Weather`; when applied to a column, if you type a city or address into a cell in that column, that location will be used an input to a formula that fetches the current weather at that location, and the resulting object with weather info will be shown in the cell.",
    "exampleSnippets": [
      {
        "name": "Column Format with No Matchers",
        "content": "Basic **Column Format** example without any matchers. ",
        "code": "// Replace all <text> with your own text\n// A custom column type that you apply to any column in any Coda table.\npack.addColumnFormat({\n  name: '<format name>',\n  formulaNamespace: '<the name of a formula in this pack>', // this will be deprecated\n  formulaName: '<the name of a formula to execute using the value in the column>',\n  instructions: '<instruction text that will be visible by Users>',\n  // Optional, regular expressions that detect urls that are handeable by this column format. When a\n  // user pastes a url that matches any of these, the UI will hint to the user that they can apply\n  // this format to their column.\n  matchers: [],\n});"
      }
    ]
  },
  {
    "name": "Authentication",
    "triggerTokens": [
      "setSystemAuthentication",
      "setUserAuthentication"
    ],
    "sdkReferencePath": "/classes/PackDefinitionBuilder.html#setSystemAuthentication",
    "content": "The SDK broadly divides authentication into two categories: authentication that is tied to the user of the pack vs authentication that is managed by the system, aka the pack author. In the pack definition the former is known as `defaultAuthentication` and the latter `systemConnectionAuthentication`. You will typically specify one or the other in your pack definition, or neither if your pack does not make http requests or those requests do not require authentication.\n\nDefault authentication is the most common. Specify this if each user of your pack should log in with OAuth, or have their own API key, or whatever user-specific token is necessary for the pack to be able to retrieve data that is specific to that user.\n\nUse system authentication if you as the pack author will provide the necessary tokens to successfully make http requests within your pack. An example would be if your pack returns weather forecasts and the API involved requires an API key, but individual users need not provide their own API key. You as the pack author will register an API key and provide it to Coda, and Coda will apply it to all pack requests regardless of the user.",
    "exampleSnippets": [
      {
        "name": "System Authentication",
        "content": "",
        "code": "pack.setSystemAuthentication({\n  // Replace HeaderBearerToken with an authentication type.\n  // (Not all authentication types are available for system authentication.)\n  type: coda.AuthenticationType.HeaderBearerToken,\n});"
      },
      {
        "name": "User Authentication",
        "content": "",
        "code": "pack.setUserAuthentication({\n  // Replace None with the authentication type that applies for your pack.\n  type: coda.AuthenticationType.None,\n});"
      }
    ]
  },
  {
    "name": "addDynmaicSyncTable()",
    "triggerTokens": [
      "addDynamicSyncTable"
    ],
    "sdkReferencePath": "/classes/PackDefinitionBuilder.html#addDynamicSyncTable",
    "content": "Most sync tables have schemas that can be statically defined. For example, if you're writing a sync of a user's Google Calendar events, the structure of an Event from the Google Calendar API is well-known and you can write a schema for what your table should contain.\n\nIn certain cases, you may want to sync data whose structure is not known in advance and may depend on the user doing the sync. For example, Coda's Jira pack allows users to sync data from their Jira instance, but Jira lets users create arbitrary custom fields for their Issue objects. So the schema of the Issues sync table is not known in advance; it depends on the Jira account that the user is syncing from.\n\nCoda supports \"dynamic\" sync tables for cases like these. Instead of including a static schema in your sync table definition, you include a formula that returns a schema. This formula can use the fetcher to make authenticated http requests to your pack's API so that you may retrieve any necessary info from that third-party service needed to construct an appropriate schema.\n\nTo define a dynamic schema, use the `makeDynamicSyncTable()` wrapper function. You will provide a `getSchema` formula that returns a schema definition. You'll also provide some supporting formulas like `getName`, to return a name in the UI for the table, in case even the name of the entities being synced is dynamic.\n\nThere are two subtle variants of dynamic sync tables. A sync table can be dynamic simply because the shape of the entities being synced vary based on who the current user is. For example, in the Jira example, Jira Issues are synced by hitting the same static Jira API url for Issues, but the schema of the issues returned will be different depending on the configuration of the Jira instance of the calling user.\n\nAlternatively, a sync table can be dynamic because the data source is specific to each instance of the table. If you were building a sync table to sync data from a Google Sheet, the data source would be the API url of a specific sheet. In this case, the sync table will be bound to a `dynamicUrl` that defines the data source. This url will be available to all of the formulas to implement the sync table in the sync context, as `context.sync.dynamicUrl`. To create a sync table that uses dynamic urls, you must implement the `listDynamicUrls` metadata formula in your dynamic sync table definition.",
    "exampleSnippets": [
      {
        "name": "Basic Dynamic Sync Table",
        "content": "",
        "code": "// Replace all <text> with your own names\npack.addDynamicSyncTable({\n  // The static name for this category of sync table\n  name: '<MyDynamicSynctable>',\n  // The display name for the table, shown in the UI.\n  getName: async context => {\n    const response = await context.fetcher.fetch({method: 'GET', url: context.sync.dynamicUrl});\n    // Return whatever represents the name of the entity you're syncing.\n    return response.body.name;\n  },\n  // A label for the kind of entities that you are syncing.\n  // Using Google Sheets as example you might use \"Row\" here, as each synced entity is a row from the source sheet.\n  entityName: '<RowName>',\n  getSchema: async () => {\n    return coda.makeSchema({\n      type: coda.ValueType.Array,\n      items: coda.makeObjectSchema({\n        type: coda.ValueType.Object,\n        // The property name from the properties object below that represents the unique\n        // identifier of this item. A sync table MUST have a stable unique identifier. Without\n        // one, each subsequent sync will wipe away all rows and recreate them from scratch.\n        id: '<idColumn>',\n        // The property name from the properties object below that should label this item\n        // in the UI. All properties can be seen when hovering over a synced item in the UI,\n        // but the primary property value is shown on the chip representing the full object.\n        primary: '<displayColumn>',\n        // The columns that will be displayed on the table\n        featured: ['<otherColumn>'],\n        // The actual schema properties.\n        properties: {\n          // Add your properties here e.g.\n          // idColumn: {type: coda.ValueType.Number},\n          // displayColumn: {type: coda.ValueType.String},\n          // otherColumn: {type: coda.ValueType.String},\n        },\n      }),\n    });\n  },\n  // A user-friendly url representing the entity being synced. The table UI in the doc will provide\n  // a convenience link to this url so the user can easily click through to the source of data in that table.\n  getDisplayUrl: async context => {\n    const response = await context.fetcher.fetch({method: 'GET', url: context.sync.dynamicUrl});\n    // Return whatever represents a browser-friendly version of the dynamic url.\n    return response.body.browserLink;\n  },\n  formula: {\n    // This is the name that will be called in the formula builder.\n    // Remember, your formula name cannot have spaces in it.\n    name: '<DynamicSyncTable>',\n    description: '<Creates a dynamic sync table>',\n\n    // If your formula requires one or more inputs, you’ll define them here.\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: '<myParam>',\n        description: '<My description>',\n      }),\n    ],\n    // Everything inside this statement will execute anytime your Coda function is called in a doc.\n    execute: async function ([myParam], context) {\n      return {\n        result: [\n          // {\n          //   idPropertyName: 1,\n          //   displayPropertyName: '<Example1>',\n          //   otherPropertyName: myParam,\n          // },\n        ],\n      };\n    },\n  },\n});"
      }
    ]
  },
  {
    "name": "addFormula()",
    "triggerTokens": [
      "addFormula"
    ],
    "sdkReferencePath": "/classes/PackDefinitionBuilder.html#addFormula",
    "content": "A **formula (including a button)** is a JavaScript function that will be exposed as a Coda formula, that you can use anywhere in a Coda doc that you can use any normal formula. Formulas take basic Coda types as input, like strings, numbers, dates, booleans, and arrays of these types, and return any of these types or objects whose properties are any of these types. Buttons are just a flavor of a formula with the flag `isButton` activated.",
    "exampleSnippets": [
      {
        "name": "Basic Formula",
        "content": "",
        "code": "// Replace all <text> with your own text\npack.addFormula({\n  // This sets the return type of the formula.\n  resultType: coda.ValueType.String,\n\n  // This is the name that will be called in the formula builder.\n  // Remember, your formula name cannot have spaces in it.\n  name: '<Hello>',\n  description: '<A Hello World example.>',\n\n  // If your formula requires one or more inputs, you’ll define them here.\n  // Create more parameters with /Parameter.\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: '<myParam>',\n      description: '<My description>',\n    }),\n  ],\n\n  // Everything inside this execute statement will happen anytime your Coda function is called in a doc.\n  execute: async function ([myParam], context) {\n    // Here, myParam is the first parameter you’ve defined above: the “name” input.\n    return 'Hello ' + myParam + '!';\n  },\n});"
      }
    ]
  },
  {
    "name": "addSyncTable()",
    "triggerTokens": [
      "addSyncTable"
    ],
    "sdkReferencePath": "/classes/PackDefinitionBuilder.html#addSyncTable",
    "content": "A **sync table** is how to bring structured data from a third-party into Coda. A sync table is a table that you can add to a Coda doc that gets its rows from a third-party data source, that can be refreshed regularly to pull in new or updated data. A sync table is powered by a **formula** that takes parameters that represent sync options and returns an array of objects representing row data. A sync table also includes a schema describing the structure of the returned objects.",
    "exampleSnippets": [
      {
        "name": "Basic Sync Table",
        "content": "",
        "code": "// Replace all <text> with your own text\npack.addSyncTable({\n  // The display name for the table, shown in the UI.\n  name: '<MySyncTable>',\n  // The unique identifier for the table.\n  identityName: '<TableName>',\n  schema: coda.makeObjectSchema({\n    type: coda.ValueType.Object,\n    // The property name from the properties object below that represents the unique\n    // identifier of this item. A sync table MUST have a stable unique identifier. Without\n    // one, each subsequent sync will wipe away all rows and recreate them from scratch.\n    id: '<idColumn>',\n    // The property name from the properties object below that should label this item\n    // in the UI. All properties can be seen when hovering over a synced item in the UI,\n    // but the primary property value is shown on the chip representing the full object.\n    primary: '<displayColumn>',\n    // The actual schema properties.\n    properties: {\n      // Add your properties here e.g.\n      // idColumn: {type: coda.ValueType.String},\n      // displayColumn: {type: coda.ValueType.String},\n      // otherColumn: {type: coda.ValueType.Number},\n    },\n  }),\n  formula: {\n    // This is the name that will be called in the formula builder.\n    // Remember, your formula name cannot have spaces in it.\n    name: '<SyncTable>',\n    description: '<Creates a sync table>',\n\n    // If your formula requires one or more inputs, you’ll define them here.\n    // You can change the coda.Type to anything but object.\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: '<myParam>',\n        description: '<My description>',\n      }),\n    ],\n    // Everything inside this statement will execute anytime your Coda function is called in a doc.\n    execute: async function ([myParam], context) {\n      const response = await context.fetcher.fetch({method: 'GET', url: '<your url>'});\n      return {\n        result: [\n          {\n            // idColumn: 'Example1',\n            // displayColumn: response.body,\n            // otherColumn: myParam,\n          },\n        ],\n      };\n    },\n  },\n});"
      }
    ]
  }
]