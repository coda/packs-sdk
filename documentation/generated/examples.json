[
  {
    "name": "Column formats",
    "description": "Samples that show how to create a column format.",
    "icon": "material/table-column",
    "category": "Topic",
    "triggerTokens": [
      "addColumnFormat"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/blocks/column-formats"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/blocks/column-formats",
    "learnMoreLink": "/guides/blocks/column-formats",
    "content": "A **column format** is a custom column type that you apply to any column in any Coda table. A column format tells Coda to interpret the value in a cell by executing a **formula** using that value, typically looking up data related to that value from an external API.\n\nFor example, the Weather pack has a column format `Current Weather`; when applied to a column, if you type a city or address into a cell in that column, that location will be used as an input to a formula that fetches the current weather at that location, and the resulting object with weather info will be shown in the cell.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "The basic structure of a column format.",
        "code": "pack.addColumnFormat({\n  name: \"My Column Format\",\n  instructions: \"My description.\",\n  formulaName: \"MyFormula\",\n  matchers: [\n    // TODO: If formatting a URL, add a regular expression that matches it.\n  ],\n});"
      },
      {
        "name": "Text (Reverse)",
        "content": "A column format that formats text. This sample displays the text in the cell in reverse.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Adds a column format to the Pack, which will display the contents of the\n// column in reverse order.\npack.addColumnFormat({\n  name: \"Reversed Text\",\n  instructions: \"Whatever text you enter into this column will be reversed.\",\n  // The formula \"Reverse()\" (defined below) will be run on the content of the\n  // column to determine it's display value.\n  formulaName: \"Reverse\",\n});\n\n// Adds a formula to this Pack to reverse text. It is used by the column format\n// above, but can also be used on it's own anywhere in the doc.\npack.addFormula({\n  resultType: coda.ValueType.String,\n  name: \"Reverse\",\n  description: \"Reverses text.\",\n  parameters: [\n    // Formulas used in column formats can have only one required parameter.\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"input\",\n      description: \"The text to reverse.\",\n    }),\n    // Optional parameters can't be set when run as a column format.\n    coda.makeParameter({\n      type: coda.ParameterType.Boolean,\n      name: \"byWord\",\n      description: \"Reverse the text word-by-word.\",\n      suggestedValue: false,\n      optional: true,\n    }),\n  ],\n  execute: async function ([input, byWord = false]) {\n    let separator = \"\";\n    if (byWord) {\n      separator = \" \";\n    }\n    return input.split(separator).reverse().join(separator);\n  },\n});"
      },
      {
        "name": "Text (Roman Numeral)",
        "content": "A column format that formats a number as text. This sample displays the number in the cell as a Roman numeral.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Adds a column format to the Pack, which will display the contents of the\n// column as Roman numerals.\npack.addColumnFormat({\n  name: \"Roman Numeral\",\n  instructions: \"Displays the number as a Roman numeral.\",\n  formulaName: \"RomanNumeral\",\n});\n\n// Adds a formula to this Pack to convert a number to a Roman numeral. It is\n// used by the column format above, but can also be used on it's own anywhere in\n// the doc.\npack.addFormula({\n  name: \"RomanNumeral\",\n  description: \"Converts a number to the equivalent Roman numeral.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"value\",\n      description: \"The number to convert.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([value], context) {\n    let pairs = Object.entries(NumberMapping);\n    // Sort the pairs by the number, largest to smallest.\n    pairs.sort((a, b) => b[1] - a[1]);\n    let result = \"\";\n    for (let [roman, num] of pairs) {\n      while (value >= num) {\n        result += roman;\n        value -= num;\n      }\n    }\n    return result;\n  },\n});\n\nconst NumberMapping = {\n  I: 1, IV: 4, V: 5, IX: 9, X: 10, XL: 40, L: 50, XC: 90, C: 100, CD: 400,\n  D: 500, CM: 900, M: 1000,\n};"
      },
      {
        "name": "Text (Progress Bar)",
        "content": "A column format that formats a number as graphic. This sample displays the number in the cell as a progress bar.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Adds a column format to the Pack, which will display the contents of the\n// column as a progress bar.\npack.addColumnFormat({\n  name: \"Progress Bar\",\n  instructions: \"Draws a progress bar with the given percentage.\",\n  formulaName: \"ProgressBar\",\n});\n\n// Adds a formula to this Pack to draw a number as a progress bar. It is used by\n// the column format above, but can also be used on it's own anywhere in the\n// doc.\npack.addFormula({\n  name: \"ProgressBar\",\n  description: \"Draws a progress bar.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"percentage\",\n      description: \"The percentage complete, as a number between 0 and 1.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([percentage], context) {\n    if (percentage < 0 || percentage > 1) {\n      throw new coda.UserVisibleError(\"Percentage must be between 0 and 1.\");\n    }\n    let chars = Math.floor(percentage * 10);\n    return \"⬛\".repeat(chars) + \"⬜\".repeat(10 - chars);\n  },\n});"
      },
      {
        "name": "Image (Cats)",
        "content": "A column format that formats text as an image. This sample displays the text in the cell as an overlay on a random image of a cat.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Column format that displays the cell's value within a random cat image,\n// using the CatImage() formula defined above.\npack.addColumnFormat({\n  name: \"Cat Image\",\n  instructions: \"Displays the text over the image of a random cat.\",\n  formulaName: \"CatImage\",\n});\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text], context) {\n    let url = \"https://cataas.com/cat/says/\" + encodeURIComponent(text);\n    url = coda.withQueryParams(url, {\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");"
      },
      {
        "name": "Rich data (Todoist)",
        "content": "A column format that formats a URL as rich data. This sample displays the URL of the Todoist task in the cell as a rich data chip.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\n\n// Regular expressions that match Todoist task URLs. Used by the column format\n// and also the formula that powers it.\nconst TaskUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showTask\\\\?id=([0-9]+)\"),\n];\n\nexport const pack = coda.newPack();\n\n// Add a column format that displays a task URL as rich metadata.\npack.addColumnFormat({\n  name: \"Task\",\n  // The formula \"Task\" below will get run on the cell value.\n  formulaName: \"Task\",\n  // If the first values entered into a new column match these patterns then\n  // this column format will be automatically applied.\n  matchers: TaskUrlPatterns,\n});\n\n// A schema defining the rich metadata to be returned.\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"taskId\",\n});\n\n// Formula that looks up rich metadata about a task given it's URL. This is used\n// by the \"Task\" column format above, but is also a regular formula that can be\n// used elsewhere.\npack.addFormula({\n  name: \"Task\",\n  description: \"Gets a Todoist task by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n\n  execute: async function ([url], context) {\n    let taskId = extractTaskId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    let task = response.body;\n    return {\n      name: task.content,\n      description: task.description,\n      url: task.url,\n      taskId: task.id,\n    };\n  },\n});\n\n// Helper function to extract the Task ID from the URL.\nfunction extractTaskId(taskUrl: string) {\n  for (let pattern of TaskUrlPatterns) {\n    let matches = taskUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid task URL: \" + taskUrl);\n}\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      }
    ]
  },
  {
    "name": "Authentication",
    "description": "Samples that show how to authenticate with an API.",
    "icon": "material/account-key",
    "category": "Topic",
    "triggerTokens": [
      "setSystemAuthentication",
      "setUserAuthentication"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/basics/authentication"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/basics/authentication",
    "learnMoreLink": "/guides/basics/authentication",
    "content": "Adding authentication to your Pack allows you to pass credentials with your API requests. Simply specify the type of authentication to use and Coda will collect the credentials from the user, store them, and apply them to Fetcher requests. Per-user authentication is the most common, where each user connects to their own account, while system-wide authentication is used in cases where the Pack maker's keys are used for all users.\n\nCoda supports a fixed set of authentication types which cover the most common patterns that APIs use. In addition you can define your own form of custom token authentication to support more complex scenarios. It's not possible to write completely custom authentication code however, as Coda alone has access to the user's credentials.",
    "exampleSnippets": [
      {
        "name": "Authorization header",
        "content": "Authentication that passes a long-lived token in the Authorization header using the \"Bearer\" scheme. This sample connects to the Todoist API.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Todoist API, using a personal API token in\n// an \"Authorization: Bearer ...\" header.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = coda.withQueryParams(\"https://api.todoist.com/sync/v9/sync\", {\n      resource_types: JSON.stringify([\"user\"]),\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.user?.full_name;\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");"
      },
      {
        "name": "Custom header",
        "content": "Authentication that passes a long-lived token in a custom header. This sample connects to RapidAPI.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// System-wide authentication to RapidAPI, using an API key in a custom header.\n// See https://docs.rapidapi.com/docs/keys#how-to-find-your-api-key.\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.CustomHeaderToken,\n  headerName: \"X-RapidAPI-Key\",\n});\n\n// Allow the pack to make requests to RapidAPI.\npack.addNetworkDomain(\"rapidapi.com\");"
      },
      {
        "name": "Multiple headers",
        "content": "Authentication that passes multiple long-lived token in a HTTP headers. This sample connects to the Copper API.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Copper API, using multiple HTTP headers.\n// See https://developer.copper.com/introduction/requests.html#headers.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.MultiHeaderToken,\n  headers: [\n    { name: \"X-PW-AccessToken\", description: \"API key\" },\n    { name: \"X-PW-UserEmail\", description: \"Email address\" },\n  ],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.copper.com/developer_api/v1/account\",\n      headers: {\n        \"X-PW-Application\": \"developer_api\",\n      },\n    });\n    let account = response.body;\n    return account.name;\n  },\n});\n\n// Allow the pack to make requests to Copper.\npack.addNetworkDomain(\"copper.com\");"
      },
      {
        "name": "Query parameter",
        "content": "Authentication that passes a long-lived token in a query parameter. This sample connects to the Giphy API.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// System-wide authentication to the Giphy API, using an API key in the query\n// string. See https://support.giphy.com/hc/en-us/articles/360020283431.\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.QueryParamToken,\n  paramName: \"api_key\",\n});\n\n// Allow the pack to make requests to Giphy.\npack.addNetworkDomain(\"giphy.com\");"
      },
      {
        "name": "Multiple query parameters",
        "content": "Authentication that passes multiple long-lived tokens in query parameters. This sample connects to the Smarty API.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Smarty API, using multiple query parameters.\n// See https://www.smarty.com/docs/cloud/authentication#keypairs\npack.setUserAuthentication({\n  type: coda.AuthenticationType.MultiQueryParamToken,\n  params: [\n    { name: \"auth-id\", description: \"The Auth ID of the secret key.\" },\n    { name: \"auth-token\", description: \"The Auth Token of the secret key.\" },\n  ],\n});\n\n// Allow the pack to make requests to Smarty.\npack.addNetworkDomain(\"smartystreets.com\");"
      },
      {
        "name": "Custom tokens",
        "content": "Authentication that passes any number of custom tokens in the URL, headers, or request body. This sample connects to the Vonage SMS API.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Vonage API, using an API key and secret\n// in the request body.\n// See https://developer.vonage.com/en/api/sms\npack.setUserAuthentication({\n  type: coda.AuthenticationType.Custom,\n  params: [\n    { name: \"api_key\", description: \"API key.\" },\n    { name: \"api_secret\", description: \"API secret.\" },\n  ],\n});\n\npack.addFormula({\n  name: \"SendSMS\",\n  description: \"Sends an SMS message.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"from\",\n      description: \"The phone number to send from.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"to\",\n      description: \"The phone number to send to.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"The text of the message.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function ([from, to, text], context) {\n    // Create the placeholders for the API key and secret.\n    let invocationToken = context.invocationToken;\n    let apiKeyPlaceholder = \"{{api_key-\" + invocationToken + \"}}\";\n    let apiSecretPlaceholder = \"{{api_secret-\" + invocationToken + \"}}\";\n\n    // Construct the JSON request body.\n    let body = {\n      from: from,\n      to: to,\n      text: text,\n      // These placeholders will be automatically replaced with the user's key\n      // and secret before the request is made.\n      api_key: apiKeyPlaceholder,\n      api_secret: apiSecretPlaceholder,\n    };\n\n    let response = await context.fetcher.fetch({\n      method: \"POST\",\n      url: \"https://rest.nexmo.com/sms/json\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    });\n\n    let message = response.body.messages[0];\n    if (message.status !== \"0\") {\n      throw new coda.UserVisibleError(message[\"error-text\"]);\n    }\n    return message[\"message-id\"];\n  },\n});\n\n// Allow the pack to make requests to Vonage (former Nexmo).\npack.addNetworkDomain(\"nexmo.com\");"
      },
      {
        "name": "Username and password",
        "content": "Authentication that passes a username and password in the Authorization header using the \"Basic\" scheme. This sample connects to the Twilio API.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Twilio API, using an Account SID and token in\n// an \"Authorization: Basic ...\" header.\n// See https://www.twilio.com/docs/usage/requests-to-twilio\npack.setUserAuthentication({\n  type: coda.AuthenticationType.WebBasic,\n  instructionsUrl: \"https://www.twilio.com/docs/sms/api#sms-api-authentication\",\n\n  // Use Twilio-specific placeholders for the username and password fields.\n  uxConfig: {\n    placeholderUsername: \"Account SID\",\n    placeholderPassword: \"Auth Token\",\n  },\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function(context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.twilio.com/2010-04-01/Accounts.json\",\n    });\n    // Return the name of the main account.\n    return response.body.accounts[0].friendly_name;\n  },\n});\n\n// Allow the pack to make requests to Twilio.\npack.addNetworkDomain(\"twilio.com\");"
      },
      {
        "name": "Coda API token",
        "content": "Authentication optimized for connecting to the Coda API, which is a token passed in the Authorization header.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Coda API, using a token in the Authorization\n// header.\n// See https://coda.io/developers/apis/v1\npack.setUserAuthentication({\n  type: coda.AuthenticationType.CodaApiHeaderBearerToken,\n\n  // Creates the token automatically when the Pack is installed.\n  shouldAutoAuthSetup: true,\n});\n\n// Allow the pack to make requests to Coda.\npack.addNetworkDomain(\"coda.io\");"
      },
      {
        "name": "AWS Signature Version 4",
        "content": "Authentication that supports Amazon Web Services (AWS), using an access key and secret. This sample connects to the S3 service.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the AWS S3 service, using AWS Signature Version 4.\n// The user provides the URL of their S3 bucket as the endpoint, along with an\n// access key and secret.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.AWSAccessKey,\n  instructionsUrl:\n    \"https://aws.amazon.com/premiumsupport/knowledge-center/create-access-key/\",\n\n  // The AWS service to connect to.\n  service: \"s3\",\n\n  // Prompt the user from their S3 bucket URL.\n  requiresEndpointUrl: true,\n  endpointDomain: \"amazonaws.com\",\n\n  // Use the bucket name as the display name for the account.\n  getConnectionName: async function (context) {\n    return context.endpoint.split(\"//\")[1].split(\".\")[0];\n  },\n});"
      },
      {
        "name": "OAuth2",
        "content": "Authentication that uses an OAuth2 flow. This sample connects to the Todoist API.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Todoist API, using an OAuth2 flow.\n// See https://developer.todoist.com/guides/#oauth\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://todoist.com/oauth/authorize\",\n  tokenUrl: \"https://todoist.com/oauth/access_token\",\n  scopes: [\"data:read_write\"],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = coda.withQueryParams(\"https://api.todoist.com/sync/v9/sync\", {\n      resource_types: JSON.stringify([\"user\"]),\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.user?.full_name;\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");"
      },
      {
        "name": "Manual endpoint",
        "content": "Authentication that requires users to enter the endpoint URL for their account. This sample connects to the Okta API.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Okta API, using a custom token prefix and\n// account-specific endpoints.\n// See https://developer.okta.com/docs/reference/core-okta-api/#authentication\npack.setUserAuthentication({\n  type: coda.AuthenticationType.CustomHeaderToken,\n  headerName: \"Authorization\",\n  tokenPrefix: \"SSWS\",\n\n  // Ask users for their Okta subdomain.\n  requiresEndpointUrl: true,\n  endpointDomain: \"okta.com\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function(context) {\n    // Retrieve the endpoint that the user set.\n    let endpoint = context.endpoint;\n    let url = endpoint + \"/api/v1/org\";\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.companyName;\n  },\n});\n\n// Allow the pack to make requests to Okta.\npack.addNetworkDomain(\"okta.com\");"
      },
      {
        "name": "Automatic endpoint",
        "content": "Authentication that automatically determines the account-specific endpoint URL during the OAuth2 flow. This sample connects to the Salesforce API.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Salesforce API, using OAuth2 and an\n// automatically determined account-specific endpoint.\n// eslint-disable-next-line max-len\n// See https://help.salesforce.com/s/articleView?id=sf.remoteaccess_authenticate.htm&type=5\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://login.salesforce.com/services/oauth2/authorize\",\n  tokenUrl: \"https://login.salesforce.com/services/oauth2/token\",\n  scopes: [\"id\", \"api\", \"refresh_token\"],\n  additionalParams: {\n    prompt: \"consent\",\n  },\n\n  // Each account is associated with an instance URL, returned in the OAuth\n  // token response.\n  requiresEndpointUrl: true,\n  endpointDomain: \"salesforce.com\",\n  endpointKey: \"instance_url\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    // Relative URLs have the endpoint URL automatically prepended.\n    let url = \"/services/oauth2/userinfo\";\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.name;\n  },\n});\n\n// Allow the pack to make requests to Salesforce.\npack.addNetworkDomain(\"salesforce.com\");"
      },
      {
        "name": "User-selected endpoint",
        "content": "Authentication that presents a list of endpoints to the user for them to select one. This sample connects to the Jira API.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Jira Cloud API, using OAuth2 with a\n// post-submit step to select the instance to connect to. Note that this code\n// isn't compatible with Jira Data Center.\n// See https://developer.atlassian.com/cloud/confluence/oauth-2-3lo-apps\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://auth.atlassian.com/authorize\",\n  tokenUrl: \"https://auth.atlassian.com/oauth/token\",\n  scopes: [\"offline_access\", \"read:jira-user\", \"read:jira-work\"],\n  additionalParams: {\n    audience: \"api.atlassian.com\",\n    prompt: \"consent\",\n  },\n\n  // After approving access, the user should select which instance they want to\n  // connect to.\n  postSetup: [{\n    type: coda.PostSetupType.SetEndpoint,\n    name: \"SelectEndpoint\",\n    description: \"Select the site to connect to:\",\n    // Determine the list of sites they have access to.\n    getOptions: async function (context) {\n      let url = \"https://api.atlassian.com/oauth/token/accessible-resources\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let sites = response.body;\n      return sites.map(site => {\n        // Constructing an endpoint URL from the site ID.\n        let url = \"https://api.atlassian.com/ex/jira/\" + site.id;\n        return { display: site.name, value: url };\n      });\n    },\n  }],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    // This function is run twice: once before the site has been selected and\n    // again after. When the site hasn't been selected yet, return a generic\n    // name.\n    if (!context.endpoint) {\n      return \"Jira\";\n    }\n    // Include both the name of the user and server.\n    let server = await getServer(context);\n    let user = await getUser(context);\n    return `${user.displayName} (${server.serverTitle})`;\n  },\n});\n\n// Get information about the Jira server.\nasync function getServer(context: coda.ExecutionContext) {\n  let url = \"/rest/api/3/serverInfo\";\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body;\n}\n\n// Get information about the Jira user.\nasync function getUser(context: coda.ExecutionContext) {\n  let url = \"/rest/api/3/myself\";\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body;\n}\n\n// Allow the pack to make requests to Jira.\npack.addNetworkDomain(\"atlassian.com\");"
      }
    ]
  },
  {
    "name": "Dynamic sync tables",
    "description": "Samples that show how to create a dynamic sync table.",
    "icon": "material/cloud-sync-outline",
    "category": "Topic",
    "triggerTokens": [
      "addDynamicSyncTable"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/blocks/sync-tables/dynamic"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/blocks/sync-tables/dynamic",
    "learnMoreLink": "/guides/blocks/sync-tables/dynamic",
    "content": "Dynamic sync tables allow you to bring data from an external data source into your doc, even when the structure of that data is not known in advance. Instead of including a static schema in your sync table definition, you include a `getSchema` function that returns a schema based on the dataset the user selects. It can use the fetcher to make authenticated HTTP requests to an API so that you can determine the shape of the data.\n\nDynamic sync tables typically provide a list all of the datasets that the user has access to, using the `listDynamicUrls` function. Once a user selects a dataset from the side panel it will be available to other functions in `context.sync.dynamicUrl`. The dynamic sync table must also provide a user-visible URL for the selected dataset (using `getDisplayUrl`) and a name for the resulting table on the page (using `getName`).",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "",
        "code": "pack.addDynamicSyncTable({\n  name: \"MyThings\",\n  description: \"My description.\",\n  identityName: \"${1}\",\n  listDynamicUrls: async function (context) {\n    // TODO: Fetch the list of datasets the user can connect to.\n    let datasets = [];\n    // TODO: Replace \"name\" and \"url\" below with correct JSON keys.\n    return coda.autocompleteSearchObjects(undefined, datasets, \"name\", \"url\");\n  },\n  getName: async function (context) {\n    let datasetUrl = context.sync.dynamicUrl;\n    // TODO: Fetch metadata about the dataset and return the name.\n    return \"Table Name\";\n  },\n  getSchema: async function (context) {\n    let datasetUrl = context.sync.dynamicUrl;\n    // TODO: Fetch metadata about the dataset and use it to construct a schema.\n    let schema = coda.makeObjectSchema({\n      properties: {},\n      displayProperty: \"\",\n      idProperty: \"\",\n      featuredProperties: [],\n    });\n    return schema;\n  },\n  getDisplayUrl: async function (context) {\n    let datasetUrl = context.sync.dynamicUrl;\n    // TODO: Fetch metadata about the dataset and return a user-friendly URL.\n    return \"\";\n  },\n  formula: {\n    name: \"Sync$1\",\n    description: \"Syncs the data.\",\n    parameters: [\n      // TODO: Add parameters.\n    ],\n    execute: async function (args, context) {\n      let datasetUrl = context.sync.dynamicUrl!;\n      // TODO: Unpack the parameter values.\n      let [] = args;\n      // TODO: Fetch the rows.\n      let rows = [];\n      for (let row of rows) {\n        // TODO: If required, adjust the row to match the schema.\n      }\n      return {\n        result: rows,\n      };\n    },\n  },\n});"
      },
      {
        "name": "With URL list",
        "content": "A sync table that presents a list of URLs to select from. This sample shows responses to a Typeform form.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// When listing forms, the maximum to return.\nconst MaxForms = 200;\n\n// How many responses to fetch per-page.\nconst PageSize = 100;\n\n// Add a dynamic sync table for form responses.\npack.addDynamicSyncTable({\n  name: \"FormResponses\",\n  description: \"Responses to a form.\",\n  identityName: \"FormResponse\",\n\n  // Returns the URLs of the available forms. The user will select one when they\n  // add the table to their doc. The selected URL will be passed as\n  // `context.sync.dynamicUrl` to other methods.\n  listDynamicUrls: async function (context) {\n    let forms = await getForms(context);\n    let results = [];\n    for (let form of forms) {\n      // Each result should include the name and URL of the form.\n      results.push({\n        display: form.title,\n        // Using the API URL of the form, not the browser URL. This makes it\n        // easier to use the URL in the code, and `getDisplayUrl` below can\n        // show the browser URL to the user.\n        value: form.self.href,\n      });\n    }\n    return results;\n  },\n\n  // Like listDynamicUrls above, but to allow the user to search for a form by\n  // name. The second parameter is the search term the user entered.\n  searchDynamicUrls: async function (context, search) {\n    let forms = await getForms(context, search);\n    let results = [];\n    for (let form of forms) {\n      results.push({\n        display: form.title,\n        value: form.self.href,\n      });\n    }\n    return results;\n  },\n\n  // Returns the name of the table, given the selected URL.\n  getName: async function (context) {\n    let formUrl = context.sync.dynamicUrl;\n    let form = await getForm(context, formUrl);\n    return form.title;\n  },\n\n  // Returns the display version of the selected URL.\n  getDisplayUrl: async function (context) {\n    let formUrl = context.sync.dynamicUrl;\n    let form = await getForm(context, formUrl);\n    return form._links.display;\n  },\n\n  // Returns the schema of the table, given the selected URL.\n  getSchema: async function (context) {\n    let formUrl = context.sync.dynamicUrl;\n    let form = await getForm(context, formUrl);\n\n    // These properties are the same for all forms.\n    let properties: coda.ObjectSchemaProperties = {\n      submittedAt: {\n        type: coda.ValueType.String,\n        codaType: coda.ValueHintType.DateTime,\n      },\n      responseId: {\n        type: coda.ValueType.String,\n      },\n    };\n    // Use them as the display value and ID of the rows.\n    let displayProperty = \"submittedAt\";\n    let idProperty = \"responseId\";\n\n    // For each field in the form, add a property to the schema.\n    let featuredProperties = [];\n    for (let field of form.fields) {\n      // Format the field name into a valid property name.\n      let name = getPropertyName(field);\n      // Generate a schema for the field and add it to the set of properties.\n      properties[name] = getPropertySchema(field);\n      // Mark the property as featured (included in the table by default).\n      featuredProperties.push(name);\n    }\n\n    // Return the schema for each row.\n    return coda.makeObjectSchema({\n      properties: properties,\n      displayProperty: displayProperty,\n      idProperty: idProperty,\n      featuredProperties: featuredProperties,\n    });\n  },\n\n  // The formula that syncs the records.\n  formula: {\n    name: \"SyncResponses\",\n    description: \"Sync the form responses\",\n    parameters: [],\n    execute: async function ([], context) {\n      let formUrl = context.sync.dynamicUrl;\n\n      // Retrieve the token to continue from, if any.\n      let pageToken = context.sync.continuation?.token || null;\n\n      // Construct the API URL.\n      let url = coda.withQueryParams(formUrl + \"/responses\", {\n        page_size: PageSize,\n        before: pageToken,\n      });\n\n      // Fetch a page of responses.\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n        // Disable HTTP caching, so we always get the latest results.\n        cacheTtlSecs: 0,\n      });\n      let formResponses = response.body.items;\n\n      // Reformat each response to match the schema.\n      let rows = [];\n      for (let formResponse of formResponses) {\n        // Include the metadata common to all forms.\n        let row = {\n          submittedAt: formResponse.submitted_at,\n          responseId: formResponse.response_id,\n        };\n\n        // For each answer, add it to the row.\n        for (let answer of formResponse.answers) {\n          // Get the key to return the value in.\n          let key = getPropertyKey(answer.field);\n          let value = getPropertyValue(answer);\n          row[key] = value;\n        }\n        rows.push(row);\n      }\n\n      // Determine if we need to fetch more pages.\n      let continuation;\n      if (formResponses.length > 0) {\n        // Continue onward from the token of the last response.\n        let lastToken = formResponses[formResponses.length - 1].token;\n        continuation = {\n          token: lastToken,\n        };\n      }\n\n      // Return the rows and the continuation, if any.\n      return {\n        result: rows,\n        continuation: continuation,\n      };\n    },\n  },\n});\n\n// Gets the available forms, optionally filtered by a search string.\nasync function getForms(context: coda.ExecutionContext, search?: string) {\n  let url = coda.withQueryParams(\"https://api.typeform.com/forms\", {\n    search: search,\n    page_size: MaxForms,\n  });\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body.items;\n}\n\n// Get metadata about a form given it's URL.\nasync function getForm(context, url) {\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n    // Disable HTTP caching, so we always get the latest result.\n    cacheTtlSecs: 0,\n  });\n  return response.body;\n}\n\n// Generates a property name given a field title.\nfunction getPropertyName(field) {\n  return (\n    field.title\n      // Replace placeholders with an X.\n      .replace(/\\{\\{.*?\\}\\}/g, \"X\")\n  );\n}\n\n// Generates a property schema based on a Typeform field.\nfunction getPropertySchema(field): coda.Schema & coda.ObjectSchemaProperty {\n  let schema: any = {\n    // Use the field's full title as it's description.\n    description: field.title,\n    // The sync formula will return the value keyed using the field's ID.\n    fromKey: getPropertyKey(field),\n  };\n\n  // Set the schema type depending on the field type.\n  switch (field.type) {\n    case \"yes_no\":\n      schema.type = coda.ValueType.Boolean;\n      break;\n    case \"number\":\n    case \"opinion_scale\":\n    case \"rating\":\n      schema.type = coda.ValueType.Number;\n      break;\n    case \"date\":\n      schema.type = coda.ValueType.String;\n      schema.codaType = coda.ValueHintType.Date;\n      break;\n    case \"multiple_choice\":\n      let isMultiselect = field.properties.allow_multiple_selection;\n      if (isMultiselect) {\n        schema.type = coda.ValueType.Array;\n        schema.items = {\n          type: coda.ValueType.String,\n        };\n      } else {\n        schema.type = coda.ValueType.String;\n      }\n      break;\n    default:\n      // Default to strings.\n      schema.type = coda.ValueType.String;\n  }\n\n  return schema;\n}\n\n// Gets the key to use for this field when returning the value in the sync\n// formula.\nfunction getPropertyKey(field) {\n  return field.id;\n}\n\n// Gets the value from a Typeform answer.\nfunction getPropertyValue(answer) {\n  switch (answer.type) {\n    case \"choice\":\n      return answer.choice.label;\n    case \"choices\":\n      return answer.choices.labels;\n    default:\n      // The value is stored in a field with the same name as the type of the\n      // answer.\n      return answer[answer.type];\n  }\n}\n\n// Configure per-user authentication, using OAuth2.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // See: https://developer.typeform.com/get-started/applications/\n  authorizationUrl: \"https://api.typeform.com/oauth/authorize\",\n  tokenUrl: \"https://api.typeform.com/oauth/token\",\n  // See: https://developer.typeform.com/get-started/scopes/\n  scopes: [\"forms:read\", \"responses:read\", \"accounts:read\"],\n\n  // Get the name of the account from the Typeform API.\n  getConnectionName: async function (context) {\n    let url = \"https://api.typeform.com/me\";\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    let profile = response.body;\n    return profile.alias;\n  },\n});\n\n// Allow requests to the typeform.com domain.\npack.addNetworkDomain(\"typeform.com\");"
      },
      {
        "name": "With grouped URL list",
        "content": "A sync table that presents a list of URLs to select from, grouped into folders. This sample shows data from Open Data NY (data.ny.gov), which is powered by Socrata.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// The domain to connect to. Can be swapped for other domains hosting Socrata.\nconst Domain = \"data.ny.gov\";\n\n// The max number of columns to include in the sync table by default.\nconst MaxFeaturedColumns = 50;\n\n// How many rows to scan when determining the which columns to feature.\nconst TableScanMaxRows = 100;\n\n// How many rows to fetch per-page.\nconst PageSize = 100;\n\n// The maximum number of datasets to return in a search.\nconst MaxDatasets = 10000;\n\n// A regular expression matching a dataset.\nconst DatasetUrlRegex = new RegExp(`^https?://${Domain}/.*/([^?#]+)`);\n\n// Schema for an address (part of a location).\nconst AddressSchema = coda.makeObjectSchema({\n  properties: {\n    address: { type: coda.ValueType.String },\n    city: { type: coda.ValueType.String },\n    state: { type: coda.ValueType.String },\n    zip: { type: coda.ValueType.String },\n  },\n  displayProperty: \"address\",\n});\n\n// Schema for a location (used for locations and points).\nconst LocationSchema = coda.makeObjectSchema({\n  properties: {\n    coordinates: {\n      type: coda.ValueType.Array,\n      items: { type: coda.ValueType.Number },\n    },\n    latitude: { type: coda.ValueType.Number },\n    longitude: { type: coda.ValueType.Number },\n    address: { ...AddressSchema, fromKey: \"human_address\" },\n  },\n  displayProperty: \"coordinates\",\n});\n\n// A mapping from Socrata types to Coda schemas.\nconst TypeSchemaMap: Record<string, coda.Schema> = {\n  text: { type: coda.ValueType.String },\n  number: { type: coda.ValueType.Number },\n  checkbox: { type: coda.ValueType.Boolean },\n  calendar_date: {\n    type: coda.ValueType.String,\n    codaType: coda.ValueHintType.Date,\n  },\n  location: LocationSchema,\n  point: LocationSchema,\n  url: { type: coda.ValueType.String, codaType: coda.ValueHintType.Url },\n};\n\n// A base row schema, extended for each dataset.\nconst BaseRowSchema = coda.makeObjectSchema({\n  properties: {\n    rowId: { type: coda.ValueType.String, fromKey: \":id\" },\n  },\n  idProperty: \"rowId\",\n  displayProperty: \"rowId\",\n});\n\n\n// Allow requests to the domain.\npack.addNetworkDomain(Domain);\n\n// Use a system-wide application token to get additional quota.\n// https://dev.socrata.com/docs/app-tokens.html\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.CustomHeaderToken,\n  headerName: \"X-App-Token\",\n});\n\n// A dynamic sync table for the rows of a dataset.\npack.addDynamicSyncTable({\n  name: \"PublicDataset\",\n  identityName: \"DatasetRow\",\n  entityName: \"Row\",\n  // If new columns are added later, don't automatically feature them.\n  defaultAddDynamicColumns: false,\n\n  // Allow the user to browse the datasets by category.\n  listDynamicUrls: async function (context, category) {\n    if (!category) {\n      // Return the list of categories.\n      let categories = await getCategories(context);\n      return categories.map(category => {\n        return {\n          display: category,\n          value: category,\n          hasChildren: true,\n        };\n      });\n    }\n\n    // Return all the datasets in that category.\n    let datasets = await searchDatasets(context, {\n      categories: category,\n      only: \"datasets\",\n      domains: Domain,\n      search_context: Domain,\n      order: \"page_views_last_month\",\n      limit: MaxDatasets,\n    });\n    if (!datasets?.length) {\n      return [];\n    }\n    return datasets.map(dataset => {\n      return {\n        display: dataset.name,\n        value: dataset.link,\n      };\n    });\n  },\n\n  searchDynamicUrls: async function (context, search) {\n    let datasets = await searchDatasets(context, {\n      q: search,\n      only: \"datasets\",\n      domains: Domain,\n      search_context: Domain,\n      order: \"relevance\",\n      limit: MaxDatasets,\n    });\n    if (!datasets?.length) {\n      return [];\n    }\n    return datasets.map(dataset => {\n      return {\n        display: dataset.name,\n        value: dataset.link,\n      };\n    });\n  },\n\n  getName: async function (context) {\n    let dataset = await getDataset(context);\n    return dataset.name;\n  },\n\n  getSchema: async function (context) {\n    let dataset = await getDataset(context);\n\n    // Copy the base schema.\n    let schema: coda.GenericObjectSchema = {\n      ...BaseRowSchema,\n    };\n\n    // Add a schema property for each column.\n    for (let column of dataset.columns) {\n      let fieldName = column.fieldName;\n      let dataType = column.dataTypeName;\n      let description = column.description;\n\n      if (fieldName.startsWith(\":\")) {\n        // Skip internal fields.\n        continue;\n      }\n\n      let fieldSchema = TypeSchemaMap[dataType];\n      if (!fieldSchema) {\n        throw new Error(\"Couldn't find schema for column type: \" + dataType);\n      }\n\n      schema.properties[fieldName] = {\n        ...fieldSchema,\n        description: description,\n      };\n    }\n\n    // Determine which columns to feature.\n    schema.featuredProperties = await getFeatured(dataset, context);\n\n    // Add attribution information.\n    schema.attribution = getAttribution(dataset);\n\n    return schema;\n  },\n\n  getDisplayUrl: async function (context) {\n    return context.sync.dynamicUrl;\n  },\n\n  formula: {\n    name: \"SyncDataset\",\n    description: \"Syncs the dataset.\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"search\",\n        description: \"If specified, only rows containing this search term \" +\n          \"will be included.\",\n        optional: true,\n      }),\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"filter\",\n        description: \"A SoQL $where clause to use to filter the results. \" +\n          \"https://dev.socrata.com/docs/queries/where.html\",\n        optional: true,\n      }),\n    ],\n    execute: async function ([search, filter], context) {\n      let dataset = await getDataset(context);\n      let offset = context.sync.continuation?.offset as number || 0;\n\n      // Only fetch the selected columns.\n      let fields = coda.getEffectivePropertyKeysFromSchema(context.sync.schema);\n\n      // Fetch the row data.\n      let baseUrl = `https://${Domain}/resource/${dataset.id}.json`;\n      let url = coda.withQueryParams(baseUrl, {\n        $select: fields.join(\",\"),\n        $q: search,\n        $where: filter,\n        $limit: PageSize,\n        $offset: offset,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let rows = response.body;\n\n      // Transform the rows to match the schema.\n      for (let row of rows) {\n        for (let [key, value] of Object.entries(row)) {\n          row[key] = formatValue(value);\n        }\n      }\n\n      let continution = null;\n      if (rows.length > 0) {\n        // Keep fetching rows until we get an empty page.\n        continution = { offset: offset + PageSize };\n      }\n\n      return {\n        result: rows,\n        continuation: continution,\n      };\n    },\n  },\n});\n\n/**\n * Reformat a row value to match the schema.\n */\nfunction formatValue(value) {\n  if (typeof value === \"object\") {\n    let obj = value as Record<string, any>;\n    if (obj.url) {\n      // Pull up the URL.\n      value = obj.url;\n    } else if (obj.type === \"Point\") {\n      // Format point to LocationSchema.\n      value = {\n        latitude: obj.coordinates[1],\n        longitude: obj.coordinates[0],\n        // A point's coordinates are returned as x,y instead of lat,long.\n        coordinates: obj.coordinates.reverse(),\n      };\n    } else if (obj.latitude && obj.longitude) {\n      // Format location to LocationSchema.\n      value = {\n        ...obj,\n        coordinates: [obj.latitude, obj.longitude],\n      };\n    }\n  }\n  return value;\n}\n\n/**\n * Get the list of dataset categories.\n */\nasync function getCategories(context: coda.ExecutionContext):\n  Promise<string[]> {\n  let baseUrl = `https://${Domain}/api/catalog/v1/domain_categories`;\n  let url = coda.withQueryParams(baseUrl, {\n    domains: Domain,\n  });\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body.results.map(result => result.domain_category);\n}\n\n/**\n * Search for datasets, using a flexible set of parameters.\n */\nasync function searchDatasets(context: coda.ExecutionContext,\n  params: Record<string, any>): Promise<DatasetResult[]> {\n  let url = coda.withQueryParams(`https://${Domain}/api/catalog/v1`, params);\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body.results.map(result => {\n    return {\n      ...result.resource,\n      ...result,\n    };\n  });\n}\n\n/**\n * Get a dataset by ID.\n */\nasync function getDataset(context: coda.ExecutionContext): Promise<Dataset> {\n  let datasetUrl = context.sync.dynamicUrl;\n  let datasetId = getDatasetId(datasetUrl);\n  let url = `https://${Domain}/api/views/${datasetId}.json`;\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body;\n}\n\n/**\n * Extract the ID of the dataset from it's URL.\n */\nfunction getDatasetId(url: string): string {\n  let match = url.match(DatasetUrlRegex);\n  if (!match) {\n    throw new coda.UserVisibleError(\"Invalid dataset URL: \" + url);\n  }\n  return match[1];\n}\n\n/**\n * Determine which rows to feature (include in the table by default) for a given\n * dataset.\n */\nasync function getFeatured(dataset: Dataset, context: coda.ExecutionContext):\n  Promise<string[]> {\n  // Fetch some of the first rows from the dataset.\n  let baseUrl = `https://${Domain}/resource/${dataset.id}.json`;\n  let url = coda.withQueryParams(baseUrl, {\n    $limit: TableScanMaxRows,\n  });\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  let rows = response.body;\n\n  // Count how many times each column has a value.\n  let columnCount: Record<string, number> = {};\n  for (let row of rows) {\n    for (let [key, value] of Object.entries(row)) {\n      if (!columnCount[key]) {\n        columnCount[key] = 0;\n      }\n      if (value) {\n        columnCount[key]++;\n      }\n    }\n  }\n\n  // Return the list of columns that have at least one value in the scanned\n  // rows, up to a defined maximum.\n  return dataset.columns.map(column => column.fieldName)\n    .filter(column => columnCount[column] > 0)\n    .filter(column => !column.startsWith(\":\"))\n    .slice(0, MaxFeaturedColumns);\n}\n\n/**\n * Get the attribution node for a given dataset.\n */\nfunction getAttribution(dataset: Dataset): coda.AttributionNode[] {\n  if (!dataset.attribution) {\n    return null;\n  }\n  let node;\n  if (dataset.attributionLink) {\n    node = coda.makeAttributionNode({\n      type: coda.AttributionNodeType.Link,\n      anchorText: dataset.attribution,\n      anchorUrl: dataset.attributionLink,\n    });\n  } else {\n    node = coda.makeAttributionNode({\n      type: coda.AttributionNodeType.Text,\n      text: dataset.attribution,\n    });\n  }\n  return [node];\n}\n\n\n// A dataset search result.\ninterface DatasetResult {\n  name: string;\n  link: string;\n}\n\n// The dataset metadata.\ninterface Dataset {\n  id: string;\n  name: string;\n  description: string;\n  columns: DatasetColumn[];\n  attribution: string;\n  attributionLink: string;\n}\n\n// A dataset column definition.\ninterface DatasetColumn {\n  name: string;\n  description: string;\n  fieldName: string;\n  dataTypeName: string;\n}"
      }
    ]
  },
  {
    "name": "Formulas",
    "description": "Samples that show how to create a formula.",
    "icon": "material/function",
    "category": "Topic",
    "triggerTokens": [
      "addFormula"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/blocks/formulas"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/blocks/formulas",
    "learnMoreLink": "/guides/blocks/formulas",
    "content": "A formula is a JavaScript function that is exposed as a Coda formula, that you can use anywhere in a Coda doc that you can use any built-in formula. Formulas take basic types as input, like strings, numbers, dates, booleans, and arrays of these types, and return any of these types or objects whose properties are any of these types.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "The basic structure of a formula. This sample takes in a single string parameter and returns a string result.",
        "code": "pack.addFormula({\n  name: \"MyFormula\",\n  description: \"My description.\",\n  parameters: [\n    // TODO: Add parameters.\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function (args, context) {\n    // TODO: Unpack the parameter values.\n    let [] = args;\n    // TODO: Compute the result.\n    return \"\";\n  },\n});"
      },
      {
        "name": "Image result",
        "content": "A formula that returns an image. This sample gets a random cat image with an optional text overlay or filter applied.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"filter\",\n      description: \"A filter to apply to the image.\",\n      autocomplete: [\"blur\", \"mono\", \"sepia\", \"negative\", \"paint\", \"pixel\"],\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text, filter], context) {\n    let url = \"https://cataas.com/cat\";\n    if (text) {\n      url += \"/says/\" + encodeURIComponent(text);\n    }\n    url = coda.withQueryParams(url, {\n      filter: filter,\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");"
      },
      {
        "name": "Rich data result",
        "content": "A formula that returns rich data (a schema). This sample gets information about a task in the Todoist application.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the rich metadata to be returned about each task.\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"taskId\",\n});\n\n// Formula that looks up rich metadata about a task given it's ID.\npack.addFormula({\n  name: \"Task\",\n  description: \"Gets a Todoist task by ID\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"taskId\",\n      description: \"The ID of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n\n  execute: async function ([taskId], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    let task = response.body;\n    return {\n      name: task.content,\n      description: task.description,\n      url: task.url,\n      taskId: task.id,\n    };\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      },
      {
        "name": "With examples",
        "content": "A formula that includes examples of how to use it. This sample formats text to look like screaming, with a optional parameters to override how many exclamation points to use and an alternate character to use.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formats text to look like screaming. For example, \"Hello\" => \"HELLO!!!\".\npack.addFormula({\n  name: \"Scream\",\n  description: \"Make text uppercase and add exclamation points.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"The text to scream.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"volume\",\n      description: \"The number of exclamation points to add.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"character\",\n      description: \"The character to repeat.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  examples: [\n    { params: [\"Hello\"], result: \"HELLO!!!\" },\n    { params: [\"Hello\", 5], result: \"HELLO!!!!!\" },\n    { params: [\"Hello\", undefined, \"?\"], result: \"HELLO???\" },\n    { params: [\"Hello\", 5, \"?\"], result: \"HELLO?????\" },\n  ],\n  execute: async function ([text, volume = 3, character = \"!\"], context) {\n    return text.toUpperCase() + character.repeat(volume);\n  },\n});"
      }
    ]
  },
  {
    "name": "Actions",
    "description": "Samples that show how to create an action formula, for use in a button or automation.",
    "icon": "material/cursor-default-click-outline",
    "category": "Topic",
    "triggerTokens": [
      "isAction"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/blocks/actions"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/blocks/actions",
    "learnMoreLink": "/guides/blocks/actions",
    "content": "Actions are special types of formulas that power buttons and automations. They usually send data to an external API, but can also be used for other one-time calculations.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "The basic structure of an action. This sample takes in a single string parameter and returns the string \"OK\" when the action is complete.",
        "code": "pack.addFormula({\n  name: \"MyAction\",\n  description: \"My description.\",\n  parameters: [\n    // TODO: Add parameters.\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function (args, context) {\n    // TODO: Unpack the parameter values.\n    let [] = args;\n    // TODO: Do something.\n    return \"OK\";\n  },\n});"
      },
      {
        "name": "Random value",
        "content": "A formula that returns a random value. This sample rolls virtual dice and returns the results.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Rolls virtual dice and returns the resulting numbers. Use it with a button in\n// table and store the results in another column.\npack.addFormula({\n  name: \"RollDice\",\n  description: \"Roll some virtual dice.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"quantity\",\n      description: \"How many dice to roll.\",\n      suggestedValue: 1,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"sides\",\n      description: \"How many sides the dice have.\",\n      suggestedValue: 6,\n    }),\n  ],\n  resultType: coda.ValueType.Array,\n  items: coda.makeSchema({\n    type: coda.ValueType.Number,\n  }),\n  isAction: true,\n  execute: async function ([quantity, sides], context) {\n    let results = [];\n    for (let i = 0; i < quantity; i++) {\n      let roll = Math.ceil(Math.random() * sides);\n      results.push(roll);\n    }\n    return results;\n  },\n});"
      },
      {
        "name": "Post to API",
        "content": "A formula that posts data to an external API. This sample creates a new task in the Todoist app.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Action formula (for buttons and automations) that adds a new task in Todoist.\npack.addFormula({\n  name: \"AddTask\",\n  description: \"Add a new task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the task.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n\n  execute: async function ([name], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/tasks\",\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        content: name,\n      }),\n    });\n    // Return values are optional but recommended. Returning a URL or other\n    // unique identifier is recommended when creating a new entity.\n    return response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      },
      {
        "name": "Update row in sync table",
        "content": "A formula that updates an item on the server, and the existing row in a sync table if it exists. This sample updates the name of a task in the Todoist app.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the data in the sync table.\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"taskId\",\n  featuredProperties: [\"description\", \"url\"],\n});\n\n// Action formula (for buttons and automations) that updates an existing task,\n// and by returning the schema also updates the existing row in the sync table.\npack.addFormula({\n  name: \"UpdateTask\",\n  description: \"Updates the name of a task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"taskId\",\n      description: \"The ID of the task to update.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The new name of the task.\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  // For schemas returned by actions to update rows in a sync table, set the\n  // identity on the schema to match the identityName on the sync table being\n  // updated, using the helper function coda.withIdentity().\n  schema: coda.withIdentity(TaskSchema, \"Task\"),\n  isAction: true,\n\n  execute: async function ([taskId, name], context) {\n    let url = \"https://api.todoist.com/rest/v2/tasks/\" + taskId;\n    await context.fetcher.fetch({\n      url: url,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        content: name,\n      }),\n    });\n    // Get the updated Task and return it, which will update the row in the sync\n    // table.\n    let response = await context.fetcher.fetch({\n      url: url,\n      method: \"GET\",\n      cacheTtlSecs: 0, // Ensure we are getting the latest data.\n    });\n    let task = response.body;\n    return {\n      name: task.content,\n      description: task.description,\n      url: task.url,\n      taskId: task.id,\n    };\n  },\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [],\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v2/tasks\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results = [];\n      for (let task of response.body) {\n        results.push({\n          name: task.content,\n          description: task.description,\n          url: task.url,\n          taskId: task.id,\n        });\n      }\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      }
    ]
  },
  {
    "name": "Parameters",
    "description": "Samples that show how to accept parameters from the user.",
    "icon": "material/format-textbox",
    "category": "Topic",
    "triggerTokens": [
      "makeParameter"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/basics/parameters"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/basics/parameters",
    "learnMoreLink": "/guides/basics/parameters",
    "content": "Coda formulas, actions, and sync tables receive take in user input via parameters. They are required by default, but can by made optional. Variable argument (vararg) parameters can be used to allow for parameters to be set more than once.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "The basic structure of a parameter. This sample is for a string parameter.",
        "code": "coda.makeParameter({\n  type: coda.ParameterType.String,\n  name: \"myParameter\",\n  description: \"My description.\",\n}),"
      },
      {
        "name": "No parameters",
        "content": "A formula without any parameters. This sample returns the name of the current day of the week.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that gets the current weekday, for example \"Monday\".\npack.addFormula({\n  name: \"CurrentWeekday\",\n  description: \"Get the current day of the week.\",\n  parameters: [],\n  resultType: coda.ValueType.String,\n  execute: async function ([], context) {\n    let now = new Date();\n    let formatter = Intl.DateTimeFormat(\"us-US\", {\n      timeZone: context.timezone,\n      weekday: \"long\",\n    });\n    return formatter.format(now);\n  },\n});"
      },
      {
        "name": "String parameter",
        "content": "A formula that takes plain text as a parameter. This sample returns a greeting to the name provided.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Say Hello to the given name.\npack.addFormula({\n  name: \"Hello\",\n  description: \"A Hello World example.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The person's name you would like to say hello to.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([name]) {\n    return \"Hello \" + name + \"!\";\n  },\n});"
      },
      {
        "name": "Number parameter",
        "content": "A formula that takes a number as a parameter. This sample converts a number of slices of pizza into a percentage eaten.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that converts slices of a pizza into a percentage eaten.\npack.addFormula({\n  name: \"PizzaEaten\",\n  description: \"Calculates what percentage of a pizza was eaten.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"slices\",\n      description: \"How many slices were eaten.\",\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Percent,\n  execute: async function ([slices], context) {\n    return slices / 8;\n  },\n});"
      },
      {
        "name": "Date parameter",
        "content": "A formula that takes a date as a parameter. This sample determines if the year of a given date would make for good New Years Eve glasses (has two or more zeros).",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addFormula({\n  name: \"GoodNYEGlasses\",\n  description: \"Determines if a date is good for New Years Eve glasses \" +\n    \"(the year contains two zeros).\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"date\",\n      description: \"The input date.\",\n    }),\n  ],\n  resultType: coda.ValueType.Boolean,\n  execute: async function ([date], context) {\n    // Format the JavaScript Date into a four-digit year.\n    let formatted = date.toLocaleDateString(\"en\", {\n      timeZone: context.timezone, // Use the timezone of the doc (important!).\n      year: \"numeric\",\n    });\n    // Extract all of the zeros from the year.\n    let zeros = formatted.match(/0/g);\n    return zeros?.length >= 2;\n  },\n});"
      },
      {
        "name": "Image parameter",
        "content": "A formula that takes an image as a parameter. This sample returns the file size of an image.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Regular expression that matches Coda-hosted images.\nconst HostedImageUrlRegex = new RegExp(\"^https://(?:[^/]*\\.)?codahosted.io/.*\");\n\n// Formula that calculates the file size of an image.\npack.addFormula({\n  name: \"FileSize\",\n  description: \"Gets the file size of an image, in bytes.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Image,\n      name: \"image\",\n      description:\n        \"The image to operate on. Not compatible with Image URL columns.\",\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function ([imageUrl], context) {\n    // Throw an error if the image isn't Coda-hosted. Image URL columns can\n    // contain images on any domain, but by default Packs can only access image\n    // attachments hosted on codahosted.io.\n    if (!imageUrl.match(HostedImageUrlRegex)) {\n      throw new coda.UserVisibleError(\"Not compatible with Image URL columns.\");\n    }\n    // Fetch the image content.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: imageUrl,\n      isBinaryResponse: true, // Required when fetching binary content.\n    });\n    // The binary content of the response is returned as a Node.js Buffer.\n    // See: https://nodejs.org/api/buffer.html\n    let buffer = response.body as Buffer;\n    // Return the length, in bytes.\n    return buffer.length;\n  },\n});"
      },
      {
        "name": "Array parameter",
        "content": "A formula that takes a string array as a parameter. This sample returns the longest string in the list.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addFormula({\n  name: \"Longest\",\n  description: \"Given a list of strings, returns the longest one.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.StringArray,\n      name: \"strings\",\n      description: \"The input strings.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([strings], context) {\n    if (strings.length === 0) {\n      throw new coda.UserVisibleError(\"No options provided.\");\n    }\n    let result;\n    for (let str of strings) {\n      if (!result || str.length > result.length) {\n        result = str;\n      }\n    }\n    return result;\n  },\n});"
      },
      {
        "name": "Sparse array parameter",
        "content": "A formula that takes sparse number arrays as a parameter, useful when passing table columns. This sample returns the total cost for an order of items.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addFormula({\n  name: \"TotalCost\",\n  description: \"Calculates the total cost for an order.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.SparseNumberArray,\n      name: \"prices\",\n      description: \"The prices for each item.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.SparseNumberArray,\n      name: \"quantities\",\n      description: \"The quantities of each item. Default: 1.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.SparseNumberArray,\n      name: \"taxRates\",\n      description: \"The tax rates for each item. Default: 0.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Currency,\n  execute: async function ([prices, quantities=[], taxRates=[]], context) {\n    if ((quantities.length > 0 && quantities.length !== prices.length) ||\n        (taxRates.length > 0 && taxRates.length !== prices.length)) {\n      throw new coda.UserVisibleError(\"All lists must be the same length.\");\n    }\n    let result = 0;\n    for (let i = 0; i < prices.length; i++) {\n      let price = prices[i];\n      let quantity = quantities[i];\n      let taxRate = taxRates[i];\n      if (price == null) {\n        // If the price is blank, continue on to the next row.\n        continue;\n      }\n      if (quantity != null) {\n        price *= quantity;\n      }\n      if (taxRate != null) {\n        price += price * taxRate;\n      }\n      result += price;\n    }\n    return result;\n  },\n});"
      },
      {
        "name": "Optional parameters",
        "content": "A formula with some required and some optional parameters. This sample formats text to look like screaming, with a optional parameters to override how many exclamation points to use and an alternate character to use.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formats text to look like screaming. For example, \"Hello\" => \"HELLO!!!\".\npack.addFormula({\n  name: \"Scream\",\n  description: \"Make text uppercase and add exclamation points.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"The text to scream.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"volume\",\n      description: \"The number of exclamation points to add.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"character\",\n      description: \"The character to repeat.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  examples: [\n    { params: [\"Hello\"], result: \"HELLO!!!\" },\n    { params: [\"Hello\", 5], result: \"HELLO!!!!!\" },\n    { params: [\"Hello\", undefined, \"?\"], result: \"HELLO???\" },\n    { params: [\"Hello\", 5, \"?\"], result: \"HELLO?????\" },\n  ],\n  execute: async function ([text, volume = 3, character = \"!\"], context) {\n    return text.toUpperCase() + character.repeat(volume);\n  },\n});"
      },
      {
        "name": "Parameter suggested value",
        "content": "A formula with a parameter that defines a suggested value. This sample rolls virtual dice and returns the results.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Rolls virtual dice and returns the resulting numbers. Use it with a button in\n// table and store the results in another column.\npack.addFormula({\n  name: \"RollDice\",\n  description: \"Roll some virtual dice.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"quantity\",\n      description: \"How many dice to roll.\",\n      suggestedValue: 1,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"sides\",\n      description: \"How many sides the dice have.\",\n      suggestedValue: 6,\n    }),\n  ],\n  resultType: coda.ValueType.Array,\n  items: coda.makeSchema({\n    type: coda.ValueType.Number,\n  }),\n  isAction: true,\n  execute: async function ([quantity, sides], context) {\n    let results = [];\n    for (let i = 0; i < quantity; i++) {\n      let roll = Math.ceil(Math.random() * sides);\n      results.push(roll);\n    }\n    return results;\n  },\n});"
      },
      {
        "name": "Variable argument parameters",
        "content": "A formula that accepts a variable number of arguments. This sample draws a simple diagram using text, with an unknown number of arrow labels and steps.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Takes an unknown number of steps and labels and outputs a simple diagram.\n// Example: Steps(\"Idea\", \"Experiment\", \"Prototype\", \"Refine\", \"Product\")\n// Result: Idea --Experiment--> Prototype --Refine--> Product\npack.addFormula({\n  name: \"Steps\",\n  description: \"Draws a simple step diagram using text.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"start\",\n      description: \"The starting step.\",\n    }),\n  ],\n  varargParameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"label\",\n      description: \"The label for the arrow.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"step\",\n      description: \"The next step.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([start, ...varargs], context) {\n    let result = start;\n    while (varargs.length > 0) {\n      let label; let step;\n      // Pull the first set of varargs off the list, and leave the rest.\n      [label, step, ...varargs] = varargs;\n      result += ` --${label}--> ${step}`;\n    }\n    return result;\n  },\n});"
      },
      {
        "name": "Reusing parameters",
        "content": "A Pack that reuses a parameter across multiple formulas. This sample includes mathematical formulas that operate on a list of numbers.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A \"numbers\" parameter shared by both formulas.\nconst NumbersParameter = coda.makeParameter({\n  type: coda.ParameterType.NumberArray,\n  name: \"numbers\",\n  description: \"The numbers to perform the calculation on.\",\n});\n\npack.addFormula({\n  name: \"GCD\",\n  description: \"Returns the greatest common divisor for a list of numbers.\",\n  parameters: [\n    // Use the shared parameter created above.\n    NumbersParameter,\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function ([numbers]) {\n    // Handle the error case where the list is empty.\n    if (numbers.length === 0) {\n      throw new coda.UserVisibleError(\"The list cannot be empty.\");\n    }\n\n    // Handle the error case where all the numbers are zeros.\n    if (numbers.every(number => number === 0)) {\n      throw new coda.UserVisibleError(\n        \"The list must contain a non-zero number.\");\n    }\n\n    let result = numbers[0];\n    for (let i = 1; i < numbers.length; i++) {\n      let number = numbers[i];\n      result = gcd(number, result);\n    }\n    return result;\n  },\n});\n\npack.addFormula({\n  name: \"LCM\",\n  description: \"Returns the least common multiple for a list of numbers.\",\n  parameters: [\n    // Use the shared parameter created above.\n    NumbersParameter,\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function ([numbers]) {\n    // Handle the error case where the list is empty.\n    if (numbers.length === 0) {\n      throw new coda.UserVisibleError(\"The list cannot be empty.\");\n    }\n\n    // Handle the error case where the list contains a zero.\n    if (numbers.some(number => number === 0)) {\n      throw new coda.UserVisibleError(\"The list must not contain a zero.\");\n    }\n\n    let result = numbers[0];\n    for (let i = 1; i < numbers.length; i++) {\n      let number = numbers[i];\n      result = Math.abs(number * result) / gcd(number, result);\n    }\n    return result;\n  },\n});\n\n// Helper function that calculates the greatest common divisor of two\n// numbers.\nfunction gcd(a, b) {\n  if (a === 0) {\n    return b;\n  }\n  return gcd(b % a, a);\n}"
      }
    ]
  },
  {
    "name": "Autocomplete",
    "description": "Samples that show how to provide autocomplete options for a parameter.",
    "icon": "material/form-dropdown",
    "category": "Topic",
    "triggerTokens": [
      "autocomplete"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/basics/parameters/autocomplete"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/basics/parameters/autocomplete",
    "learnMoreLink": "/guides/basics/parameters/autocomplete",
    "content": "Autocomplete can be configured for a parameter to provide a defined set of options for the user to select from. You can pass either a static array or use a function to dynamically generate the options.",
    "exampleSnippets": [
      {
        "name": "Simple autocomplete",
        "content": "A formula with a parameter that provides autocomplete for acceptable values. This sample returns the noise that an animal makes, for a limited set of animals.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Returns the noise an animal makes. Ex) \"cow\" => \"moo\".\npack.addFormula({\n  name: \"AnimalNoise\",\n  description: \"Gets the noise than an animal makes.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"animal\",\n      description: \"The selected animal.\",\n      autocomplete: [\"cow\", \"pig\", \"sheep\"],\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([animal], context) {\n    switch (animal) {\n      case \"cow\":\n        return \"moo\";\n      case \"pig\":\n        return \"oink\";\n      case \"sheep\":\n        return \"baa\";\n      default:\n        throw new coda.UserVisibleError(\"Unknown animal: \" + animal);\n    }\n  },\n});"
      },
      {
        "name": "Dynamic autocomplete",
        "content": "A formula with a parameter that provides autocomplete for acceptable values, where the options are pulled dynamically from an API. This sample returns the price for a board game listed on the site Board Game Atlas.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Gets the price of a board game by ID, with autocomplete on the ID.\npack.addFormula({\n  name: \"GetPrice\",\n  description: \"Gets the price of a board game.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"gameId\",\n      description: \"The ID of the game on boardgameatlas.com\",\n      autocomplete: async function (context, search, parameters) {\n        let url = coda.withQueryParams(\n          \"https://api.boardgameatlas.com/api/search\",\n          { fuzzy_match: true, name: search });\n        let response = await context.fetcher.fetch({ method: \"GET\", url: url });\n        let results = response.body.games;\n        // Generate an array of autocomplete objects, using the game's name as\n        // the label and its ID for the value.\n        return coda.autocompleteSearchObjects(search, results, \"name\", \"id\");\n      },\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Currency,\n  execute: async function ([gameId], context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.boardgameatlas.com/api/search?ids=\" + gameId,\n    });\n    return response.body.games[0].price;\n  },\n});\n\npack.addNetworkDomain(\"boardgameatlas.com\");\n\n// Authenticate using a client ID.\n// See: https://www.boardgameatlas.com/api/docs/apps\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.QueryParamToken,\n  paramName: \"client_id\",\n});"
      },
      {
        "name": "Autocomplete on previous parameter",
        "content": "A formula with a parameter that provides autocomplete for acceptable values, where the options depend on the value of a previous parameter. This sample generates a greeting in either English or Spanish.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Greet someone in their language, with the greeting autocomplete adjusting\n// based on the language selected.\npack.addFormula({\n  name: \"Greeting\",\n  description: \"Greet someone.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"language\",\n      description: \"The language to greet them in.\",\n      autocomplete: [\n        { display: \"English\", value: \"en\" },\n        { display: \"Spanish\", value: \"es\" },\n      ],\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"greeting\",\n      description: \"The greeting to use.\",\n      autocomplete: async function (context, search, { language }) {\n        let options;\n        if (language === \"es\") {\n          options = [\"Hola\", \"Buenos días\"];\n        } else {\n          options = [\"Hello\", \"Howdy\"];\n        }\n        return coda.simpleAutocomplete(search, options);\n      },\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name to greet.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  execute: async function ([language, greeting, name], context) {\n    let result = greeting + \" \" + name + \"!\";\n    if (language === \"es\") {\n      // Add upside-down exclamation point in the front.\n      result = \"¡\" + result;\n    }\n    return result;\n  },\n});"
      },
      {
        "name": "Autocomplete on vararg key-value pairs",
        "content": "A formula with vararg parameters that represent key-value pairs, which provides autocomplete for available keys and for acceptable values based on the selected key. This sample generates a fictitious ice cream order. Note: This technique will not work when using vararg parameters in the builder UIs.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Generates a fictitious ice cream order, using a flexible set of choices.\npack.addFormula({\n  name: \"OrderIcecream\",\n  description: \"Put in your ice cream order.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"scoops\",\n      description: \"How many scoops do you want?\",\n    }),\n  ],\n  varargParameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"choice\",\n      description: \"Which choice to set.\",\n      autocomplete: [\"flavor\", \"topping\", \"vessel\"],\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"value\",\n      description: \"The value of that choice.\",\n      autocomplete: async function (context, search, params) {\n        switch (params.choice) {\n          case \"flavor\":\n            return [\"vanilla\", \"chocolate\", \"strawberry\"];\n          case \"topping\":\n            return [\"sprinkles\", \"whipped cream\", \"chocolate shell\"];\n          case \"vessel\":\n            return [\"cone\", \"cup\"];\n          default:\n            return [];\n        }\n      },\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([scoops, ...args], context) {\n    let result = `${scoops}: scoops`;\n    let choice, value;\n    while (args.length > 0) {\n      [choice, value, ...args] = args;\n      result += `, ${choice}: ${value}`;\n    }\n    return result;\n  },\n});"
      }
    ]
  },
  {
    "name": "Sync tables",
    "description": "Samples that show how to create a sync table.",
    "icon": "material/table-sync",
    "category": "Topic",
    "triggerTokens": [
      "addSyncTable"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/blocks/sync-tables"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/blocks/sync-tables",
    "learnMoreLink": "/guides/blocks/sync-tables",
    "content": "A **sync table** is how to bring structured data from a third-party into Coda. A sync table is a table that you can add to a Coda doc that gets its rows from a third-party data source, that can be refreshed regularly to pull in new or updated data. A sync table is powered by a **formula** that takes parameters that represent sync options and returns an array of objects representing row data. A sync table also includes a schema describing the structure of the returned objects.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "The basic structure of a sync table.",
        "code": "pack.addSyncTable({\n  name: \"MyThings\",\n  description: \"Table description.\",\n  identityName: \"Thing\",\n  schema: ThingSchema,\n  formula: {\n    name: \"Sync$1\",\n    description: \"Syncs the data.\",\n    parameters: [\n      // TODO: Add parameters.\n    ],\n    execute: async function (args, context) {\n      // TODO: Unpack the parameter values.\n      let [] = args;\n      // TODO: Fetch the rows.\n      let rows = [];\n      for (let row of rows) {\n        // TODO: If required, adjust the row to match the schema.\n      }\n      return {\n        result: rows,\n      };\n    },\n  },\n});"
      },
      {
        "name": "With parameter",
        "content": "A sync table that uses a parameter. This sample syncs cat photos from the CatAAS API.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Schema for a Cat image.\nconst CatSchema = coda.makeObjectSchema({\n  properties: {\n    image: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n    tags: {\n      type: coda.ValueType.Array,\n      items: coda.makeSchema({ type: coda.ValueType.String }),\n    },\n    created: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.DateTime,\n    },\n    id: { type: coda.ValueType.String },\n  },\n  displayProperty: \"image\",\n  idProperty: \"id\",\n  featuredProperties: [\"tags\"],\n});\n\n// Sync table that retrieves all cat images, optionally filtered by tags.\npack.addSyncTable({\n  name: \"Cats\",\n  identityName: \"Cat\",\n  schema: CatSchema,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  formula: {\n    name: \"SyncCats\",\n    description: \"Syncs the cats.\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"tag\",\n        description: \"Only cats with this tag will be selected.\",\n        optional: true,\n        // Pull the list of tags to use for autocomplete from the API.\n        autocomplete: async function (context, search) {\n          let response = await context.fetcher.fetch({\n            method: \"GET\",\n            url: \"https://cataas.com/api/tags\",\n          });\n          let tags = response.body;\n          // Convert the tags into a list of autocomplete options.\n          return coda.simpleAutocomplete(search, tags);\n        },\n      }),\n    ],\n    execute: async function ([tag], context) {\n      let url = coda.withQueryParams(\"https://cataas.com/api/cats\", {\n        tags: tag,\n        limit: 10000,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let cats = response.body;\n      let result = [];\n      for (let cat of cats) {\n        result.push({\n          image: \"https://cataas.com/cat/\" + cat._id,\n          tags: cat.tags,\n          created: cat.createdAt,\n          id: cat._id,\n        });\n      }\n      return {\n        result: result,\n      };\n    },\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");"
      },
      {
        "name": "With continuation",
        "content": "A sync table that uses continuations to sync data using multiple executions. This sample syncs the spells available in Dungeons and Dragons.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// How many spells to fetch in each sync formula execution.\nconst BATCH_SIZE = 20;\n\n// Allow requests to the DND API.\npack.addNetworkDomain(\"dnd5eapi.co\");\n\n// Schema that defines the metadata to return for each spell. Shared by the\n// formula, column format, and sync table.\nlet SpellSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The spell name.\",\n      type: coda.ValueType.String,\n    },\n    description: {\n      description: \"A description of the spell.\",\n      type: coda.ValueType.String,\n    },\n    higher_level: {\n      description: \"A description for casting the spell at a higher level.\",\n      type: coda.ValueType.String,\n    },\n    level: {\n      description: \"The level of the spell.\",\n      type: coda.ValueType.Number,\n    },\n    range: {\n      description: \"The range of the spell.\",\n      type: coda.ValueType.String,\n    },\n    material: {\n      description: \"The material component for the spell to be cast.\",\n      type: coda.ValueType.String,\n    },\n    duration: {\n      description: \"How long the spell effect lasts.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"Instantaneous\".\n    },\n    casting_time: {\n      description: \"How long it takes for the spell to activate.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"1 action\".\n    },\n    attack_type: {\n      description: \"The attack type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    damage_type: {\n      description: \"The damage type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    index: {\n      description: \"A unique identifier for the spell.\",\n      type: coda.ValueType.String,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"index\",\n  featuredProperties: [\"description\", \"level\", \"range\"],\n});\n\n// Reformat the API response for a spell to fit the schema.\nfunction formatSpell(spell) {\n  return {\n    // Start with all of the properties in the API response.\n    ...spell,\n    description: spell.desc?.join(\"\\n\"),\n    higher_level: spell.higher_level?.join(\"\\n\"),\n    damage_type: spell.damage?.damage_type?.name,\n  };\n}\n\n// A sync table that displays all spells available in the API.\npack.addSyncTable({\n  name: \"Spells\",\n  identityName: \"Spell\",\n  schema: SpellSchema,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  formula: {\n    name: \"SyncSpells\",\n    description: \"Sync all the spells.\",\n    parameters: [],\n    execute: async function ([], context) {\n      // Get the list of all spells.\n      let listUrl = \"https://www.dnd5eapi.co/api/spells\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: listUrl,\n      });\n      let results = response.body.results;\n\n      // If there is a previous continuation, start from the index contained\n      // within, otherwise start at zero.\n      let index: number = (context.sync.continuation?.index as number) || 0;\n\n      // Get a batch of results, starting from the index determined above.\n      let batch = results.slice(index, index + BATCH_SIZE);\n\n      // Fetch the spells for the batch of results.\n      let spells = await fetchSpells(context.fetcher, batch);\n\n      // Move the index forward.\n      index += BATCH_SIZE;\n\n      // If there are more results to process, create a new continuation.\n      let continuation;\n      if (index <= results.length) {\n        continuation = {\n          index: index,\n        };\n      }\n\n      // Return the batch of spells and the next continuation, if any.\n      return {\n        result: spells,\n        continuation: continuation,\n      };\n    },\n  },\n});\n\n// Fetch a batch of spells from the API and return them formatted to match the\n// schema. This utility function is shared by the formula and sync table.\nasync function fetchSpells(fetcher: coda.Fetcher, spellResults) {\n  let requests = [];\n  for (let spellResult of spellResults) {\n    // Add on the domain.\n    let url = \"https://www.dnd5eapi.co\" + spellResult.url;\n    // Put the request in the list. Don\"t use await here, since we want them to\n    // run at the same time.\n    let request = fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    requests.push(request);\n  }\n\n  // Wait for all of the requests to finish.\n  let responses = await Promise.all(requests);\n\n  // Format the API responses and return them.\n  let spells = [];\n  for (let response of responses) {\n    spells.push(formatSpell(response.body));\n  }\n  return spells;\n}"
      },
      {
        "name": "With authentication",
        "content": "A sync table that pulls from an API using authentication. This sample syncs the tasks from a user's Todoist account.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the data in the sync table.\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"taskId\",\n  featuredProperties: [\"description\", \"url\"],\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"filter\",\n        description: \"A supported filter string. See the Todoist help center.\",\n        optional: true,\n      }),\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"project\",\n        description: \"Limit tasks to a specific project.\",\n        optional: true,\n        autocomplete: async function (context, search) {\n          let url = \"https://api.todoist.com/rest/v2/projects\";\n          let response = await context.fetcher.fetch({\n            method: \"GET\",\n            url: url,\n          });\n          let projects = response.body;\n          return coda.autocompleteSearchObjects(search, projects, \"name\", \"id\");\n        },\n      }),\n    ],\n    execute: async function ([filter, project], context) {\n      let url = coda.withQueryParams(\"https://api.todoist.com/rest/v2/tasks\", {\n        filter: filter,\n        project_id: project,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results = [];\n      for (let task of response.body) {\n        results.push({\n          name: task.content,\n          description: task.description,\n          url: task.url,\n          taskId: task.id,\n        });\n      }\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      },
      {
        "name": "With row references",
        "content": "A sync table that contains a reference to a row in another sync table. This sample syncs the tasks from a user's Todoist account.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the data in the Projects sync table.\nconst ProjectSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the project.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    url: {\n      description: \"A link to the project in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    projectId: {\n      description: \"The ID of the project.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"projectId\",\n  featuredProperties: [\"url\"],\n});\n\n// A reference schema, allowing other sync tables to link to rows in the\n// Projects sync table. The second parameter must match the identityName field\n// of the sync table being referenced.\nconst ProjectReferenceSchema = coda.makeReferenceSchemaFromObjectSchema(\n  ProjectSchema, \"Project\");\n\n// A schema defining the data in the Tasks sync table.\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    // Reference a project from the Projects sync table.\n    project: ProjectReferenceSchema,\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"taskId\",\n  featuredProperties: [\"description\", \"url\", \"project\"],\n});\n\n// The definition and logic for the Projects sync table.\npack.addSyncTable({\n  name: \"Projects\",\n  schema: ProjectSchema,\n  identityName: \"Project\",\n  formula: {\n    name: \"SyncProjects\",\n    description: \"Sync projects\",\n    parameters: [],\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v2/projects\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results = [];\n      for (let project of response.body) {\n        results.push({\n          name: project.name,\n          url: project.url,\n          projectId: project.id,\n        });\n      }\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// The definition and logic for the Tasks sync table.\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [],\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v2/tasks\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results = [];\n      for (let task of response.body) {\n        let item: any = {\n          name: task.content,\n          description: task.description,\n          url: task.url,\n          taskId: task.id,\n        };\n        if (task.project_id) {\n          // Add a reference to the parent project in the Projects table.\n          item.project = {\n            projectId: task.project_id,\n            name: \"Not found\", // Placeholder name, if not synced yet.\n          };\n        }\n        results.push(item);\n      }\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      }
    ]
  },
  {
    "name": "Fetcher",
    "description": "Samples that show how to fetch data from an external source.",
    "icon": "fontawesome/solid/cloud-arrow-down",
    "category": "Topic",
    "triggerTokens": [
      "fetch"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/basics/fetcher"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/basics/fetcher",
    "learnMoreLink": "/guides/basics/fetcher",
    "content": "Communicating with an API or external server is done through the `Fetcher`, a custom interface for making HTTP requests. The fetcher is made available through the `context` object passed in to formulas. The fetcher can only send requests to URLs that have have a domain name that's been registered using `addNetworkDomain`. The fetcher runs asynchronously, and is typically run within an `async` function that will `await` the result.",
    "exampleSnippets": [
      {
        "name": "Template (GET)",
        "content": "",
        "code": "let response = await context.fetcher.fetch({\n  method: \"GET\",\n  url: \"https://example.com\",\n});\nlet data = response.body;"
      },
      {
        "name": "Template (POST)",
        "content": "",
        "code": "let payload = {\n  // TODO: Construct the JSON that the API expects.\n};\nlet response = await context.fetcher.fetch({\n  method: \"POST\",\n  url: \"https://example.com\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify(payload),\n});\nlet data = response.body;"
      },
      {
        "name": "JSON Array (Bacon Ipsum)",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// When using the fetcher, this is the domain of the API that your pack makes\n// fetcher requests to.\npack.addNetworkDomain(\"baconipsum.com\");\n\n// This line adds a new formula to this Pack.\npack.addFormula({\n  name: \"BaconIpsum\",\n  description: \"Returns meat-themed lorem ipsum copy.\",\n  parameters: [], // No parameters required.\n  resultType: coda.ValueType.String,\n\n  // This function is declared async to that is can wait for the fetcher to\n  // complete. The context parameter provides access to the fetcher.\n  execute: async function ([], context) {\n    let url = \"https://baconipsum.com/api/?type=meat-and-filler\";\n\n    // The fetcher's fetch method makes the request. The await keyword is used\n    // to wait for the API's response before continuing on through the code.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n\n    // The API returns an array of strings, which is automatically parsed by\n    // the fetcher into a JavaScript object.\n    let paragraphs = response.body;\n\n    // Return the paragraphs separated by a blank line.\n    return paragraphs.join(\"\\n\\n\");\n  },\n});"
      }
    ]
  },
  {
    "name": "Data types",
    "description": "Samples that show how to return values of various data types.",
    "icon": "material/order-alphabetical-ascending",
    "category": "Topic",
    "triggerTokens": [
      "resultType",
      "type"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/basics/data-types"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/basics/data-types",
    "learnMoreLink": "/guides/basics/data-types",
    "content": "Packs can return various types of values, and apply hints that tell Coda how to display that data. Formulas and schema properties must declare the these types upfront, and the values you return in your code must match.",
    "exampleSnippets": [
      {
        "name": "Template (String)",
        "content": "The basic structure of a formula that returns a string.",
        "code": "pack.addFormula({\n  name: \"MyFormula\",\n  description: \"My description.\",\n  parameters: [\n    // TODO: Add parameters.\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function (args, context) {\n    // TODO: Unpack the parameter values.\n    let [] = args;\n    // TODO: Compute the result.\n    return \"\";\n  },\n});"
      },
      {
        "name": "Template (Number)",
        "content": "The basic structure of a formula that returns a number.",
        "code": "pack.addFormula({\n  name: \"MyFormula\",\n  description: \"My description.\",\n  parameters: [\n    // TODO: Add parameters.\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function (args, context) {\n    // TODO: Unpack the parameter values.\n    let [] = args;\n    // TODO: Compute the result.\n    return 0;\n  },\n});"
      },
      {
        "name": "Template (Boolean)",
        "content": "The basic structure of a formula that returns a boolean.",
        "code": "pack.addFormula({\n  name: \"MyFormula\",\n  description: \"My description.\",\n  parameters: [\n    // TODO: Add parameters.\n  ],\n  resultType: coda.ValueType.Boolean,\n  execute: async function (args, context) {\n    // TODO: Unpack the parameter values.\n    let [] = args;\n    // TODO: Compute the result.\n    return true;\n  },\n});"
      },
      {
        "name": "Template (Array)",
        "content": "The basic structure of a formula that returns an array.",
        "code": "pack.addFormula({\n  name: \"MyFormula\",\n  description: \"My description.\",\n  parameters: [\n    // TODO: Add parameters.\n  ],\n  resultType: coda.ValueType.Array,\n  items: coda.makeSchema({\n    type: coda.ValueType.String,\n  }),\n  execute: async function (args, context) {\n    // TODO: Unpack the parameter values.\n    let [] = args;\n    // TODO: Compute the result.\n    return [];\n  },\n});"
      },
      {
        "name": "Template (Object)",
        "content": "The basic structure of a formula that returns an object.",
        "code": "pack.addFormula({\n  name: \"MyFormula\",\n  description: \"My description.\",\n  parameters: [\n    // TODO: Add parameters.\n  ],\n  resultType: coda.ValueType.Object,\n  schema: ThingSchema,\n  execute: async function (args, context) {\n    // TODO: Unpack the parameter values.\n    let [] = args;\n    // TODO: Compute the result.\n    return {};\n  },\n});"
      },
      {
        "name": "Percent",
        "content": "A formula that returns a number formatted as a percent value. This sample converts a number of slices of pizza into a percentage eaten.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that converts slices of a pizza into a percentage eaten.\npack.addFormula({\n  name: \"PizzaEaten\",\n  description: \"Calculates what percentage of a pizza was eaten.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"slices\",\n      description: \"How many slices were eaten.\",\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Percent,\n  execute: async function ([slices], context) {\n    return slices / 8;\n  },\n});"
      },
      {
        "name": "Currency",
        "content": "A formula that returns a number formatted as a currency value. This sample converts from another currency to US dollars.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"exchangerate.host\");\n\npack.addFormula({\n  name: \"ToUSD\",\n  description: \"Convert from a different currency to US dollars.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"amount\",\n      description: \"The amount to convert.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"from\",\n      description: \"The currency to convert from.\",\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  schema: {\n    type: coda.ValueType.Number,\n    codaType: coda.ValueHintType.Currency,\n    // Ensure the currency symbol displayed with the result is \"$\".\n    currencyCode: \"USD\",\n    // Only show two decimal places (no fractional pennies).\n    precision: 2,\n  },\n  execute: async function ([amount, from], context) {\n    let url = coda.withQueryParams(\"https://api.exchangerate.host/latest\", {\n      base: from,\n      amount: amount,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    let rates = response.body.rates;\n    return rates.USD;\n  },\n});"
      },
      {
        "name": "Date and time",
        "content": "A formula that returns a date and time, passed as a string. This sample adds five minutes onto the given date and time.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that adds five minutes to an input date and time.\npack.addFormula({\n  name: \"FiveMinsLate\",\n  description: \"Adds five minutes to the input date and time.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"input\",\n      description: \"The input date and time.\",\n    }),\n  ],\n  // Return the result as the number of seconds since the epoch.\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Time,\n  execute: async function ([input], context) {\n    let seconds = input.getTime() / 1000;\n    seconds += 5 * 60; // Add five minutes, as seconds.\n    return seconds;\n  },\n});"
      },
      {
        "name": "Markdown",
        "content": "A formula that returns markdown content. This sample returns the contents of the README.md file from a GitHub repository.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Returns the contents of GitHub repo's README.md file as markdown.\npack.addFormula({\n  name: \"GetReadme\",\n  description: \"Gets the content of a GitHub repo's README.md file.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"repo\",\n      description: \"The repo to read from.\",\n      suggestedValue: \"coda/packs-sdk\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.Markdown,\n  execute: async function ([repo], context) {\n    let url = `https://raw.githubusercontent.com/${repo}/HEAD/README.md`;\n    let result = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return result.body;\n  },\n});\n\npack.addNetworkDomain(\"raw.githubusercontent.com\");"
      },
      {
        "name": "HTML",
        "content": "A formula that returns HTML content. This sample returns HTML with every word of the input string bolded.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Returns HTML with every other word of the input text bolded.\npack.addFormula({\n  name: \"AlternatingBold\",\n  description: \"Bold every other word.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"The text to bold.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.Html,\n  execute: async function ([text], context) {\n    let words = text.split(\" \");\n    for (let i = 0; i < words.length; i++) {\n      if (i % 2 === 0) {\n        words[i] = `<b>${words[i]}</b>`;\n      }\n    }\n    return words.join(\" \");\n  },\n});"
      },
      {
        "name": "Embed",
        "content": "A formula that a URL to embed. This sample returns an embed of the infamous YouTube video for \"Never Gonna Give You Up\" by Rick Astley.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Returns the infamous YouTube video by Rick Astley as an embed.\npack.addFormula({\n  name: \"Rickroll\",\n  description: \"Embeds the video \\\"Never Gonna Give You Up\\\".\",\n  parameters: [],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.Embed,\n  execute: async function ([], context) {\n    return \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\";\n  },\n});"
      },
      {
        "name": "Image",
        "content": "A formula that returns an image, as a reference. This sample returns a random photo of a cat.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"filter\",\n      description: \"A filter to apply to the image.\",\n      autocomplete: [\"blur\", \"mono\", \"sepia\", \"negative\", \"paint\", \"pixel\"],\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text, filter], context) {\n    let url = \"https://cataas.com/cat\";\n    if (text) {\n      url += \"/says/\" + encodeURIComponent(text);\n    }\n    url = coda.withQueryParams(url, {\n      filter: filter,\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");"
      }
    ]
  },
  {
    "name": "Schemas",
    "description": "Samples that show how to define a schema, to represent rich objects.",
    "icon": "material/format-list-group",
    "category": "Topic",
    "triggerTokens": [
      "makeSchema",
      "makeObjectSchema"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/advanced/schemas"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/advanced/schemas",
    "learnMoreLink": "/guides/advanced/schemas",
    "content": "To return structured data in a Pack you must first define the shape of that data using a schema. Schemas describe the type of data that will be returned, as well as metadata about how Coda should render it, but not the data itself. Pack formulas and sync tables specify which schema they are using and return data that matches it.\n\nThe most common form of schema you'll need to define are object schemas. They are often used to bundle together multiple pieces of data returned by an API.",
    "exampleSnippets": [
      {
        "name": "Template (Object Schema)",
        "content": "The basic structure of an object schema.",
        "code": "const ThingSchema = coda.makeObjectSchema({\n  properties: {\n    name: { type: coda.ValueType.String },\n    // TODO: Add more properties.\n  },\n  displayProperty: \"$2\",\n});"
      },
      {
        "name": "For formula",
        "content": "An object schema used by a formula. This sample defines the schema for information about the daylight at a given location.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Define a schema for the information about the daylight at a given location.\nconst SunSchema = coda.makeObjectSchema({\n  properties: {\n    daylight: {\n      description: \"How much daylight there will be.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Duration,\n    },\n    sunriseUTC: {\n      description: \"When the sun will rise (in UTC).\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Time,\n    },\n    sunsetUTC: {\n      description: \"When the sun will set (in UTC).\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Time,\n    },\n  },\n  // Which of the properties defined above will be shown inside the chip.\n  displayProperty: \"daylight\",\n});"
      },
      {
        "name": "For sync table",
        "content": "An object schema used by a sync table. This sample defines the schema for the information about a spell in Dungeons and Dragons.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Schema that defines the a spell object.\nlet SpellSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The spell name.\",\n      type: coda.ValueType.String,\n    },\n    description: {\n      description: \"A description of the spell.\",\n      type: coda.ValueType.String,\n    },\n    higher_level: {\n      description: \"A description for casting the spell at a higher level.\",\n      type: coda.ValueType.String,\n    },\n    level: {\n      description: \"The level of the spell.\",\n      type: coda.ValueType.Number,\n    },\n    range: {\n      description: \"The range of the spell.\",\n      type: coda.ValueType.String,\n    },\n    material: {\n      description: \"The material component for the spell to be cast.\",\n      type: coda.ValueType.String,\n    },\n    duration: {\n      description: \"How long the spell effect lasts.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"Instantaneous\".\n    },\n    casting_time: {\n      description: \"How long it takes for the spell to activate.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"1 action\".\n    },\n    attack_type: {\n      description: \"The attack type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    damage_type: {\n      description: \"The damage type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    index: {\n      description: \"A unique identifier for the spell.\",\n      type: coda.ValueType.String,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"index\",\n  featuredProperties: [\"description\", \"level\", \"range\"],\n});"
      },
      {
        "name": "With self-reference",
        "content": "An object schema used by a sync table, that includes a row reference to itself. This sample defines the schema for a task in Todoist, where tasks can have parent tasks.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A reference to a synced Task. Usually you can use\n// `coda.makeReferenceSchemaFromObjectSchema` to generate these from the primary\n// schema, but that doesn't work in this case since a task itself can contain\n// a reference to a parent task.\nconst TaskReferenceSchema = coda.makeObjectSchema({\n  codaType: coda.ValueHintType.Reference,\n  properties: {\n    name: { type: coda.ValueType.String, required: true },\n    taskId: { type: coda.ValueType.String, required: true },\n  },\n  displayProperty: \"name\",\n  idProperty: \"taskId\",\n  // For reference schemas, set identity.name the value of identityName on the\n  // sync table being referenced.\n  identity: {\n    name: \"Task\",\n  },\n});\n\n// A schema defining a Task object.\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    // Add a reference to the sync'ed row of the parent task.\n    // References only work in sync tables.\n    parentTask: TaskReferenceSchema,\n  },\n  displayProperty: \"name\",\n  idProperty: \"taskId\",\n  featuredProperties: [\"description\", \"url\"],\n});"
      }
    ]
  },
  {
    "name": "Dates and times",
    "description": "Samples that show how to work with dates and times.",
    "icon": "material/calendar-clock",
    "category": "Topic",
    "triggerTokens": [
      "Date",
      "Time",
      "DateTime"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/advanced/timezones"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/advanced/timezones",
    "learnMoreLink": "/guides/advanced/timezones",
    "content": "Working with dates and times can be tricky, especially in Coda due to documents and operating in different timezones. These samples demonstrate some patterns you can use when taking them are parameters or returning them as results.",
    "exampleSnippets": [
      {
        "name": "Local date",
        "content": "A formula that requires getting a date in the document's timezone. This sample determines if the year of a given date would make for good New Years Eve glasses (has two or more zeros).",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addFormula({\n  name: \"GoodNYEGlasses\",\n  description: \"Determines if a date is good for New Years Eve glasses \" +\n    \"(the year contains two zeros).\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"date\",\n      description: \"The input date.\",\n    }),\n  ],\n  resultType: coda.ValueType.Boolean,\n  execute: async function ([date], context) {\n    // Format the JavaScript Date into a four-digit year.\n    let formatted = date.toLocaleDateString(\"en\", {\n      timeZone: context.timezone, // Use the timezone of the doc (important!).\n      year: \"numeric\",\n    });\n    // Extract all of the zeros from the year.\n    let zeros = formatted.match(/0/g);\n    return zeros?.length >= 2;\n  },\n});"
      },
      {
        "name": "Local time",
        "content": "A formula that requires getting a time in the document's timezone. This sample shows a time using the military format (ex: \"0900 hours\").",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Displays a time using military conventions. The result is a string (text)\n// value.\npack.addFormula({\n  name: \"ToMilitaryTime\",\n  description: \"Displays a time in military time.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"time\",\n      description: \"The input time.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([time], context) {\n    // Format the JavaScript Date into 2-digit, 24 hour time.\n    let formatted = time.toLocaleTimeString(\"en-US\", {\n      timeZone: context.timezone,  // Use the timezone of the doc (important!).\n      hour12: false, // Use 24 hour time.\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    });\n    // Remove the colon separating the hours and minutes.\n    formatted = formatted.replace(\":\", \"\");\n    return formatted + \" hours\";\n  },\n});"
      },
      {
        "name": "Local date and time",
        "content": "A formula that requires getting a date and time in the document's timezone. This sample determines if all of the digits are the same (ex: 1/1/11 1:11).",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addFormula({\n  name: \"SameDigit\",\n  description: \"Determines if a date and time only contain a single digit.\" +\n    \"For example, 1/1/11 1:11.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"dateAndTime\",\n      description: \"The input date and time.\",\n    }),\n  ],\n  resultType: coda.ValueType.Boolean,\n  execute: async function ([dateAndTime], context) {\n    // Format the JavaScript Date to only include the monday, day, year, hour\n    // and minute as numbers.\n    let formatted = dateAndTime.toLocaleString(\"en-US\", {\n      timeZone: context.timezone, // Use the timezone of the doc (important!).\n      month: \"numeric\",\n      day: \"numeric\",\n      year: \"2-digit\",\n      hour: \"numeric\",\n      minute: \"numeric\",\n    });\n    // Extract the digits from the formatted date.\n    let digits = formatted.match(/\\d/g);\n    // Get the unique set of digits.\n    let unique = new Set(digits);\n    return unique.size === 1;\n  },\n});"
      },
      {
        "name": "Send to API",
        "content": "A formula that requires sending a date to an API. This sample use the Calendarific API to get the holidays on a given date.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema to represent a holiday.\nconst HolidaySchema = coda.makeObjectSchema({\n  properties: {\n    name: { type: coda.ValueType.String },\n    description: { type: coda.ValueType.String },\n    locations: { type: coda.ValueType.String },\n    type: {\n      type: coda.ValueType.Array,\n      items: { type: coda.ValueType.String },\n    },\n  },\n  displayProperty: \"name\",\n});\n\n// Gets the holidays happening in the selected country on a given day.\npack.addFormula({\n  name: \"Holidays\",\n  description: \"Get the holidays (if any) on a given day.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"country\",\n      description: \"Which country's holidays to return (ex: US).\",\n      // Auto-complete the valid country identifiers using the API.\n      autocomplete: async function (context, search) {\n        let response = await context.fetcher.fetch({\n          method: \"GET\",\n          url: \"https://calendarific.com/api/v2/countries\",\n        });\n        let countries = response.body.response.countries;\n        return coda.autocompleteSearchObjects(\n          search,\n          countries,\n          \"country_name\",\n          \"iso-3166\",\n          );\n      },\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"date\",\n      description: \"Which date to lookup.\",\n    }),\n  ],\n  resultType: coda.ValueType.Array,\n  items: HolidaySchema,\n  execute: async function ([country, date], context) {\n    // Create a formatter that outputs a numeric day, month, and year.\n    let formatter = new Intl.DateTimeFormat(\"en\", {\n      timeZone: context.timezone, // Use the doc's timezone (important!)\n      year: \"numeric\",\n      month: \"numeric\",\n      day: \"numeric\",\n    });\n\n    // Format the date into individual parts.\n    let parts = formatter.formatToParts(date);\n\n    // Find the day, month, and year parts.\n    let day = parts.find(part => part.type === \"day\").value;\n    let month = parts.find(part => part.type === \"month\").value;\n    let year = parts.find(part => part.type === \"year\").value;\n\n    // Make a request to the Calendarific API.\n    let url = coda.withQueryParams(\"https://calendarific.com/api/v2/holidays\", {\n      country: country,\n      year: year,\n      month: month,\n      day: day,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n\n    // Return the results.\n    return response.body.response.holidays;\n  },\n});\n\n// Calendarific requires an API key as a query parameter.\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.QueryParamToken,\n  paramName: \"api_key\",\n});\n\npack.addNetworkDomain(\"calendarific.com\");"
      },
      {
        "name": "Time math",
        "content": "A formula that computes a relative time. This sample adds five minutes onto an input date and time.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that adds five minutes to an input date and time.\npack.addFormula({\n  name: \"FiveMinsLate\",\n  description: \"Adds five minutes to the input date and time.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"input\",\n      description: \"The input date and time.\",\n    }),\n  ],\n  // Return the result as the number of seconds since the epoch.\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Time,\n  execute: async function ([input], context) {\n    let seconds = input.getTime() / 1000;\n    seconds += 5 * 60; // Add five minutes, as seconds.\n    return seconds;\n  },\n});"
      }
    ]
  },
  {
    "name": "Images & files",
    "description": "Samples that show how to work with images and files.",
    "icon": "material/image",
    "category": "Topic",
    "triggerTokens": [
      "ImageReference",
      "ImageAttachment",
      "Image",
      "ImageArray",
      "File",
      "Attachment"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/advanced/images"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/advanced/images",
    "learnMoreLink": "/guides/advanced/images",
    "content": "Packs have native support for accepting images and files as parameters and returning them as results, always passed as URLs. Packs can either return a \"live\" URL to a hosted image (`ImageReference`) or a temporary URL that Coda should upload the doc (`ImageAttachment`). The utility provided at `content.temporaryBlobStorage` can be used to save private images to a temporary location for later upload, which can be used in conjunction with the `ImageAttachment` hint type to permanently ingest an image resource using the temporary URL. Packs also provide support for embedded SVGs, including support for dark mode.",
    "exampleSnippets": [
      {
        "name": "Image parameter",
        "content": "A formula that takes an image as a parameter. This sample returns the file size of an image.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Regular expression that matches Coda-hosted images.\nconst HostedImageUrlRegex = new RegExp(\"^https://(?:[^/]*\\.)?codahosted.io/.*\");\n\n// Formula that calculates the file size of an image.\npack.addFormula({\n  name: \"FileSize\",\n  description: \"Gets the file size of an image, in bytes.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Image,\n      name: \"image\",\n      description:\n        \"The image to operate on. Not compatible with Image URL columns.\",\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function ([imageUrl], context) {\n    // Throw an error if the image isn't Coda-hosted. Image URL columns can\n    // contain images on any domain, but by default Packs can only access image\n    // attachments hosted on codahosted.io.\n    if (!imageUrl.match(HostedImageUrlRegex)) {\n      throw new coda.UserVisibleError(\"Not compatible with Image URL columns.\");\n    }\n    // Fetch the image content.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: imageUrl,\n      isBinaryResponse: true, // Required when fetching binary content.\n    });\n    // The binary content of the response is returned as a Node.js Buffer.\n    // See: https://nodejs.org/api/buffer.html\n    let buffer = response.body as Buffer;\n    // Return the length, in bytes.\n    return buffer.length;\n  },\n});"
      },
      {
        "name": "Image result",
        "content": "A formula that return an external image. This sample returns a random photo of a cat.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"filter\",\n      description: \"A filter to apply to the image.\",\n      autocomplete: [\"blur\", \"mono\", \"sepia\", \"negative\", \"paint\", \"pixel\"],\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text, filter], context) {\n    let url = \"https://cataas.com/cat\";\n    if (text) {\n      url += \"/says/\" + encodeURIComponent(text);\n    }\n    url = coda.withQueryParams(url, {\n      filter: filter,\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");"
      },
      {
        "name": "Image result from temporary URL",
        "content": "A formula that returns an image uploaded to `temporaryBlobStorage`. This sample returns a random avatar using an API that returns SVG code used to generate an avatar. You could also imagine procedurally generating a SVG or image in your packs code and uploading it to `temporaryBlobStorage`.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"boringavatars.com\");\n\npack.addFormula({\n  name: \"BoringAvatar\",\n  description: \"Get a boring avatar image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"size\",\n      description: \"The size to generate the avatar in pixels.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageAttachment,\n  execute: async function ([size], context) {\n    let resp = await context.fetcher.fetch({ \n      method: \"GET\", \n      url: `https://source.boringavatars.com/beam/${size}`,\n      // Formats response as binary to get a Buffer of the svg data\n      isBinaryResponse: true, \n    });\n    // This API returns direct SVG code used to generate the avatar.\n    let svg = resp.body;\n\n    let url = await context.temporaryBlobStorage\n                      .storeBlob(svg, \"image/svg+xml\");\n    return url;\n  },\n});"
      },
      {
        "name": "Upload images",
        "content": "An action that downloads images from Coda and uploads them to another service. This sample uploads a list of files to Google Photos.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Regular expression that matches Coda-hosted images.\nconst HostedImageUrlRegex = new RegExp(\"^https://(?:[^/]*\\.)?codahosted.io/.*\");\n\n// A custom type that bundles together the image buffer and content type.\ninterface ImageData {\n  buffer: Buffer,\n  contentType: string,\n}\n\n// Action that uploads a list of images to Google Photos.\npack.addFormula({\n  name: \"Upload\",\n  description: \"Uploads images to Google Photos.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.ImageArray,\n      name: \"images\",\n      description: \"The images to upload.\",\n    }),\n  ],\n  resultType: coda.ValueType.Array,\n  items: {\n    type: coda.ValueType.String,\n    codaType: coda.ValueHintType.Url,\n  },\n  isAction: true,\n  execute: async function ([imageUrls], context) {\n    // Download the images from Coda.\n    let images = await downloadImages(imageUrls, context);\n    // Upload the images to Google Photos, getting temporary tokens.\n    let uploadTokens = await uploadImages(images, context);\n    // Add the images to the user's library, using the tokens.\n    let urls = await addImages(uploadTokens, context);\n    // Return the URLs of the uploaded images.\n    return urls;\n  },\n});\n\n// Download the images from Coda, in parallel. For each image it returns a\n// buffer of image data and the MIME type of the image.\nasync function downloadImages(imageUrls, context: coda.ExecutionContext):\n    Promise<ImageData[]> {\n  let requests = [];\n  for (let imageUrl of imageUrls) {\n    // Reject images not hosted in Coda, since we can't download them.\n    if (!imageUrl.match(HostedImageUrlRegex)) {\n      throw new coda.UserVisibleError(\"Not compatible with Image URL columns.\");\n    }\n\n    // Start the download.\n    let request = context.fetcher.fetch({\n      method: \"GET\",\n      url: imageUrl,\n      isBinaryResponse: true,\n      disableAuthentication: true,\n    });\n    requests.push(request);\n  }\n  // Wait for all the downloads to finish.\n  let responses = await Promise.all(requests);\n\n  // Extract the data from the responses.\n  let images: ImageData[] = [];\n  for (let response of responses) {\n    let data = {\n      buffer: response.body,\n      contentType: response.headers[\"content-type\"] as string,\n    };\n    images.push(data);\n  }\n  return images;\n}\n\n// Uploads the images to Google Photos, in parallel. For each image it returns a\n// temporary upload token.\nasync function uploadImages(images: ImageData[],\n    context: coda.ExecutionContext): Promise<string[]> {\n  let requests = [];\n  for (let image of images) {\n    // Start the upload.\n    let request = context.fetcher.fetch({\n      method: \"POST\",\n      url: \"https://photoslibrary.googleapis.com/v1/uploads\",\n      headers: {\n        \"Content-Type\": \"application/octet-stream\",\n        \"X-Goog-Upload-Content-Type\": image.contentType,\n        \"X-Goog-Upload-Protocol\": \"raw\",\n      },\n      body: image.buffer,\n    });\n    requests.push(request);\n  }\n  // Wait for all the uploads to finish.\n  let responses = await Promise.all(requests);\n\n  // Extract the upload tokens from the responses.\n  let uploadTokens = [];\n  for (let response of responses) {\n    let uploadToken = response.body;\n    uploadTokens.push(uploadToken);\n  }\n  return uploadTokens;\n}\n\n// Adds uploaded images to the user's library. For each image it returns the URL\n// of the image in Google Photos.\nasync function addImages(uploadTokens: string[],\n    context: coda.ExecutionContext): Promise<string[]> {\n  // Construct the request payload.\n  let items = [];\n  for (let uploadToken of uploadTokens) {\n    let item  = {\n      simpleMediaItem: {\n        uploadToken: uploadToken,\n      },\n    };\n    items.push(item);\n  }\n  let payload = {\n    newMediaItems: items,\n  };\n\n  // Make the request to add all the images.\n  let response = await context.fetcher.fetch({\n    method: \"POST\",\n    url: \"https://photoslibrary.googleapis.com/v1/mediaItems:batchCreate\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(payload),\n  });\n  let results = response.body.newMediaItemResults;\n\n  // Extract the URLs from the results.\n  let urls = [];\n  for (let [i, result] of results.entries()) {\n    // Throw an error if any of the uploads failed.\n    if (result.status.message !== \"Success\") {\n      throw new coda.UserVisibleError(\n        `Upload failed for image ${i + 1}: ${result.status.message}`);\n    }\n    let url = result.mediaItem.productUrl;\n    urls.push(url);\n  }\n  return urls;\n}\n\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://accounts.google.com/o/oauth2/v2/auth\",\n  tokenUrl: \"https://oauth2.googleapis.com/token\",\n  scopes: [\n    \"https://www.googleapis.com/auth/photoslibrary.appendonly\",\n  ],\n  additionalParams: {\n    access_type: \"offline\",\n    prompt: \"consent\",\n  },\n});\n\npack.addNetworkDomain(\"googleapis.com\");"
      },
      {
        "name": "Attach image data",
        "content": "A sync table that includes images sourced from raw data. This sample syncs files from Dropbox, including their thumbnail images.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Schema defining the fields to sync for each file.\nconst FileSchema = coda.makeObjectSchema({\n  properties: {\n    name: { type: coda.ValueType.String },\n    path: { type: coda.ValueType.String, fromKey: \"path_display\" },\n    url: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    thumbnail: {\n      type: coda.ValueType.String,\n      // ImageAttachments instructs Coda to ingest the image and store it in the\n      // doc. This is required, since the thumbnail image URLs returned by\n      // TemporaryBlobStorage expire.\n      codaType: coda.ValueHintType.ImageAttachment,\n    },\n    fileId: { type: coda.ValueType.String, fromKey: \"id\" },\n  },\n  displayProperty: \"name\",\n  idProperty: \"fileId\",\n  featuredProperties: [\"thumbnail\", \"url\"],\n});\n\n// Sync table for files.\npack.addSyncTable({\n  name: \"Files\",\n  identityName: \"File\",\n  schema: FileSchema,\n  formula: {\n    name: \"SyncFiles\",\n    description: \"Sync the files.\",\n    parameters: [],\n    execute: async function ([], context) {\n      // Get a batch of files.\n      let filesResponse = await getFiles(context);\n      let files = filesResponse.entries\n        .filter(entry => entry[\".tag\"] === \"file\");\n      let hasMore = filesResponse.has_more;\n\n      // Get the URL for each file.\n      let fileIds = files.map(file => file.id);\n      let fileUrls = await getFileUrls(fileIds, context);\n      for (let i = 0; i < files.length; i++) {\n        files[i].url = fileUrls[i];\n      }\n\n      // Get the thumbnail for each file.\n      let paths = files.map(file => file.path_lower);\n      let thumbnails = await getThumbnails(paths, context);\n\n      // The thumbnail images are returned as base64-encoded strings in the\n      // response body, but the doc can only ingest an image URL. We'll parse\n      // the image data and store it in temporary blob storage, and return those\n      // URLs.\n\n      // Collect the all of the temporary blob storage jobs that are started.\n      let jobs = [];\n      for (let thumbnail of thumbnails) {\n        let job;\n        if (thumbnail) {\n          // Parse the base64 thumbnail content.\n          let buffer = Buffer.from(thumbnail, \"base64\");\n          // Store it in temporary blob storage.\n          job = context.temporaryBlobStorage.storeBlob(buffer, \"image/png\");\n        } else {\n          // The file has no thumbnail, have the job return undefined.\n          job = Promise.resolve(undefined);\n        }\n        jobs.push(job);\n      }\n\n      // Wait for all the jobs to complete, then copy the temporary URLs back\n      // into the file objects.\n      let temporaryUrls = await Promise.all(jobs);\n      for (let i = 0; i < files.length; i++) {\n        files[i].thumbnail = temporaryUrls[i];\n      }\n\n      // If there are more files to retrieve, create a continuation.\n      let continuation;\n      if (hasMore) {\n        continuation = {\n          cursor: filesResponse.cursor,\n        };\n      }\n\n      // Return the results.\n      return {\n        result: files,\n        continuation: continuation,\n      };\n    },\n  },\n});\n\n// Gets a batch of files from the API.\nasync function getFiles(context: coda.ExecutionContext): Promise<any> {\n  let url = \"https://api.dropboxapi.com/2/files/list_folder\";\n  let body;\n\n  // Retrieve the cursor to continue from, if any.\n  let cursor = context.sync.continuation?.cursor;\n  if (cursor) {\n    // Continue from the cursor.\n    url = coda.joinUrl(url, \"/continue\");\n    body = {\n      cursor: cursor,\n    };\n  } else {\n    // Starting a new sync, list all of the files.\n    body = {\n      path: \"\",\n      recursive: true,\n      limit: 25,\n    };\n  }\n\n  // Make the API request and return the response.\n  let response = await context.fetcher.fetch({\n    method: \"POST\",\n    url: url,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(body),\n  });\n  return response.body;\n}\n\n// Get the thumbnail metadata for a list of file paths.\nasync function getThumbnails(paths, context: coda.ExecutionContext):\n    Promise<string[]> {\n  // Use a batch URL to get all of the thumbnail metadata in one request.\n  let url = \"https://content.dropboxapi.com/2/files/get_thumbnail_batch\";\n\n  // Create a request entry for each file path.\n  let entries = [];\n  for (let path of paths) {\n    let entry = {\n      path: path,\n      format: \"png\",\n      size: \"w256h256\",\n    };\n    entries.push(entry);\n  }\n\n  // Make the API request and return the response.\n  let response = await context.fetcher.fetch({\n    method: \"POST\",\n    url: url,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      entries: entries,\n    }),\n  });\n  return response.body.entries.map(entry => entry.thumbnail);\n}\n\n// Get the Dropbox URLs for a list of file IDs.\nasync function getFileUrls(fileIds, context: coda.ExecutionContext):\n    Promise<string[]> {\n  // Use a batch URL to get all of the thumbnail metadata in one request.\n  let url = \"https://api.dropboxapi.com/2/sharing/get_file_metadata/batch\";\n\n  // Make the API request and return the response.\n  let response = await context.fetcher.fetch({\n    method: \"POST\",\n    url: url,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      files: fileIds,\n    }),\n  });\n  return response.body.map(metadata => metadata.result.preview_url);\n}\n\n// Set per-user authentication using Dropbox's OAuth2.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://www.dropbox.com/oauth2/authorize\",\n  tokenUrl: \"https://api.dropbox.com/oauth2/token\",\n  scopes: [\"files.content.read\", \"sharing.read\"],\n  additionalParams: {\n    token_access_type: \"offline\",\n  },\n});\n\n// Allow access to the Dropbox domain.\npack.addNetworkDomain(\"dropboxapi.com\");"
      },
      {
        "name": "Attach private images",
        "content": "A sync table that includes images sourced from private URLs. This sample syncs files from Google Drive, including their thumbnail images.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Schema defining the fields to sync for each file.\nconst FileSchema = coda.makeObjectSchema({\n  properties: {\n    name: { type: coda.ValueType.String },\n    url: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n      fromKey: \"webViewLink\",\n    },\n    thumbnail: {\n      type: coda.ValueType.String,\n      // ImageAttachments instructs Coda to ingest the image and store it in the\n      // doc.\n      codaType: coda.ValueHintType.ImageAttachment,\n    },\n    fileId: {\n      type: coda.ValueType.String,\n      fromKey: \"id\",\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"fileId\",\n  featuredProperties: [\"thumbnail\", \"url\"],\n});\n\n// Sync table for files.\npack.addSyncTable({\n  name: \"Files\",\n  identityName: \"File\",\n  schema: FileSchema,\n  formula: {\n    name: \"SyncFiles\",\n    description: \"Sync the files.\",\n    parameters: [],\n    execute: async function ([], context) {\n      // Retrieve the page token to use from the previous sync, if any.\n      let pageToken = context.sync.continuation?.pageToken;\n\n      // Get a batch of files.\n      let url = \"https://www.googleapis.com/drive/v3/files\";\n      url = coda.withQueryParams(url, {\n        fields: \"files(id,name,webViewLink,thumbnailLink)\",\n        pageToken: pageToken,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let files = response.body.files;\n      let nextPageToken = response.body.nextPageToken;\n\n      // The thumbnail URLs that the Drive API returns require authentication\n      // credentials to access, so the doc won't be able to ingest them as-is.\n      // Instead, we'll download the thumbnails and store them in temporary\n      // blob storage, and return those URLs.\n\n      // Collect the all of the temporary blob storage jobs that are started.\n      let jobs = [];\n      for (let file of files) {\n        let job;\n        if (file.thumbnailLink) {\n          // Download the thumbnail (with credentials) and store it in temporary\n          // blob storage.\n          job = context.temporaryBlobStorage.storeUrl(file.thumbnailLink);\n        } else {\n          // The file has no thumbnail, have the job return undefined.\n          job = Promise.resolve(undefined);\n        }\n        jobs.push(job);\n      }\n\n      // Wait for all the jobs to complete, then copy the temporary URLs back\n      // into the file objects.\n      let temporaryUrls = await Promise.all(jobs);\n      for (let i = 0; i < files.length; i++) {\n        files[i].thumbnail = temporaryUrls[i];\n      }\n\n      // If there are more files to retrieve, create a continuation.\n      let continuation;\n      if (nextPageToken) {\n        continuation = { pageToken: nextPageToken };\n      }\n\n      // Return the results.\n      return {\n        result: files,\n        continuation: continuation,\n      };\n    },\n  },\n});\n\n// Set per-user authentication using Google's OAuth2.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://accounts.google.com/o/oauth2/v2/auth\",\n  tokenUrl: \"https://oauth2.googleapis.com/token\",\n  scopes: [\"https://www.googleapis.com/auth/drive.readonly\"],\n  additionalParams: {\n    access_type: \"offline\",\n    prompt: \"consent\",\n  },\n  // Send the authentication information to all domains.\n  // Note: Using auth with multiple domains requires approval from Coda.\n  networkDomain: [\"googleapis.com\", \"docs.google.com\", \"googleusercontent.com\"],\n});\n\n// Allow access to the Google domains.\n// Note: Using multiple domains in a Pack requires approval from Coda.\npack.addNetworkDomain(\"googleapis.com\");\npack.addNetworkDomain(\"docs.google.com\");\npack.addNetworkDomain(\"googleusercontent.com\");"
      },
      {
        "name": "Generated SVG",
        "content": "A formula that generated an SVG, and returns it as a data URI. This sample generates an image from the text provided.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A formula that generates an image using some input text.\npack.addFormula({\n  name: \"TextToImage\",\n  description: \"Generates an image using the text provided.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"The text to include in the image.\",\n      suggestedValue: \"Hello World!\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"color\",\n      description: \"The desired color of the text. Defaults to black.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text, color = \"black\"], context) {\n    // Calculate the width of the generated image required to fit the text.\n    // Using a fixed-width font to make this easy.\n    let width = text.length * 6;\n    // Generate the SVG markup. Prefer using a library for this when possible.\n    let svg = `\n      <svg viewBox=\"0 0 ${width} 10\" xmlns=\"http://www.w3.org/2000/svg\">\n        <text x=\"0\" y=\"8\" font-family=\"Courier\" font-size=\"10\" fill=\"${color}\">\n          ${text}\n        </text>\n      </svg>\n    `.trim();\n    // Encode the markup as base64.\n    let encoded = Buffer.from(svg).toString(\"base64\");\n    // Return the SVG as a data URL.\n    return coda.SvgConstants.DataUrlPrefix + encoded;\n  },\n});"
      },
      {
        "name": "Dark mode SVG",
        "content": "A formula that generates an SVG that adapts if dark mode is enabled. This sample generates an image with static text, which changes color when dark mode is enabled.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A formula that demonstrates how to generate an SVG that adapts to the user's\n// dark mode setting in Coda.\npack.addFormula({\n  name: \"HelloDarkMode\",\n  description: \"Generates an image that adapts to the dark mode setting.\",\n  parameters: [],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([], context) {\n    // When loading your image in dark mode, Coda will append the URL fragment\n    // \"#DarkMode\". Instead of hard-coding that value, it's safer to retrieve\n    // it from the SDK.\n    let darkModeId = coda.SvgConstants.DarkModeFragmentId;\n    // Generate the SVG markup. Prefer using a library for this when possible.\n    let svg = `\n      <svg viewBox=\"0 0 36 10\" xmlns=\"http://www.w3.org/2000/svg\">\n        <!-- Add the dark mode ID to the root of the SVG. -->\n        <g id=\"${darkModeId}\">\n          <text x=\"0\" y=\"8\" font-family=\"Courier\" font-size=\"10\" fill=\"black\">\n            Hello World!\n          </text>\n        </g>\n        <style>\n          /* Create a style rule that will be applied when the dark mode\n             fragment is applied. */\n          #${darkModeId}:target text { fill: white; }\n        </style>\n      </svg>\n    `.trim();\n    // Encode the markup as base64.\n    let encoded = Buffer.from(svg).toString(\"base64\");\n    // Return the SVG as a data URL (using the dark mode prefix).\n    return coda.SvgConstants.DataUrlPrefixWithDarkModeSupport + encoded;\n  },\n});"
      },
      {
        "name": "File parameter",
        "content": "A formula that takes an file as a parameter. This sample uploads the file to an AWS S3 bucket.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Action that uploads a file to Amazon S3.\npack.addFormula({\n  name: \"Upload\",\n  description: \"Upload a file to AWS S3.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.File,\n      name: \"file\",\n      description: \"The file to upload.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The target file name. Default: the original file name.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"path\",\n      description: \"The target directory path. Default: the root directory.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function ([fileUrl, name, path=\"/\"], context) {\n    // Fetch the file contents.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: fileUrl,\n      isBinaryResponse: true,\n      disableAuthentication: true,\n    });\n    let buffer = response.body;\n    let contentType = response.headers[\"content-type\"] as string;\n    let contentDisposition = response.headers[\"content-disposition\"] as string;\n\n    // Determine file name.\n    if (!name && contentDisposition) {\n      name = getFilename(contentDisposition);\n    }\n    if (!name) {\n      // Fallback to last segment of the URL.\n      name = fileUrl.split(\"/\").pop();\n    }\n\n    // Upload to S3.\n    let s3Url = coda.joinUrl(context.endpoint, path, name);\n    await context.fetcher.fetch({\n      method: \"PUT\",\n      url: s3Url,\n      headers: {\n        \"Content-Type\": contentType,\n        \"Content-Length\": buffer.length.toString(),\n      },\n      body: buffer,\n    });\n    return s3Url;\n  },\n});\n\n// Gets the filename from a Content-Disposition header value.\nfunction getFilename(contentDisposition) {\n  let match = contentDisposition.match(/filename=(.*?)(;|$)/);\n  if (!match) {\n    return;\n  }\n  let filename = match[1].trim();\n  // Remove quotes around the filename, if present.\n  filename = filename.replace(/^[\"'](.*)[\"']$/, \"$1\");\n  return filename;\n}\n\n// Set per-user authentication using AWS Signature Version 4 with an access key.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.AWSAccessKey,\n  service: \"s3\",\n  requiresEndpointUrl: true,\n  endpointDomain: \"amazonaws.com\",\n});\n\n// Allow the pack to make requests to AWS.\npack.addNetworkDomain(\"amazonaws.com\");"
      }
    ]
  },
  {
    "name": "API setup",
    "description": "Samples that show how to configure a Pack to connect to various popular APIs.",
    "icon": "material/api",
    "category": "Topic",
    "triggerTokens": [],
    "linkData": {
      "type": "SamplePage"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/samples/topic/apis",
    "content": "When connecting to an external API the most difficult part can be translating their technical documentation to the configuration options available in Packs, specifically the authentication required. This set of examples shows how to setup a Pack to connect to various popular APIs.",
    "exampleSnippets": [
      {
        "name": "Asana",
        "content": "The Asana API uses OAuth2 to authenticate users, and requires the use of PKCE.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Asana API, using OAuth2.\n// See https://developers.asana.com/docs/oauth\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://app.asana.com/-/oauth_authorize\",\n  tokenUrl: \"https://app.asana.com/-/oauth_token\",\n\n  // Enable PKCE (required).\n  useProofKeyForCodeExchange: true,\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://app.asana.com/api/1.0/users/me\",\n    });\n    let user = response.body.data;\n    return user.name;\n  },\n});\n\n// Allow the pack to make requests to Asana.\npack.addNetworkDomain(\"asana.com\");"
      },
      {
        "name": "AWS S3",
        "content": "The Amazon Web Services (AWS) S3 service uses their custom signature method.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the AWS S3 service, using AWS Signature Version 4.\n// The user provides the URL of their S3 bucket as the endpoint, along with an\n// access key and secret.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.AWSAccessKey,\n  instructionsUrl:\n    \"https://aws.amazon.com/premiumsupport/knowledge-center/create-access-key/\",\n\n  // The AWS service to connect to.\n  service: \"s3\",\n\n  // Prompt the user from their S3 bucket URL.\n  requiresEndpointUrl: true,\n  endpointDomain: \"amazonaws.com\",\n\n  // Use the bucket name as the display name for the account.\n  getConnectionName: async function (context) {\n    return context.endpoint.split(\"//\")[1].split(\".\")[0];\n  },\n});"
      },
      {
        "name": "Board Game Atlas",
        "content": "The Board Game Atlas API requires the developer to provide their client ID as query parameter.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Authenticate using a client ID.\n// See: https://www.boardgameatlas.com/api/docs/apps\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.QueryParamToken,\n  paramName: \"client_id\",\n});\n\npack.addNetworkDomain(\"boardgameatlas.com\");"
      },
      {
        "name": "ClickUp",
        "content": "The ClickUp API uses OAuth2 to authenticate users.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the ClickUp API, using OAuth2.\n// See https://clickup.com/api\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://app.clickup.com/api\",\n  tokenUrl: \"https://app.clickup.com/api/v2/oauth/token\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.clickup.com/api/v2/user\",\n    });\n    let user = response.body.user;\n    return user.username;\n  },\n});\n\n// Allow the pack to make requests to the ClickUp.\npack.addNetworkDomain(\"clickup.com\");"
      },
      {
        "name": "Coda API",
        "content": "The Coda API requires the user to provide an API token, passed in an Authorization header. Packs include a specific authentication type optimized for the Coda API.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Coda API, using a token in the Authorization\n// header.\n// See https://coda.io/developers/apis/v1\npack.setUserAuthentication({\n  type: coda.AuthenticationType.CodaApiHeaderBearerToken,\n\n  // Creates the token automatically when the Pack is installed.\n  shouldAutoAuthSetup: true,\n});\n\n// Allow the pack to make requests to Coda.\npack.addNetworkDomain(\"coda.io\");"
      },
      {
        "name": "Copper API",
        "content": "The Copper API requires the user to provide an API key and their email address, passed in custom HTTP headers.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Copper API, using multiple HTTP headers.\n// See https://developer.copper.com/introduction/requests.html#headers.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.MultiHeaderToken,\n  headers: [\n    { name: \"X-PW-AccessToken\", description: \"API key\" },\n    { name: \"X-PW-UserEmail\", description: \"Email address\" },\n  ],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.copper.com/developer_api/v1/account\",\n      headers: {\n        \"X-PW-Application\": \"developer_api\",\n      },\n    });\n    let account = response.body;\n    return account.name;\n  },\n});\n\n// Allow the pack to make requests to Copper.\npack.addNetworkDomain(\"copper.com\");"
      },
      {
        "name": "Dropbox",
        "content": "The Dropbox API uses OAuth2 to authenticate users, prompting them to approve a specific set of scopes. Additional parameters are requires on the authorization URL to ensure that offline access is granted.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Set per-user authentication using Dropbox's OAuth2.\n// See https://developers.dropbox.com/oauth-guide\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://www.dropbox.com/oauth2/authorize\",\n  tokenUrl: \"https://api.dropbox.com/oauth2/token\",\n  scopes: [\"files.content.read\"],\n\n  // Additional parameters to ensure a refresh_token is returned.\n  additionalParams: {\n    token_access_type: \"offline\",\n  },\n});\n\n// Allow access to the Dropbox domain.\npack.addNetworkDomain(\"dropboxapi.com\");"
      },
      {
        "name": "Facebook (Meta)",
        "content": "The Facebook (Meta) APIs use OAuth2 to authenticate users, prompting them to approve a specific set of scopes.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to Facebook (Meta) APIs, using OAuth2.\n// eslint-disable-next-line max-len\n// See https://developers.facebook.com/docs/facebook-login/guides/advanced/manual-flow\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://www.facebook.com/v14.0/dialog/oauth\",\n  tokenUrl: \"https://graph.facebook.com/v14.0/oauth/access_token\",\n\n  // All scopes: https://developers.facebook.com/docs/permissions/reference\n  scopes: [\n    \"public_profile\",\n  ],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://graph.facebook.com/v14.0/me\",\n    });\n    let user = response.body;\n    return user.name;\n  },\n});\n\n// Allow the pack to make requests to Facebook.\npack.addNetworkDomain(\"facebook.com\");"
      },
      {
        "name": "Giphy",
        "content": "The Giphy API requires the developer to provide their API key as query parameter.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// System-wide authentication to the Giphy API, using an API key in the query\n// string. See https://support.giphy.com/hc/en-us/articles/360020283431.\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.QueryParamToken,\n  paramName: \"api_key\",\n});\n\n// Allow the pack to make requests to Giphy.\npack.addNetworkDomain(\"giphy.com\");"
      },
      {
        "name": "GitHub",
        "content": "The GitHub API uses OAuth2 to authenticate users, prompting them to approve a specific set of scopes. The authorization header uses the non-standard prefix \"token\" instead of the default \"Bearer\".",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Setup per-user authentication using GitHub's OAuth2.\n// Remember to set your client ID and secret in the \"Settings\" tab.\n// See https://docs.github.com/en/developers/apps/building-oauth-apps\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://github.com/login/oauth/authorize\",\n  tokenUrl: \"https://github.com/login/oauth/access_token\",\n  tokenPrefix: \"token\",\n  scopes: [\"repo\", \"user\"],\n\n  // Determines the name of the GitHub account that was connected.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.github.com/user\",\n    });\n    return response.body.login;\n  },\n});\n\n// Allow the Pack to access the GitHub domain.\npack.addNetworkDomain(\"github.com\");"
      },
      {
        "name": "Google",
        "content": "The Google APIs use OAuth2 to authenticate users, prompting them to approve a specific set of scopes. Additional parameters are requires on the authorization URL to ensure that offline access is granted. Note: It currently isn't possible to complete Google's OAuth verification process with a Pack. See the [FAQ](https://coda.io/packs/build/latest/guides/faq/#google) for more information.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to Google APIs, using OAuth2.\n// See https://developers.google.com/identity/protocols/oauth2/web-server\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://accounts.google.com/o/oauth2/v2/auth\",\n  tokenUrl: \"https://oauth2.googleapis.com/token\",\n\n  // All scopes: https://developers.google.com/identity/protocols/oauth2/scopes\n  scopes: [\n    \"profile\",\n  ],\n\n  // Additional parameters to ensure a refresh_token is returned.\n  additionalParams: {\n    access_type: \"offline\",\n    prompt: \"consent\",\n  },\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://www.googleapis.com/oauth2/v1/userinfo\",\n    });\n    let user = response.body;\n    return user.name;\n  },\n});\n\n// Allow the pack to make requests to Google.\npack.addNetworkDomain(\"googleapis.com\");"
      },
      {
        "name": "Jira",
        "content": "The Jira API uses OAuth2 to authenticate users. After authenticating users must select which Jira instance to associate the account with, and all further API requests are sent to that instance's URL.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Jira Cloud API, using OAuth2 with a\n// post-submit step to select the instance to connect to. Note that this code\n// isn't compatible with Jira Data Center.\n// See https://developer.atlassian.com/cloud/confluence/oauth-2-3lo-apps\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://auth.atlassian.com/authorize\",\n  tokenUrl: \"https://auth.atlassian.com/oauth/token\",\n  scopes: [\"offline_access\", \"read:jira-user\", \"read:jira-work\"],\n  additionalParams: {\n    audience: \"api.atlassian.com\",\n    prompt: \"consent\",\n  },\n\n  // After approving access, the user should select which instance they want to\n  // connect to.\n  postSetup: [{\n    type: coda.PostSetupType.SetEndpoint,\n    name: \"SelectEndpoint\",\n    description: \"Select the site to connect to:\",\n    // Determine the list of sites they have access to.\n    getOptions: async function (context) {\n      let url = \"https://api.atlassian.com/oauth/token/accessible-resources\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let sites = response.body;\n      return sites.map(site => {\n        // Constructing an endpoint URL from the site ID.\n        let url = \"https://api.atlassian.com/ex/jira/\" + site.id;\n        return { display: site.name, value: url };\n      });\n    },\n  }],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    // This function is run twice: once before the site has been selected and\n    // again after. When the site hasn't been selected yet, return a generic\n    // name.\n    if (!context.endpoint) {\n      return \"Jira\";\n    }\n    // Include both the name of the user and server.\n    let server = await getServer(context);\n    let user = await getUser(context);\n    return `${user.displayName} (${server.serverTitle})`;\n  },\n});\n\n// Get information about the Jira server.\nasync function getServer(context: coda.ExecutionContext) {\n  let url = \"/rest/api/3/serverInfo\";\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body;\n}\n\n// Get information about the Jira user.\nasync function getUser(context: coda.ExecutionContext) {\n  let url = \"/rest/api/3/myself\";\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: url,\n  });\n  return response.body;\n}\n\n// Allow the pack to make requests to Jira.\npack.addNetworkDomain(\"atlassian.com\");"
      },
      {
        "name": "Microsoft",
        "content": "The Microsoft APIs use OAuth2 to authenticate users, prompting them to approve a specific set of scopes. Additional parameters are requires on the authorization URL to ensure that offline access is granted, and PKCE is recommended.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to Microsoft APIs, using OAuth2.\n// eslint-disable-next-line max-len\n// See https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl:\n    \"https://login.microsoftonline.com/common/oauth2/v2.0/authorize\",\n  tokenUrl: \"https://login.microsoftonline.com/common/oauth2/v2.0/token\",\n\n  // eslint-disable-next-line max-len\n  // Learn more: https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent\n  scopes: [\n    \"offline_access\",\n    \"user.read\",\n  ],\n\n  // Additional parameters to ensure a refresh_token is returned.\n  additionalParams: {\n    prompt: \"consent\",\n  },\n\n  // Enable PKCE (optional but recommended).\n  useProofKeyForCodeExchange: true,\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://graph.microsoft.com/v1.0/me\",\n    });\n    let user = response.body;\n    return user.displayName;\n  },\n});\n\n// Allow the pack to make requests to Microsoft.\npack.addNetworkDomain(\"microsoft.com\");"
      },
      {
        "name": "Okta",
        "content": "The Okta API requires the user to provide an API key, passed as an Authorization header with a custom prefix. The user must also specify which Okta domain to connect to.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Okta API, using a custom token prefix and\n// account-specific endpoints.\n// See https://developer.okta.com/docs/reference/core-okta-api/#authentication\npack.setUserAuthentication({\n  type: coda.AuthenticationType.CustomHeaderToken,\n  headerName: \"Authorization\",\n  tokenPrefix: \"SSWS\",\n\n  // Ask users for their Okta subdomain.\n  requiresEndpointUrl: true,\n  endpointDomain: \"okta.com\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function(context) {\n    // Retrieve the endpoint that the user set.\n    let endpoint = context.endpoint;\n    let url = endpoint + \"/api/v1/org\";\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.companyName;\n  },\n});\n\n// Allow the pack to make requests to Okta.\npack.addNetworkDomain(\"okta.com\");"
      },
      {
        "name": "Rapid API",
        "content": "Rapid APIs require that the developer provide an API key, passed in a custom header.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// System-wide authentication to RapidAPI, using an API key in a custom header.\n// See https://docs.rapidapi.com/docs/keys#how-to-find-your-api-key.\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.CustomHeaderToken,\n  headerName: \"X-RapidAPI-Key\",\n});\n\n// Allow the pack to make requests to RapidAPI.\npack.addNetworkDomain(\"rapidapi.com\");"
      },
      {
        "name": "Salesforce",
        "content": "The Salesforce API uses OAuth2 to authenticate users, prompting them to approve a specific set of scopes. Additional parameters are requires on the authorization URL to ensure that offline access is granted. The URL to send API requests is returned in the OAuth2 response, and passed to other formulas.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Salesforce API, using OAuth2 and an\n// automatically determined account-specific endpoint.\n// eslint-disable-next-line max-len\n// See https://help.salesforce.com/s/articleView?id=sf.remoteaccess_authenticate.htm&type=5\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://login.salesforce.com/services/oauth2/authorize\",\n  tokenUrl: \"https://login.salesforce.com/services/oauth2/token\",\n  scopes: [\"id\", \"api\", \"refresh_token\"],\n  additionalParams: {\n    prompt: \"consent\",\n  },\n\n  // Each account is associated with an instance URL, returned in the OAuth\n  // token response.\n  requiresEndpointUrl: true,\n  endpointDomain: \"salesforce.com\",\n  endpointKey: \"instance_url\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    // Relative URLs have the endpoint URL automatically prepended.\n    let url = \"/services/oauth2/userinfo\";\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.name;\n  },\n});\n\n// Allow the pack to make requests to Salesforce.\npack.addNetworkDomain(\"salesforce.com\");"
      },
      {
        "name": "Slack",
        "content": "The Slack API uses OAuth2 to authenticate users, prompting them to approve a specific set of scopes. Additional settings are required for compatibility with their non-standard implementation.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Slack API, using OAuth2.\n// See https://api.slack.com/authentication/oauth-v2\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://slack.com/oauth/v2/authorize\",\n  tokenUrl: \"https://slack.com/api/oauth.v2.access\",\n  scopes: [\"users.profile:read\"],\n\n  // Slack uses a comma as the scope delimiter.\n  scopeDelimiter: \",\",\n\n  // Slack uses the standard \"scope\" parameter for bot scopes.\n  // User scopes must be specified in the \"user_scope\" parameter instead.\n  scopeParamName: \"user_scope\",\n\n  // The user's OAuth tokens are returned in the nested object \"authed_user\".\n  nestedResponseKey: \"authed_user\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://slack.com/api/users.profile.get\",\n      cacheTtlSecs: 0,\n    });\n    let profile = response.body.profile;\n    return profile.display_name || profile.real_name;\n  },\n});\n\n// Allow the pack to make requests to Slack.\npack.addNetworkDomain(\"slack.com\");"
      },
      {
        "name": "Todoist",
        "content": "The Todoist API uses OAuth2 to authenticate users, prompting them to approve a specific set of scopes.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Todoist API, using an OAuth2 flow.\n// See https://developer.todoist.com/guides/#oauth\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://todoist.com/oauth/authorize\",\n  tokenUrl: \"https://todoist.com/oauth/access_token\",\n  scopes: [\"data:read_write\"],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = coda.withQueryParams(\"https://api.todoist.com/sync/v9/sync\", {\n      resource_types: JSON.stringify([\"user\"]),\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.user?.full_name;\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");"
      },
      {
        "name": "Typeform",
        "content": "The Typeform API uses OAuth2 to authenticate users, prompting them to approve a specific set of scopes.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Configure per-user authentication for the Typeform API, using OAuth2.\n// See: https://developer.typeform.com/get-started/applications/\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://api.typeform.com/oauth/authorize\",\n  tokenUrl: \"https://api.typeform.com/oauth/token\",\n\n  // See: https://developer.typeform.com/get-started/scopes/\n  scopes: [\"forms:read\", \"responses:read\", \"accounts:read\"],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = \"https://api.typeform.com/me\";\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    let profile = response.body;\n    return profile.alias;\n  },\n});\n\n// Allow requests to Typeform.\npack.addNetworkDomain(\"typeform.com\");"
      },
      {
        "name": "Twilio",
        "content": "The Twilio API requires the user to provide the SID and token for their account, passed using the Web Basic scheme.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Per-user authentication to the Twilio API, using an Account SID and token in\n// an \"Authorization: Basic ...\" header.\n// See https://www.twilio.com/docs/usage/requests-to-twilio\npack.setUserAuthentication({\n  type: coda.AuthenticationType.WebBasic,\n  instructionsUrl: \"https://www.twilio.com/docs/sms/api#sms-api-authentication\",\n\n  // Use Twilio-specific placeholders for the username and password fields.\n  uxConfig: {\n    placeholderUsername: \"Account SID\",\n    placeholderPassword: \"Auth Token\",\n  },\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function(context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.twilio.com/2010-04-01/Accounts.json\",\n    });\n    // Return the name of the main account.\n    return response.body.accounts[0].friendly_name;\n  },\n});\n\n// Allow the pack to make requests to Twilio.\npack.addNetworkDomain(\"twilio.com\");"
      },
      {
        "name": "Webflow",
        "content": "The Typeform API uses OAuth2 to authenticate users, and requires the developer to specify the API version in a custom header.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// The version of the Webflow API to use.\nconst WebflowApiVersion = \"1.0.0\";\n\n// Per-user authentication to the ClickUp API, using OAuth2.\n// See https://developers.webflow.com/oauth\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://webflow.com/oauth/authorize\",\n  tokenUrl: \"https://api.webflow.com/oauth/access_token\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.webflow.com/user\",\n      headers: {\n        \"Accept-Version\": WebflowApiVersion,\n      },\n    });\n    let user = response.body.user;\n    return `${user.firstName} ${user.lastName}`;\n  },\n});\n\n// Allow the pack to make requests to Webflow.\npack.addNetworkDomain(\"webflow.com\");"
      },
      {
        "name": "Yahoo",
        "content": "The Yahoo APIs uses OAuth2 to authenticate users.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Setup per-user authentication using Yahoo's OAuth2.\n// Remember to set your client ID and secret in the \"Settings\" tab.\n// See https://developer.yahoo.com/oauth2/guide/flows_authcode/\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://api.login.yahoo.com/oauth2/request_auth\",\n  tokenUrl: \"https://api.login.yahoo.com/oauth2/get_token\",\n  scopes: [\"openid\"],\n\n  // Determines the name of the Yahoo account that was connected.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.login.yahoo.com/openid/v1/userinfo\",\n    });\n    let user = response.body;\n    return user.name;\n  },\n});\n\n// Allow the Pack to access the Yahoo domain.\npack.addNetworkDomain(\"yahoo.com\");"
      }
    ]
  },
  {
    "name": "Cards",
    "description": "Samples that show how to create cards to preview content.",
    "icon": "material/card-text",
    "category": "Topic",
    "triggerTokens": [],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/blocks/cards"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/blocks/cards",
    "learnMoreLink": "/guides/blocks/cards",
    "content": "A card is an visual way to display key information about an item, typically represented by a URL in an external application.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "The basic structure of a card.",
        "code": "// A schema that defines the data shown in the card.\nconst ThingSchema = coda.makeObjectSchema({\n  properties: {\n    name: { type: coda.ValueType.String },\n    description: { type: coda.ValueType.String },\n    picture: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n    link: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    // TODO: Add more properties.\n  },\n  displayProperty: \"$2\",\n  titleProperty: \"$2\",\n  snippetProperty: \"$3\",\n  imageProperty: \"$4\",\n  linkProperty: \"$5\",\n  subtitleProperties: [\n    // TODO: List the properties to show under the title.\n  ],\n});\n\n// A formula that accepts a URL and returns an object matching the schema above.\npack.addFormula({\n  name: \"$1\",\n  description: \"My description.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \" My parameter description.\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: $1Schema,\n  execute: async function (args, context) {\n    let [url] = args;\n    // TODO: Fetch information about the item represented by the URL.\n    return {\n      // TODO: Populate with fetched information.\n      $5: url,\n    };\n  },\n});\n\n// A column format that defines which URL patterns the formula should match.\npack.addColumnFormat({\n  name: \"$1\",\n  instructions: \"My instructions.\",\n  formulaName: \"$1\",\n  matchers: [\n    new RegExp(\"https://example.com/.*\"),\n    // TODO: Optionally add more URL patterns.\n  ],\n});"
      },
      {
        "name": "Basic card",
        "content": "A formula that returns a card containing an title, subtitle, and snippet. This sample returns a card with information about a spell in the game Dungeons & Dragons.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the card, including all of metadata what specifically to\n// highlight in the card.\nlet SpellSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The spell name.\",\n      type: coda.ValueType.String,\n    },\n    description: {\n      description: \"A description of the spell.\",\n      type: coda.ValueType.String,\n    },\n    higher_level: {\n      description: \"A description for casting the spell at a higher level.\",\n      type: coda.ValueType.String,\n    },\n    level: {\n      description: \"The level of the spell.\",\n      type: coda.ValueType.Number,\n    },\n    range: {\n      description: \"The range of the spell.\",\n      type: coda.ValueType.String,\n    },\n    material: {\n      description: \"The material component for the spell to be cast.\",\n      type: coda.ValueType.String,\n    },\n    duration: {\n      description: \"How long the spell effect lasts.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"Instantaneous\".\n    },\n    casting_time: {\n      description: \"How long it takes for the spell to activate.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"1 action\".\n    },\n    attack_type: {\n      description: \"The attack type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    damage_type: {\n      description: \"The damage type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    index: {\n      description: \"A unique identifier for the spell.\",\n      type: coda.ValueType.String,\n    },\n  },\n  displayProperty: \"name\",\n  // Sync table fields.\n  idProperty: \"index\",\n  featuredProperties: [\"description\", \"level\", \"range\"],\n  // Card fields.\n  subtitleProperties: [\n    \"level\",\n    \"range\",\n    \"duration\",\n    \"damage_type\",\n  ],\n  snippetProperty: \"description\",\n});\n\n// Formula that renders a card for a spell given it's name. This will be shown\n// a \"Card\" in the Pack's list of building blocks, but is also a regular formula\n// that can be used elsewhere.\npack.addFormula({\n  name: \"Spell\",\n  description: \"Gets information about a spell, given its name.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the spell.\",\n      suggestedValue: \"Acid Arrow\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: SpellSchema,\n  execute: async function ([name], context) {\n    // Search for spells that match the name provided.\n    let searchUrl = coda.withQueryParams(\n      \"https://www.dnd5eapi.co/api/spells/\",\n      { name: name },\n      );\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: searchUrl,\n    });\n    let results = response.body.results;\n\n    // If no spells match, throw an error.\n    if (!results?.length) {\n      throw new coda.UserVisibleError(\"Unknown spell: \" + name);\n    }\n\n    // Fetch the spell details for the first result.\n    let topResult = results.slice(0, 1);\n    let spells = await fetchSpells(context.fetcher, topResult);\n\n    // Return the spell data for the result.\n    return spells[0];\n  },\n});\n\n// Allow requests to the DND API.\npack.addNetworkDomain(\"dnd5eapi.co\");\n\n// Fetch a batch of spells from the API and return them formatted to match the\n// schema. This utility function is shared by the formula and sync table.\nasync function fetchSpells(fetcher: coda.Fetcher, spellResults) {\n  let requests = [];\n  for (let spellResult of spellResults) {\n    // Add on the domain.\n    let url = \"https://www.dnd5eapi.co\" + spellResult.url;\n    // Put the request in the list. Don\"t use await here, since we want them to\n    // run at the same time.\n    let request = fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    requests.push(request);\n  }\n\n  // Wait for all of the requests to finish.\n  let responses = await Promise.all(requests);\n\n  // Format the API responses and return them.\n  let spells = [];\n  for (let response of responses) {\n    spells.push(formatSpell(response.body));\n  }\n  return spells;\n}\n\n\n// Reformat the API response for a spell to fit the schema.\nfunction formatSpell(spell) {\n  return {\n    // Start with all of the properties in the API response.\n    ...spell,\n    description: spell.desc?.join(\"\\n\"),\n    higher_level: spell.higher_level?.join(\"\\n\"),\n    damage_type: spell.damage?.damage_type?.name,\n  };\n}"
      },
      {
        "name": "With image",
        "content": "A formula that returns a card that includes an image. This samples returns a card with the current weather at a given location in the United States.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Define the schema that will be used to render the card.\nconst WeatherSchema = coda.makeObjectSchema({\n  properties: {\n    summary: { type: coda.ValueType.String, fromKey: \"shortForecast\" },\n    forecast: { type: coda.ValueType.String, fromKey: \"detailedForecast\" },\n    temperature: { type: coda.ValueType.String },\n    wind: { type: coda.ValueType.String, fromKey: \"windSpeed\" },\n    icon: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n    link: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n  },\n  displayProperty: \"summary\",\n  subtitleProperties: [\n    // Only show the value for the temperature property.\n    { property: \"temperature\", label: \"\" },\n    \"wind\",\n  ],\n  snippetProperty: \"forecast\",\n  imageProperty: \"icon\",\n  linkProperty: \"link\",\n});\n\n// Add a formula that fetches the weather and returns it as a card.\npack.addFormula({\n  name: \"CurrentWeather\",\n  description: \"Get the current weather at a specific location (US only).\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"latitude\",\n      description: \"The latitude of the location.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"longitude\",\n      description: \"The longitude of the location.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Boolean,\n      name: \"isMetric\",\n      description: \"Whether to use metric units. Default: false.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: WeatherSchema,\n  execute: async function ([latitude, longitude, isMetric], context) {\n    let url = await getForecastUrl(latitude, longitude, context);\n    if (isMetric) {\n      url = coda.withQueryParams(url, { units: \"si\" });\n    }\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    let data = response.body;\n    let weather = data.properties.periods[0];\n    // Add the unit onto the temperature.\n    weather.temperature = `${weather.temperature}°${weather.temperatureUnit}`;\n    weather.link =\n      coda.withQueryParams(\"https://forecast.weather.gov/MapClick.php\", {\n        lat: latitude,\n        lon: longitude,\n      });\n    return weather;\n  },\n});\n\n// A helper function that gets the forecast URL for a given location.\nasync function getForecastUrl(latitude: number, longitude: number,\n  context: coda.ExecutionContext): Promise<string> {\n  try {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: `https://api.weather.gov/points/${latitude},${longitude}`,\n    });\n    let data = response.body;\n    return data.properties.forecast;\n  } catch (error) {\n    // Check if the error is due to the location being outside the US.\n    if (error.statusCode === 404) {\n      let statusError = error as coda.StatusCodeError;\n      let message = statusError.body?.detail;\n      if (message) {\n        throw new coda.UserVisibleError(message);\n      }\n    }\n    throw error;\n  }\n}\n\npack.addNetworkDomain(\"weather.gov\");"
      },
      {
        "name": "With link matching",
        "content": "A card that can be created manually or automatically when pasting a link. This sample returns a card with the details of a task in Todoist.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the card, including all of metadata what specifically to\n// highlight in the card.\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    priority: {\n      description: \"The priority of the task.\",\n      type: coda.ValueType.String,\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  // Which property's content to show in the title of the card.\n  displayProperty: \"name\",\n  // Which property contains the link to open when the card is clicked.\n  linkProperty: \"url\",\n  // Which property's content to show in the body of the card.\n  snippetProperty: \"description\",\n  // Which properties' content to show in the subtitle of the card.\n  subtitleProperties: [\"priority\"],\n});\n\n// Formula that renders a card for a task given it's URL. This will be shown a\n// \"Card\" in the Pack's list of building blocks, but is also a regular formula\n// that can be used elsewhere.\npack.addFormula({\n  name: \"Task\",\n  description: \"Gets a Todoist task by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n\n  execute: async function ([url], context) {\n    let taskId = extractTaskId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    let task = response.body;\n    return {\n      name: task.content,\n      description: task.description,\n      url: task.url,\n      priority: task.priority,\n      taskId: task.id,\n    };\n  },\n});\n\n// Regular expressions that match Todoist task URLs. Used to match and parse\n// relevant URLs.\nconst TaskUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showTask\\\\?id=([0-9]+)\"),\n];\n\n// Add a column format for the Task formula, to define which URLs it should\n// trigger for. This also makes it easier to use the formula in a table column.\npack.addColumnFormat({\n  // How the option will show in the link and column type dialogs.\n  name: \"Task\",\n  // The formula that generates the card.\n  formulaName: \"Task\",\n  // The set of regular expressions that match Todoist task URLs.\n  matchers: TaskUrlPatterns,\n});\n\n// Helper function to extract the Task ID from the URL.\nfunction extractTaskId(taskUrl: string) {\n  for (let pattern of TaskUrlPatterns) {\n    let matches = taskUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid task URL: \" + taskUrl);\n}\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      }
    ]
  },
  {
    "name": "Two-way sync",
    "description": "Samples that show how to create sync tables with editable values.",
    "icon": "material/card-text",
    "category": "Topic",
    "triggerTokens": [],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/blocks/sync-tables/two-way"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/guides/blocks/sync-tables/two-way",
    "learnMoreLink": "/guides/blocks/sync-tables/two-way",
    "content": "Two-way sync is an optional feature of sync tables that allows users to make edits to row data and push those changes back to the data source. Pack makers enable two-way sync on their tables by annotating their schemas and writing an `executeUpdate` function that handles the update logic.",
    "exampleSnippets": [
      {
        "name": "Simple two-way sync",
        "content": "A sync table that supports user edits via two-way sync. It uses the default behavior of updating one row at a time. This sample syncs the tasks from a user's Todoist account.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the data in the sync table, indicating which fields are\n// editable (mutable).\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      fromKey: \"content\",\n      required: true,\n      mutable: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n      mutable: true,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    completed: {\n      description: \"If the task has been completed.\",\n      type: coda.ValueType.Boolean,\n      fromKey: \"is_completed\",\n      mutable: true,\n    },\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"name\", \"description\", \"url\", \"completed\"],\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [],\n    execute: async function (args, context) {\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: \"https://api.todoist.com/rest/v2/tasks\",\n      });\n      let tasks = response.body;\n      return {\n        result: tasks,\n      };\n    },\n    // Function that handles the row updates.\n    executeUpdate: async function (args, updates, context) {\n      // By default only one row is processed at a time.\n      let update = updates[0];\n      let { previousValue, newValue } = update;\n      let taskId = newValue.id;\n\n      // Update the completion status, if it has changed.\n      if (previousValue.is_completed !== newValue.is_completed) {\n        let action = newValue.is_completed ? \"close\" : \"reopen\";\n        await context.fetcher.fetch({\n          method: \"POST\",\n          url: `https://api.todoist.com/rest/v2/tasks/${taskId}/${action}`,\n        });\n      }\n\n      // Update the other properties of the task.\n      let response = await context.fetcher.fetch({\n        url: `https://api.todoist.com/rest/v2/tasks/${taskId}`,\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(newValue),\n      });\n\n      // Return the updated task.\n      let updated = response.body;\n      return {\n        result: [updated],\n      };\n    },\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      },
      {
        "name": "With batched updates",
        "content": "A sync table that supports user edits via two-way sync, batch processing multiple rows at once. This sample syncs the tasks from a user's Todoist account.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the data in the sync table, indicating which fields are\n// editable (mutable).\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      fromKey: \"content\",\n      required: true,\n      mutable: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n      mutable: true,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    completed: {\n      description: \"If the task has been completed.\",\n      type: coda.ValueType.Boolean,\n      fromKey: \"is_completed\",\n      mutable: true,\n    },\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"name\", \"description\", \"url\", \"completed\"],\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [],\n    execute: async function (args, context) {\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: \"https://api.todoist.com/rest/v2/tasks\",\n      });\n      let tasks = response.body;\n      return {\n        result: tasks,\n      };\n    },\n    maxUpdateBatchSize: 10,\n    // Function that handles the row updates.\n    executeUpdate: async function (args, updates, context) {\n      // Create an async job for each update.\n      let jobs = updates.map(async update => {\n        return updateTask(context, update);\n      });\n      // Wait for all of the jobs to finish .\n      let completed = await Promise.allSettled(jobs);\n\n      // For each update, return either the updated row or an error if the\n      // update failed.\n      let results = completed.map(job => {\n        if (job.status === \"fulfilled\") {\n          return job.value;\n        } else {\n          return job.reason;\n        }\n      });\n\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\nasync function updateTask(context: coda.ExecutionContext,\n  update: coda.GenericSyncUpdate): Promise<any> {\n  let { previousValue, newValue } = update;\n  let taskId = newValue.id;\n\n  // Update the completion status, if it has changed.\n  if (previousValue.is_completed !== newValue.is_completed) {\n    let action = newValue.is_completed ? \"close\" : \"reopen\";\n    await context.fetcher.fetch({\n      method: \"POST\",\n      url: `https://api.todoist.com/rest/v2/tasks/${taskId}/${action}`,\n    });\n  }\n\n  // Update the other properties of the task.\n  let response = await context.fetcher.fetch({\n    url: `https://api.todoist.com/rest/v2/tasks/${taskId}`,\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(newValue),\n  });\n\n  // Return the updated task.\n  return response.body;\n}\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      },
      {
        "name": "Using a batch update endpoint",
        "content": "A sync table that supports user edits via two-way sync, batch processing multiple rows at once using the API's batch update endpoint. This sample syncs the tasks from a user's Todoist account.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the data in the sync table, indicating which fields are\n// editable (mutable).\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      fromKey: \"content\",\n      required: true,\n      mutable: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n      mutable: true,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    completed: {\n      description: \"If the task has been completed.\",\n      type: coda.ValueType.Boolean,\n      fromKey: \"is_completed\",\n      mutable: true,\n    },\n    id: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n  },\n  displayProperty: \"name\",\n  idProperty: \"id\",\n  featuredProperties: [\"name\", \"description\", \"url\", \"completed\"],\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [],\n    execute: async function (args, context) {\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: \"https://api.todoist.com/rest/v2/tasks\",\n      });\n      let tasks = response.body;\n      return {\n        result: tasks,\n      };\n    },\n    // Process updates in batches of 10 rows at a time.\n    maxUpdateBatchSize: 10,\n    // Function that handles the row updates.\n    executeUpdate: async function (args, updates, context) {\n      // Generate the set of commands needed to process each update.\n      let commandSets = updates.map(update => generateCommands(update));\n\n      // Send all of the commands to the sync endpoint.\n      let response = await context.fetcher.fetch({\n        method: \"POST\",\n        url: \"https://api.todoist.com/sync/v9/sync\",\n        form: {\n          commands: JSON.stringify(commandSets.flat()),\n        },\n      });\n      let statuses = response.body.sync_status;\n\n      // Process the results, returning either an error or the updated task.\n      // This is done async, so the fetches can be done in parallel.\n      let jobs = updates.map(async (update, i) => {\n        let taskId = update.newValue.id;\n        let commands = commandSets[i];\n        for (let command of commands) {\n          let status = statuses[command.uuid];\n          if (status.error) {\n            return new coda.UserVisibleError(status.error);\n          }\n        }\n        // If there were no errors, fetch the updated task and return it.\n        return getTask(context, taskId);\n      });\n      let results = await Promise.all(jobs);\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// Generate a list of API commands from a row update.\nfunction generateCommands(update: coda.GenericSyncUpdate): any[] {\n  let commands = [];\n  let { previousValue, newValue } = update;\n  // Update the task.\n  commands.push({\n    type: \"item_update\",\n    uuid: Math.random().toString(36),\n    args: newValue,\n  });\n  // Update the completion status, if it's changed.\n  if (previousValue.is_completed !== newValue.is_completed) {\n    commands.push({\n      type: newValue.is_completed ? \"item_complete\" : \"item_uncomplete\",\n      uuid: Math.random().toString(36),\n      args: {\n        id: newValue.id,\n      },\n    });\n  }\n  return commands;\n}\n\n// Fetch the current state of an individual task.\nasync function getTask(context: coda.ExecutionContext, id: string) {\n  let response = await context.fetcher.fetch({\n    method: \"GET\",\n    url: `https://api.todoist.com/rest/v2/tasks/${id}`,\n  });\n  return response.body;\n}\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      },
      {
        "name": "With property options",
        "content": "A sync table that supports user edits via two-way sync, with a defined set of options for certain properties. This sample syncs a user's expenses in Splitwise.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\nconst CategorySchema = coda.makeObjectSchema({\n  properties: {\n    categoryId: {\n      description: \"A unique ID for the category.\",\n      type: coda.ValueType.Number,\n      fromKey: \"id\",\n      required: true,\n    },\n    name: {\n      description: \"The name of the category.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    icon: {\n      description: \"An icon representing the category.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n  },\n  displayProperty: \"name\",\n});\n\nconst ExpenseSchema = coda.makeObjectSchema({\n  properties: {\n    expenseId: {\n      description: \"A unique ID for the expense.\",\n      type: coda.ValueType.String,\n      fromKey: \"id\",\n    },\n    description: {\n      description: \"The description of the expense.\",\n      type: coda.ValueType.String,\n      mutable: true,\n    },\n    date: {\n      description: \"The date the expense was made.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Date,\n      mutable: true,\n    },\n    cost: {\n      description: \"The total cost of the expense.\",\n      type: coda.ValueType.Number,\n      codaType: coda.ValueHintType.Currency,\n      mutable: true,\n    },\n    notes: {\n      description: \"Any notes on the expense.\",\n      type: coda.ValueType.String,\n      fromKey: \"details\",\n      mutable: true,\n    },\n    repeat: {\n      description: \"How often the expense automatically repeats.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.SelectList,\n      fromKey: \"repeat_interval\",\n      mutable: true,\n      // Static list of options.\n      options: [\"never\", \"weekly\", \"fortnightly\", \"monthly\", \"yearly\"],\n    },\n    currency: {\n      description: \"The code of the currency of the expense.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.SelectList,\n      fromKey: \"currency_code\",\n      mutable: true,\n      // Dynamic list of options.\n      options: async function (context) {\n        // Fetch the list of supported currencies.\n        let response = await context.fetcher.fetch({\n          method: \"GET\",\n          url: \"https://secure.splitwise.com/api/v3.0/get_currencies\",\n        });\n        return response.body.currencies.map(currency => currency.currency_code);\n      },\n    },\n    category: {\n      ...CategorySchema,\n      codaType: coda.ValueHintType.SelectList,\n      mutable: true,\n      // Dynamic list of options, as objects.\n      options: async function (context) {\n        let response = await context.fetcher.fetch({\n          method: \"GET\",\n          url: \"https://secure.splitwise.com/api/v3.0/get_categories\",\n        });\n        let categories = response.body.categories;\n        let result = [];\n        for (let category of categories) {\n          result.push(category);\n          let subcategories = category.subcategories || [];\n          for (let subcategory of subcategories) {\n            if (subcategory.name === \"Other\") {\n              // Add the parent category's name in front, to distinguish it.\n              subcategory.name = `${category.name} - ${subcategory.name}`;\n            }\n            result.push(subcategory);\n          }\n        }\n        return result;\n      },\n    },\n  },\n  displayProperty: \"description\",\n  idProperty: \"expenseId\",\n  featuredProperties: [\n    \"date\", \"cost\", \"notes\", \"currency\", \"repeat\", \"category\",\n  ],\n});\n\npack.addSyncTable({\n  name: \"Expenses\",\n  description: \"Lists your expenses.\",\n  identityName: \"Expense\",\n  schema: ExpenseSchema,\n  formula: {\n    name: \"SyncExpenses\",\n    description: \"Syncs the data.\",\n    parameters: [],\n    execute: async function (args, context) {\n      let [] = args;\n      let offset = context.sync.continuation?.offset as number || 0;\n      let limit = 20;\n      let url = coda.withQueryParams(\n        \"https://secure.splitwise.com/api/v3.0/get_expenses\",\n        {\n          offset: offset,\n          limit: limit,\n        }\n      );\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let expenses = response.body.expenses;\n\n      let continuation;\n      if (expenses.length === limit) {\n        offset += limit;\n        continuation = { offset: offset };\n      }\n\n      return {\n        result: expenses,\n        continuation: continuation,\n      };\n    },\n    maxUpdateBatchSize: 10,\n    executeUpdate: async function (args, updates, context) {\n      // Make all of the updates in parallel to improve performance.\n      let jobs = updates.map(async update => {\n        return updateExpense(context, update);\n      });\n      let completed = await Promise.allSettled(jobs);\n      let results = completed.map(job => {\n        if (job.status === \"fulfilled\") {\n          return job.value;\n        } else {\n          return job.reason;\n        }\n      });\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\nasync function updateExpense(context: coda.ExecutionContext,\n  update: coda.GenericSyncUpdate) {\n  let expense = update.newValue;\n\n  // Only include fields in the body that have been updated.\n  // The API will throw an error if you include fields that can't be modified.\n  let body: Record<string, any> = {};\n  for (let field of update.updatedFields) {\n    if (field === \"category\") {\n      // Only send the category ID when updating it.\n      body.category_id = expense.category.id;\n    } else {\n      body[field] = expense[field];\n    }\n  }\n\n  try {\n    let response = await context.fetcher.fetch({\n      method: \"POST\",\n      url: `https://secure.splitwise.com/api/v3.0/update_expense/${expense.id}`,\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    });\n    let result = response.body;\n    return result.expenses[0];\n  } catch (e) {\n    // If the API returned an error, show that error to the user.\n    if (coda.StatusCodeError.isStatusCodeError(e)) {\n      let errors = Object.values(e.body.errors).flat();\n      if (errors?.length > 0) {\n        throw new coda.UserVisibleError(errors.join(\"\\n\"));\n      }\n    }\n    throw e;\n  }\n}\n\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://secure.splitwise.com/oauth/authorize\",\n  tokenUrl: \"https://secure.splitwise.com/oauth/token\",\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://secure.splitwise.com/api/v3.0/get_current_user\",\n    });\n    let user = response.body.user;\n    return `${user.first_name} ${user.last_name}`;\n  },\n});\n\npack.addNetworkDomain(\"splitwise.com\");"
      }
    ]
  },
  {
    "name": "Hello World",
    "description": "A simple \"Hello World\" Pack.",
    "icon": "material/hand-wave-outline",
    "category": "Full",
    "triggerTokens": [],
    "linkData": {
      "type": "SamplePage"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/samples/full/hello-world",
    "content": "This is an example which creates a single formula called `Hello`, that takes in a string called `name` and returns `“Hello, <name>!“`.",
    "exampleSnippets": [
      {
        "name": "Hello World",
        "content": "",
        "code": "/*\nStart making Packs!\nTry out the hello world sample below to create your first build.\n*/\n\n// This import statement gives you access to all parts of the Coda Packs SDK.\nimport * as coda from \"@codahq/packs-sdk\";\n\n// This line creates your new Pack.\nexport const pack = coda.newPack();\n\n// Here, we add a new formula to this Pack.\npack.addFormula({\n  // This is the name that will be called in the formula builder.\n  // Remember, your formula name cannot have spaces in it.\n  name: \"Hello\",\n  description: \"A Hello World example.\",\n\n  // If your formula requires one or more inputs, you’ll define them here.\n  // Here, we're creating a string input called “name”.\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name you would like to say hello to.\",\n    }),\n  ],\n\n  // The resultType defines what will be returned in your Coda doc. Here, we're\n  // returning a simple text string.\n  resultType: coda.ValueType.String,\n\n  // Everything inside this execute statement will happen anytime your Coda\n  // formula is called in a doc. An array of all user inputs is always the 1st\n  // parameter.\n  execute: async function ([name], context) {\n    return \"Hello \" + name + \"!\";\n  },\n});"
      }
    ]
  },
  {
    "name": "Daylight",
    "description": "A Pack that fetches data about the expected hours of daylight at a location.",
    "icon": "fontawesome/regular/sun",
    "category": "Full",
    "triggerTokens": [],
    "linkData": {
      "type": "SamplePage"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/samples/full/daylight",
    "content": "This Pack provides a `Daylight` formula that determines the daylight, sunrise,\n and sunset at a given location using the [Sunrise Sunset API][api]. It accepts\n a latitude, longitude, an optional date and returns a rich object (schema) as\n a result. It uses the `Fetcher` to pull data from an external API.\n\n [api]: https://sunrise-sunset.org/api",
    "exampleSnippets": [
      {
        "name": "pack.ts",
        "content": "",
        "code": "/**\n * This Pack provides a \"Daylight\" formula that determines the daylight,\n * sunrise, and sunset at a given location using the Sunrise Sunset API.\n * The results are returns as a rich object.\n * @see {@link https://sunrise-sunset.org/api|Sunrise Sunset API}\n */\n\n// This import statement provides access to all parts of the Coda Packs SDK.\nimport * as coda from \"@codahq/packs-sdk\";\n\n// This line creates the new Pack.\nexport const pack = coda.newPack();\n\n// The domain that the Pack will match fetcher requests to.\npack.addNetworkDomain(\"sunrise-sunset.org\");\n\n// Define a schema that will be used to bundle up the multiple pieces of data\n// our formula will return. In the Coda doc this will be displayed as a chip.\nconst SunSchema = coda.makeObjectSchema({\n  properties: {\n    // The values we return are simple strings, but we use the codaType field to\n    // to tell Coda to interpret them as durations and time values.\n    daylight: {\n      description: \"How much daylight there will be.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Duration,\n    },\n    sunrise: {\n      description: \"When the sun will rise (in the document's timezone).\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Time,\n    },\n    sunset: {\n      description: \"When the sun will set (in the document's timezone).\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Time,\n    },\n  },\n  // Which of the properties defined above will be shown inside the chip.\n  displayProperty: \"daylight\",\n});\n\n// Add a \"Daylight\" formula to the Pack.\npack.addFormula({\n  name: \"Daylight\",\n  description: \"Returns the sunrise and sunset for a given location.\",\n\n  // This formula takes two required numeric inputs (the latitude and longitude)\n  // and one optional date.\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"lat\",\n      description: \"The latitude to use.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"lng\",\n      description: \"The longitude to use.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"date\",\n      description: \"The date to use. Defaults to today.\",\n      // This date parameter is an optional input.\n      optional: true,\n    }),\n  ],\n\n  // In this formula, we're returning an object with multiple properties.\n  resultType: coda.ValueType.Object,\n\n  // This object will be defined according to the schema written above.\n  schema: SunSchema,\n\n  // Everything inside this execute statement will happen anytime the Coda\n  // formula is called in a doc. An array of all user inputs is passed as the\n  // first parameter. The context object is always the second parameter and is\n  // used for fetching data.\n  execute: async function ([lat, lng, date], context) {\n    // Default to today if no date is provided.\n    let lookupDate = date || new Date();\n\n    // Format the date parameter to a date string in the correct timezone.\n    let formattedDate = lookupDate.toLocaleDateString(\"en\", {\n      timeZone: context.timezone, // Use the timezone of the doc (important!).\n    });\n\n    // Create the URL to fetch, using the helper function coda.withQueryParams\n    // to add on query parameters (ex: \"?lat=40.123...\").\n    let url = coda.withQueryParams(\"https://api.sunrise-sunset.org/json\", {\n      lat: lat,\n      lng: lng,\n      date: formattedDate,\n      formatted: 0,\n    });\n\n    // Fetch the URL and get the response.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n\n    // The JSON returned by the API is parsed automatically and available in\n    // `response.body`. Here we pull out the content in the \"results\" key.\n    let results = response.body.results;\n\n    // Return the final object. The keys here must match with the properties\n    // defined above in the schema.\n    return {\n      daylight: results.day_length + \" seconds\",\n      sunrise: results.sunrise,\n      sunset: results.sunset,\n    };\n  },\n});"
      }
    ]
  },
  {
    "name": "Math",
    "description": "A Pack that provides various math operations.",
    "icon": "material/calculator-variant",
    "category": "Full",
    "triggerTokens": [],
    "linkData": {
      "type": "SamplePage"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/samples/full/math",
    "content": "This Pack contains a few mathematical formulas, including the [greatest common divisor][wikipedia_gcd] (GCD) and [least common multiple][wikipedia_lcm] (LCM).\n\n\n[wikipedia_gcd]: https://en.wikipedia.org/wiki/Greatest_common_divisor\n[wikipedia_lcm]: https://en.wikipedia.org/wiki/Least_common_multiple",
    "exampleSnippets": [
      {
        "name": "pack.ts",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A \"numbers\" parameter shared by both formulas.\nconst NumbersParameter = coda.makeParameter({\n  type: coda.ParameterType.NumberArray,\n  name: \"numbers\",\n  description: \"The numbers to perform the calculation on.\",\n});\n\npack.addFormula({\n  name: \"GCD\",\n  description: \"Returns the greatest common divisor for a list of numbers.\",\n  parameters: [\n    // Use the shared parameter created above.\n    NumbersParameter,\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function ([numbers]) {\n    // Handle the error case where the list is empty.\n    if (numbers.length === 0) {\n      throw new coda.UserVisibleError(\"The list cannot be empty.\");\n    }\n\n    // Handle the error case where all the numbers are zeros.\n    if (numbers.every(number => number === 0)) {\n      throw new coda.UserVisibleError(\n        \"The list must contain a non-zero number.\");\n    }\n\n    let result = numbers[0];\n    for (let i = 1; i < numbers.length; i++) {\n      let number = numbers[i];\n      result = gcd(number, result);\n    }\n    return result;\n  },\n});\n\npack.addFormula({\n  name: \"LCM\",\n  description: \"Returns the least common multiple for a list of numbers.\",\n  parameters: [\n    // Use the shared parameter created above.\n    NumbersParameter,\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function ([numbers]) {\n    // Handle the error case where the list is empty.\n    if (numbers.length === 0) {\n      throw new coda.UserVisibleError(\"The list cannot be empty.\");\n    }\n\n    // Handle the error case where the list contains a zero.\n    if (numbers.some(number => number === 0)) {\n      throw new coda.UserVisibleError(\"The list must not contain a zero.\");\n    }\n\n    let result = numbers[0];\n    for (let i = 1; i < numbers.length; i++) {\n      let number = numbers[i];\n      result = Math.abs(number * result) / gcd(number, result);\n    }\n    return result;\n  },\n});\n\n// Helper function that calculates the greatest common divisor of two\n// numbers.\nfunction gcd(a, b) {\n  if (a === 0) {\n    return b;\n  }\n  return gcd(b % a, a);\n}"
      }
    ]
  },
  {
    "name": "Todoist",
    "description": "A Pack that integrates with the application Todoist.",
    "icon": "octicons/tasklist-16",
    "category": "Full",
    "triggerTokens": [],
    "linkData": {
      "type": "SamplePage"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/samples/full/todoist",
    "content": "This Pack provides an integration with the task tracking app [Todoist][todoist]. It uses a variety of building blocks to allow users to work with their projects and tasks, including:\n\n- Formulas that provide rich data about an item given its URL.\n- Column formats that automatically apply those formulas to matching URLs.\n- Action formulas that create and update items, for use in button and automations.\n- Sync tables for pulling in all of the user's items.\n\nThe Pack uses OAuth2 to connect to a user's Todoist account, which you can create for free.\n\n[todoist]: https://todoist.com/",
    "exampleSnippets": [
      {
        "name": "pack.ts",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\n\n// #region Constants\n\nconst ProjectUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/project/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showProject\\\\?id=([0-9]+)\"),\n];\n\nconst TaskUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showTask\\\\?id=([0-9]+)\"),\n];\n\n// #endregion\n\n\n// #region Pack setup\n\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"todoist.com\");\n\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // OAuth2 URLs and scopes are found in the the Todoist OAuth guide:\n  // https://developer.todoist.com/guides/#oauth\n  authorizationUrl: \"https://todoist.com/oauth/authorize\",\n  tokenUrl: \"https://todoist.com/oauth/access_token\",\n  scopes: [\"data:read_write\"],\n  scopeDelimiter: \",\",\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = coda.withQueryParams(\"https://api.todoist.com/sync/v9/sync\", {\n      resource_types: JSON.stringify([\"user\"]),\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.user?.full_name;\n  },\n});\n\n// #endregion\n\n\n// #region Schemas\n\nconst DueSchema = coda.makeObjectSchema({\n  properties: {\n    date: {\n      description: \"The date the task is due.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Date,\n    },\n    time: {\n      description: \"The specific moment the task is due.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.DateTime,\n      fromKey: \"datetime\",\n    },\n    display: {\n      description: \"The display value for the due date.\",\n      type: coda.ValueType.String,\n      fromKey: \"string\",\n    },\n  },\n  displayProperty: \"display\",\n});\n\nconst ProjectSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the project.\",\n      type: coda.ValueType.String,\n      mutable: true,\n      required: true,\n    },\n    url: {\n      description: \"A link to the project in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    shared: {\n      description: \"Is the project is shared.\",\n      type: coda.ValueType.Boolean,\n      fromKey: \"is_shared\",\n    },\n    favorite: {\n      description: \"Is the project a favorite.\",\n      type: coda.ValueType.Boolean,\n      mutable: true,\n      fromKey: \"is_favorite\",\n    },\n    projectId: {\n      description: \"The ID of the project.\",\n      type: coda.ValueType.String,\n      required: true,\n      fromKey: \"id\",\n    },\n    parentProjectId: {\n      description: \"For sub-projects, the ID of the parent project.\",\n      type: coda.ValueType.String,\n      fromKey: \"parent_id\",\n    },\n  },\n  displayProperty: \"name\",\n  // Sync table metadata.\n  idProperty: \"projectId\",\n  featuredProperties: [\"url\", \"favorite\"],\n  // Card metadata.\n  linkProperty: \"url\",\n  subtitleProperties: [\"shared\", \"favorite\"],\n});\n\n// Create a reference schema for projects, to use for relation columns.\nconst ProjectReferenceSchema =\n  coda.makeReferenceSchemaFromObjectSchema(ProjectSchema, \"Project\");\n\n// Using the reference schema, add a property for the parent project.\n(ProjectSchema.properties as coda.ObjectSchemaProperties)\n  .parentProject = ProjectReferenceSchema;\n\nconst TaskSchema = coda.makeObjectSchema({\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      fromKey: \"content\",\n      required: true,\n      mutable: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Markdown,\n      mutable: true,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    completed: {\n      description: \"If the task has been completed.\",\n      type: coda.ValueType.Boolean,\n      fromKey: \"is_completed\",\n      mutable: true,\n    },\n    order: {\n      description: \"The position of the task in the project or parent task.\",\n      type: coda.ValueType.Number,\n      mutable: true,\n    },\n    priority: {\n      description: \"The priority of the task.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.SelectList,\n      options: [\"P1\", \"P2\", \"P3\", \"P4\"],\n      mutable: true,\n    },\n    due: {\n      description: \"When the task is due.\",\n      ...DueSchema,\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.String,\n      fromKey: \"id\",\n      required: true,\n    },\n    projectId: {\n      description: \"The ID of the project that the task belongs to.\",\n      type: coda.ValueType.String,\n      fromKey: \"project_id\",\n    },\n    parentTaskId: {\n      description: \"For sub-tasks, the ID of the parent task it belongs to.\",\n      type: coda.ValueType.String,\n      fromKey: \"parent_id\",\n    },\n    // A reference to the project (for sync tables only).\n    project: {\n      ...ProjectReferenceSchema,\n      mutable: true,\n    },\n  },\n  displayProperty: \"name\",\n  // Sync table metadata.\n  idProperty: \"taskId\",\n  featuredProperties: [\"project\", \"url\", \"completed\"],\n  // Card metadata.\n  linkProperty: \"url\",\n  snippetProperty: \"description\",\n  subtitleProperties: [\n    \"priority\",\n    \"completed\",\n    { label: \"Due\", property: \"due.display\" },\n  ],\n});\n\n// Create a reference schema for tasks, to use for relation columns.\nconst TaskReferenceSchema =\n  coda.makeReferenceSchemaFromObjectSchema(TaskSchema, \"Task\");\n\n// Using the reference schema, add a property for the parent task.\n(TaskSchema.properties as coda.ObjectSchemaProperties)\n  .parentTask = TaskReferenceSchema;\n\n// Format a project from the API and return an object matching the schema.\nfunction formatProjectForSchema(project: any, withReferences = false) {\n  let result: any = {\n    ...project,\n  };\n  if (withReferences && project.parent_id) {\n    result.parentProject = {\n      id: project.parent_id,\n      name: \"Not found\", // If sync'ed, the real name will be shown instead.\n    };\n  }\n  return result;\n}\n\n// Format a task from the API and return an object matching the Task schema.\nfunction formatTaskForSchema(task: any, withReferences = false) {\n  let result: any = {\n    ...task,\n    // Convert the priority to a string like \"P1\".\n    priority: \"P\" + (5 - task.priority),\n  };\n  if (withReferences) {\n    // Add a reference to the corresponding row in the Projects sync table.\n    result.project = {\n      id: task.project_id,\n      name: \"Not found\", // If sync'ed, the real name will be shown instead.\n    };\n    if (task.parent_id) {\n      // Add a reference to the corresponding row in the Tasks sync table.\n      result.parentTask = {\n        taskId: task.parent_id,\n        name: \"Not found\", // If sync'ed, the real name will be shown instead.\n      };\n    }\n  }\n  return result;\n}\n\n// Format a task from a sync table and return an object matching the API.\nfunction formatTaskForAPI(task: any) {\n  let result: any = {\n    ...task,\n  };\n  if (result.priority) {\n    // Convert the priority back to a number.\n    result.priority = 5 - Number(result.priority.substring(1));\n  }\n  return result;\n}\n\n// #endregion\n\n\n// #region Formulas\n\npack.addFormula({\n  name: \"Project\",\n  description: \"Gets a Todoist project by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the project\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: ProjectSchema,\n  execute: async function ([url], context) {\n    let projectId = extractProjectId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/projects/\" + projectId,\n      method: \"GET\",\n    });\n    return formatProjectForSchema(response.body);\n  },\n});\n\npack.addFormula({\n  name: \"Task\",\n  description: \"Gets a Todoist task by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n  execute: async function ([url], context) {\n    let taskId = extractTaskId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    return formatTaskForSchema(response.body);\n  },\n});\n\n// #endregion\n\n\n// #region Column Formats\n\npack.addColumnFormat({\n  name: \"Project\",\n  formulaName: \"Project\",\n  matchers: ProjectUrlPatterns,\n});\n\npack.addColumnFormat({\n  name: \"Task\",\n  formulaName: \"Task\",\n  matchers: TaskUrlPatterns,\n});\n\n// #endregion\n\n\n// #region Actions\n\npack.addFormula({\n  name: \"AddProject\",\n  description: \"Add a new Todoist project\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the new project\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function ([name], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/projects\",\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        name: name,\n      }),\n    });\n    return response.body.url;\n  },\n});\n\npack.addFormula({\n  name: \"AddTask\",\n  description: \"Add a new task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the task.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"projectId\",\n      description: \"The ID of the project to add it to. If blank, \" +\n        \"it will be added to the user's Inbox.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function ([name, projectId], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v2/tasks\",\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        content: name,\n        project_id: projectId,\n      }),\n    });\n    return response.body.url;\n  },\n});\n\npack.addFormula({\n  name: \"SetDueDate\",\n  description: \"Change the due date of a task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"taskId\",\n      description: \"The ID of the task.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"date\",\n      description: \"The date the task is due.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Boolean,\n      name: \"endOfDay\",\n      description:\n        \"If the task is due at the end of the day (vs a specific time).\",\n      suggestedValue: true,\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  // To update the existing row in a sync table, return the schema with an\n  // identity matching the identityName on the sync table being updated, using\n  // the helper function coda.withIdentity().\n  schema: coda.withIdentity(TaskSchema, \"Task\"),\n  isAction: true,\n  execute: async function ([taskId, date, endOfDay = false], context) {\n    let url = \"https://api.todoist.com/rest/v2/tasks/\" + taskId;\n    let payload: any = {\n      id: taskId,\n    };\n    if (endOfDay) {\n      payload.due_date = date.toISOString().split(\"T\")[0];\n    } else {\n      payload.due_datetime = date.toISOString();\n    }\n    let response = await context.fetcher.fetch({\n      method: \"POST\",\n      url: url,\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(payload),\n    });\n    return formatTaskForSchema(response.body);\n  },\n});\n\n// #endregion\n\n\n// #region Sync tables\n\npack.addSyncTable({\n  name: \"Projects\",\n  schema: ProjectSchema,\n  identityName: \"Project\",\n  formula: {\n    name: \"SyncProjects\",\n    description: \"Sync projects\",\n    parameters: [],\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v2/projects\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results: any[] = [];\n      for (let project of response.body) {\n        results.push(formatProjectForSchema(project, true));\n      }\n      return {\n        result: results,\n      };\n    },\n    // Process row updates one at a time.\n    maxUpdateBatchSize: 1,\n    executeUpdate: async function (args, updates, context) {\n      let update = updates[0];\n      let project = update.newValue;\n      let response = await context.fetcher.fetch({\n        method: \"POST\",\n        url: `https://api.todoist.com/rest/v2/projects/${project.id}`,\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(project),\n      });\n      let updated = formatProjectForSchema(response.body, true);\n\n      return {\n        result: [updated],\n      };\n    },\n  },\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"filter\",\n        description: \"A supported filter string. See the Todoist help center.\",\n        optional: true,\n      }),\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"project\",\n        description: \"Limit tasks to a specific project.\",\n        optional: true,\n        autocomplete: async function (context, search) {\n          let url = \"https://api.todoist.com/rest/v2/projects\";\n          let response = await context.fetcher.fetch({\n            method: \"GET\",\n            url: url,\n          });\n          let projects = response.body;\n          return coda.autocompleteSearchObjects(search, projects, \"name\", \"id\");\n        },\n      }),\n    ],\n    execute: async function ([filter, project], context) {\n      let url = coda.withQueryParams(\"https://api.todoist.com/rest/v2/tasks\", {\n        filter: filter,\n        project_id: project,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results: any[] = [];\n      for (let task of response.body) {\n        results.push(formatTaskForSchema(task, true));\n      }\n      return {\n        result: results,\n      };\n    },\n    // Process row updates in batches.\n    maxUpdateBatchSize: 10,\n    executeUpdate: async function (args, updates, context) {\n      // Generate the set of commands needed to process each update.\n      let commandSets = updates.map(update => generateTaskCommands(update));\n\n      // Send all of the commands to the sync endpoint.\n      let response = await context.fetcher.fetch({\n        method: \"POST\",\n        url: \"https://api.todoist.com/sync/v9/sync\",\n        form: {\n          commands: JSON.stringify(commandSets.flat()),\n        },\n      });\n      let statuses = response.body.sync_status;\n\n      // Process the results, returning either an error or the updated task.\n      // This is done async, so the fetches can be done in parallel.\n      let jobs = updates.map(async (update, i) => {\n        let taskId = update.newValue.id;\n        let commands = commandSets[i];\n        for (let command of commands) {\n          let status = statuses[command.uuid];\n          if (status.error) {\n            return new coda.UserVisibleError(status.error);\n          }\n        }\n        // If there were no errors, fetch the updated task and return it.\n        let response = await context.fetcher.fetch({\n          method: \"GET\",\n          url: `https://api.todoist.com/rest/v2/tasks/${taskId}`,\n          cacheTtlSecs: 0,\n        });\n        return formatTaskForSchema(response.body, true);\n      });\n      let results = await Promise.all(jobs);\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// Generate a list of API commands from a Task row update.\nfunction generateTaskCommands(update: coda.GenericSyncUpdate): any[] {\n  let commands: any[] = [];\n  let { previousValue, newValue, updatedFields } = update;\n\n  // Update the task.\n  commands.push({\n    type: \"item_update\",\n    uuid: getUniqueId(),\n    args: formatTaskForAPI(newValue),\n  });\n\n  // Update the parent project, if it has changed.\n  if (updatedFields.includes(\"project\")) {\n    commands.push({\n      type: \"item_move\",\n      args: {\n        id: newValue.id,\n        project_id: newValue.project?.id,\n      },\n      uuid: getUniqueId(),\n    });\n  }\n\n  // Update the completion status, if it's changed.\n  if (previousValue.is_completed !== newValue.is_completed) {\n    commands.push({\n      type: newValue.is_completed ? \"item_complete\" : \"item_uncomplete\",\n      uuid: getUniqueId(),\n      args: {\n        id: newValue.id,\n      },\n    });\n  }\n  return commands;\n}\n\n// #endregion\n\n\n// #region Helper functions\n\nfunction extractProjectId(projectUrl: string) {\n  for (let pattern of ProjectUrlPatterns) {\n    let matches = projectUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid project URL: \" + projectUrl);\n}\n\nfunction extractTaskId(taskUrl: string) {\n  for (let pattern of TaskUrlPatterns) {\n    let matches = taskUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid task URL: \" + taskUrl);\n}\n\nfunction getUniqueId() {\n  return Math.random().toString(36);\n}\n\n// #endregion"
      }
    ]
  },
  {
    "name": "Cats",
    "description": "A Pack that generates images of cats.",
    "icon": "fontawesome/solid/cat",
    "category": "Full",
    "triggerTokens": [],
    "linkData": {
      "type": "SamplePage"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/samples/full/cats",
    "content": "This Pack allows you to fetch random cat photos using the [Cat-as-a-service API][cataas]. You can set various parameters for the cat image, such as the width and height, as well as add a text overlay. The Pack provides:\n\n- A formula for fetching a cat photo.\n- A column format that displays the text on top of a cat photo.\n- A sync table that retrieves all available cat photos.\n\n[cataas]: https://cataas.com/",
    "exampleSnippets": [
      {
        "name": "pack.ts",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"cataas.com\");\n\n// Tag parameter, shared across multiple formulas.\nconst TagParameter = coda.makeParameter({\n  type: coda.ParameterType.String,\n  name: \"tag\",\n  description: \"Only cats with this tag will be selected.\",\n  optional: true,\n  // Pull the list of tags to use for autocomplete from the API.\n  autocomplete: async function (context, search) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://cataas.com/api/tags\",\n    });\n    let tags = response.body;\n    // Convert the tags into a list of autocomplete options.\n    return coda.simpleAutocomplete(search, tags);\n  },\n});\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"size\",\n      description: \"The size of the text, in pixels.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"color\",\n      description: \"The color of the text. Any valid CSS color can be used.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"width\",\n      description: \"The width of the desired image, in pixels.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"height\",\n      description: \"The height of the desired image, in pixels.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"filter\",\n      description: \"A filter to apply to the image.\",\n      autocomplete: [\"blur\", \"mono\", \"sepia\", \"negative\", \"paint\", \"pixel\"],\n      optional: true,\n    }),\n    TagParameter,\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function (\n    [text, size, color, width, height, filter, tag],\n    context,\n    ) {\n    let url = \"https://cataas.com/cat\";\n    if (tag) {\n      url += \"/\" + tag;\n    }\n    if (text) {\n      url += \"/says/\" + encodeURIComponent(text);\n    }\n    url = coda.withQueryParams(url, {\n      size: size,\n      color: color,\n      width: width,\n      height: height,\n      filter: filter,\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Column format that displays the cell's value within a random cat image,\n// using the CatImage() formula defined above.\npack.addColumnFormat({\n  name: \"Cat Image\",\n  instructions: \"Displays the text over the image of a random cat.\",\n  formulaName: \"CatImage\",\n});\n\n// Schema for a Cat image.\nconst CatSchema = coda.makeObjectSchema({\n  properties: {\n    image: {\n      description: \"The cat image.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n    tags: {\n      description: \"The tags used to categorize this cat.\",\n      type: coda.ValueType.Array,\n      items: coda.makeSchema({ type: coda.ValueType.String }),\n    },\n    created: {\n      description: \"When the cat image was added.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.DateTime,\n    },\n    id: { type: coda.ValueType.String },\n  },\n  displayProperty: \"image\",\n  idProperty: \"id\",\n  featuredProperties: [\"tags\"],\n});\n\n// Sync table that retrieves all cat images, optionally filtered by tags.\npack.addSyncTable({\n  name: \"Cats\",\n  identityName: \"Cat\",\n  schema: CatSchema,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  formula: {\n    name: \"SyncCats\",\n    description: \"Syncs the cats.\",\n    parameters: [TagParameter],\n    execute: async function ([tag], context) {\n      let url = coda.withQueryParams(\"https://cataas.com/api/cats\", {\n        tags: tag,\n        limit: 10000,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let cats = response.body;\n      let result = [];\n      for (let cat of cats) {\n        result.push({\n          image: \"https://cataas.com/cat/\" + cat._id,\n          tags: cat.tags,\n          created: cat.createdAt,\n          id: cat._id,\n        });\n      }\n      return {\n        result: result,\n      };\n    },\n  },\n});"
      }
    ]
  },
  {
    "name": "Dungeons & Dragons",
    "description": "A Pack that uses an API to retrieve information about the game Dungeons & Dragons.",
    "icon": "fontawesome/solid/dragon",
    "category": "Full",
    "triggerTokens": [],
    "linkData": {
      "type": "SamplePage"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/samples/full/dnd",
    "content": "This Pack allows you to fetch information about spells in th game Dungeons and Dragons using the [D&D 5e API][dnd]. The Pack provides:\n\n- A formula for looking up a spell by name.\n- A column format that displays information about the spell name in the cell.\n- A sync table that retrieves all available spells.\n\n[dnd]: http://www.dnd5eapi.co/",
    "exampleSnippets": [
      {
        "name": "pack.ts",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// How many spells to fetch in each sync formula execution.\nconst BATCH_SIZE = 20;\n\n// Allow requests to the DND API.\npack.addNetworkDomain(\"dnd5eapi.co\");\n\n// Schema that defines the metadata to return for each spell. Shared by the\n// formula, column format, and sync table.\nlet SpellSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The spell name.\",\n      type: coda.ValueType.String,\n    },\n    description: {\n      description: \"A description of the spell.\",\n      type: coda.ValueType.String,\n    },\n    higher_level: {\n      description: \"A description for casting the spell at a higher level.\",\n      type: coda.ValueType.String,\n    },\n    level: {\n      description: \"The level of the spell.\",\n      type: coda.ValueType.Number,\n    },\n    range: {\n      description: \"The range of the spell.\",\n      type: coda.ValueType.String,\n    },\n    material: {\n      description: \"The material component for the spell to be cast.\",\n      type: coda.ValueType.String,\n    },\n    duration: {\n      description: \"How long the spell effect lasts.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"Instantaneous\".\n    },\n    casting_time: {\n      description: \"How long it takes for the spell to activate.\",\n      type: coda.ValueType.String,\n      // Not using the Duration value hint, since this can contain values like\n      // \"1 action\".\n    },\n    attack_type: {\n      description: \"The attack type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    damage_type: {\n      description: \"The damage type of the spell.\",\n      type: coda.ValueType.String,\n    },\n    index: {\n      description: \"A unique identifier for the spell.\",\n      type: coda.ValueType.String,\n    },\n  },\n  displayProperty: \"name\",\n  // Sync table fields.\n  idProperty: \"index\",\n  featuredProperties: [\"description\", \"level\", \"range\"],\n  // Card fields.\n  subtitleProperties: [\n    \"level\",\n    \"range\",\n    \"duration\",\n    \"damage_type\",\n  ],\n  snippetProperty: \"description\",\n});\n\n// Reformat the API response for a spell to fit the schema.\nfunction formatSpell(spell) {\n  return {\n    // Start with all of the properties in the API response.\n    ...spell,\n    description: spell.desc?.join(\"\\n\"),\n    higher_level: spell.higher_level?.join(\"\\n\"),\n    damage_type: spell.damage?.damage_type?.name,\n  };\n}\n\n// A formula that looks up a spell given a name, returning the first result.\npack.addFormula({\n  name: \"Spell\",\n  description: \"Gets information about a spell, given its name.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the spell.\",\n      suggestedValue: \"Acid Arrow\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: SpellSchema,\n  execute: async function ([name], context) {\n    // Search for spells that match the name provided.\n    let searchUrl = coda.withQueryParams(\n      \"https://www.dnd5eapi.co/api/spells/\",\n      { name: name },\n      );\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: searchUrl,\n    });\n    let results = response.body.results;\n\n    // If no spells match, throw an error.\n    if (!results?.length) {\n      throw new coda.UserVisibleError(\"Unknown spell: \" + name);\n    }\n\n    // Fetch the spell details for the first result.\n    let topResult = results.slice(0, 1);\n    let spells = await fetchSpells(context.fetcher, topResult);\n\n    // Return the spell data for the result.\n    return spells[0];\n  },\n});\n\n// A column format that displays information about the spell with the given\n// name.\npack.addColumnFormat({\n  name: \"Spell\",\n  instructions: \"Displays information about the spell with this name.\",\n  formulaName: \"Spell\",\n});\n\n// A sync table that displays all spells available in the API.\npack.addSyncTable({\n  name: \"Spells\",\n  identityName: \"Spell\",\n  schema: SpellSchema,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  formula: {\n    name: \"SyncSpells\",\n    description: \"Sync all the spells.\",\n    parameters: [],\n    execute: async function ([], context) {\n      // Get the list of all spells.\n      let listUrl = \"https://www.dnd5eapi.co/api/spells\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: listUrl,\n      });\n      let results = response.body.results;\n\n      // If there is a previous continuation, start from the index contained\n      // within, otherwise start at zero.\n      let index: number = (context.sync.continuation?.index as number) || 0;\n\n      // Get a batch of results, starting from the index determined above.\n      let batch = results.slice(index, index + BATCH_SIZE);\n\n      // Fetch the spells for the batch of results.\n      let spells = await fetchSpells(context.fetcher, batch);\n\n      // Move the index forward.\n      index += BATCH_SIZE;\n\n      // If there are more results to process, create a new continuation.\n      let continuation;\n      if (index <= results.length) {\n        continuation = {\n          index: index,\n        };\n      }\n\n      // Return the batch of spells and the next continuation, if any.\n      return {\n        result: spells,\n        continuation: continuation,\n      };\n    },\n  },\n});\n\n// Fetch a batch of spells from the API and return them formatted to match the\n// schema. This utility function is shared by the formula and sync table.\nasync function fetchSpells(fetcher: coda.Fetcher, spellResults) {\n  let requests = [];\n  for (let spellResult of spellResults) {\n    // Add on the domain.\n    let url = \"https://www.dnd5eapi.co\" + spellResult.url;\n    // Put the request in the list. Don\"t use await here, since we want them to\n    // run at the same time.\n    let request = fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    requests.push(request);\n  }\n\n  // Wait for all of the requests to finish.\n  let responses = await Promise.all(requests);\n\n  // Format the API responses and return them.\n  let spells = [];\n  for (let response of responses) {\n    spells.push(formatSpell(response.body));\n  }\n  return spells;\n}"
      }
    ]
  },
  {
    "name": "GitHub",
    "description": "A Pack that integrates with GitHub.",
    "icon": "fontawesome/brands/github",
    "category": "Full",
    "triggerTokens": [],
    "linkData": {
      "type": "SamplePage"
    },
    "exampleFooterLink": "https://coda.io/packs/build/latest/samples/full/github",
    "content": "This Pack demonstrates a lightweight integration with [GitHub][github]. There is a lot of functionality provided by the GitHub API, but this sample just provides a few features related to repositories (repos):\n\n- A formula that provides rich data about a repo given its URL.\n- A column format that automatically applies that formula to matching URLs.\n- An action formula (button) that stars a repo given its URL.\n- A sync table that pulls in all of the user's repos.\n\nThe Pack uses OAuth2 to connect to a user's GitHub account. A more extensive GitHub sample that is deployed via the CLI is available in the [`packs-examples` repo][github_example].\n\n[github]: https://github.com/\n[github_example]: https://github.com/coda/packs-examples/tree/main/examples/github",
    "exampleSnippets": [
      {
        "name": "pack.ts",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Regular expression used to parse repo URLs.\nconst RepoUrlRegex = new RegExp(\"^https://github.com/([^/]+)/([^/]+)\");\n\n// How many items to fetch per-page when making API list requests.\nconst PageSize = 50;\n\n// Allow the Pack to access the GitHub domain.\npack.addNetworkDomain(\"github.com\");\n\n// Setup per-user authentication using GitHub's OAuth2.\n// Remember to set your client ID and secret in the \"Settings\" tab.\n// See https://docs.github.com/en/developers/apps/building-oauth-apps\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  authorizationUrl: \"https://github.com/login/oauth/authorize\",\n  tokenUrl: \"https://github.com/login/oauth/access_token\",\n  tokenPrefix: \"token\",\n  scopes: [\"repo\", \"user\"],\n\n  // Determines the name of the GitHub account that was connected.\n  getConnectionName: async function (context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.github.com/user\",\n    });\n    return response.body.login;\n  },\n});\n\n// A schema that defines a repo object.\nconst RepoSchema = coda.makeObjectSchema({\n  properties: {\n    repoId: { type: coda.ValueType.Number, fromKey: \"id\" },\n    name: { type: coda.ValueType.String },\n    fullName: { type: coda.ValueType.String, fromKey: \"full_name\" },\n    description: { type: coda.ValueType.String },\n    url: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n      fromKey: \"html_url\",\n    },\n    watchers: { type: coda.ValueType.Number, fromKey: \"watchers_count\" },\n    forks: { type: coda.ValueType.Number, fromKey: \"forks_count\" },\n    stars: { type: coda.ValueType.Number, fromKey: \"stargazers_count\" },\n  },\n  displayProperty: \"name\",\n  idProperty: \"repoId\",\n  featuredProperties: [\"description\", \"watchers\", \"forks\", \"stars\"],\n});\n\n// A formula to fetch information about a repo.\npack.addFormula({\n  name: \"Repo\",\n  description: \"Get information about a repo from it's URL.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the repo.\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: RepoSchema,\n  execute: async function ([url], context) {\n    let { owner, name } = parseRepoUrl(url);\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: `https://api.github.com/repos/${owner}/${name}`,\n    });\n    let repo = response.body;\n    return repo;\n  },\n});\n\n// A column format that automatically applies the Repo() formula.\npack.addColumnFormat({\n  name: \"Repo\",\n  instructions: \"Show details about a GitHub repo, given a URL.\",\n  formulaName: \"Repo\",\n  matchers: [RepoUrlRegex],\n});\n\n// An action formula that allows a user to star a repo.\npack.addFormula({\n  name: \"Star\",\n  description: \"Add a star to a repo.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the repo.\",\n    }),\n  ],\n  resultType: coda.ValueType.Boolean,\n  isAction: true,\n  execute: async function ([url], context) {\n    let { owner, name } = parseRepoUrl(url);\n    let response = await context.fetcher.fetch({\n      method: \"PUT\",\n      url: `https://api.github.com/user/starred/${owner}/${name}`,\n    });\n    return true;\n  },\n});\n\n// A sync table that lists all of the user's repos.\npack.addSyncTable({\n  name: \"Repos\",\n  description: \"All of the repos that the user has access to.\",\n  identityName: \"Repo\",\n  schema: RepoSchema,\n  formula: {\n    name: \"SyncRepos\",\n    description: \"Sync the repos.\",\n    parameters: [],\n    execute: async function ([], context) {\n      // Get the page to start from.\n      let page = (context.sync.continuation?.page as number) || 1;\n\n      // Fetch a page of repos from the GitHub API.\n      let url = coda.withQueryParams(\"https://api.github.com/user/repos\", {\n        page: page,\n        per_page: PageSize,\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let repos = response.body;\n\n      // If there were some results, re-run this formula for the next page.\n      let continuation;\n      if (repos.length > 0) {\n        continuation = { page: page + 1 };\n      }\n\n      // Return the repos and the continuation (if any).\n      return {\n        result: repos,\n        continuation: continuation,\n      };\n    },\n  },\n});\n\n// A helper function that parses a repo URL and returns the owner and name.\nfunction parseRepoUrl(url) {\n  let match = url.match(RepoUrlRegex);\n  if (!match) {\n    throw new coda.UserVisibleError(\"Invalid repo URL: \" + url);\n  }\n  return {\n    owner: match[1],\n    name: match[2],\n  };\n}"
      }
    ]
  }
]