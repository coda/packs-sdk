[
  {
    "name": "Column formats",
    "category": "Topic",
    "triggerTokens": [
      "addColumnFormat"
    ],
    "exampleFooterLink": "https://coda.github.io/packs-sdk/reference/sdk/classes/PackDefinitionBuilder#addColumnFormat",
    "content": "A **column format** is a custom column type that you apply to any column in any Coda table. A column format tells Coda to interpret the value in a cell by executing a **formula** using that value, typically looking up data related to that value from a third-party API.\n\nFor example, the Weather pack has a column format `Current Weather`; when applied to a column, if you type a city or address into a cell in that column, that location will be used an input to a formula that fetches the current weather at that location, and the resulting object with weather info will be shown in the cell.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "",
        "code": "pack.addColumnFormat({\n  name: \"<User-visible name>\",\n  instructions: \"<Help text for the format>\",\n  formulaName: \"<Name of the formula to run>\",\n  formulaNamespace: \"Deprecated\", // Will be removed shortly\n});"
      },
      {
        "name": "Text (Reverse)",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Adds a column format to the Pack, which will display the contents of the\n// column in reverse order.\npack.addColumnFormat({\n  name: \"Reversed Text\",\n  // The formula \"Reverse()\" (defined below) will be run on the content of the\n  // column to determine it's display value.\n  formulaName: \"Reverse\",\n  formulaNamespace: \"Deprecated\", // Will be removed shortly.\n  instructions: \"Whatever text you enter into this column will be reversed.\",\n});\n\n// Adds a formula to this Pack to reverse text. It is used by the column format\n// above, but can also be used on it's own anywhere in the doc.\npack.addFormula({\n  resultType: coda.ValueType.String,\n  name: \"Reverse\",\n  description: \"Reverses text.\",\n  parameters: [\n    // Formulas used in column formats can have only one required parameter.\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"input\",\n      description: \"The text to reverse.\",\n    }),\n    // Optional parameters can't be set when run as a column format.\n    coda.makeParameter({\n      type: coda.ParameterType.Boolean,\n      name: \"byWord\",\n      description: \"Reverse the text word-by-word.\",\n      defaultValue: false,\n      optional: true,\n    }),\n  ],\n  execute: async function ([input, byWord = false]) {\n    let separator = \"\";\n    if (byWord) {\n      separator = \" \";\n    }\n    return input.split(separator).reverse().join(separator);\n  },\n});"
      },
      {
        "name": "Image (Cats)",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Column format that displays the cell's value within a random cat image,\n// using the CatImage() formula defined above.\npack.addColumnFormat({\n  name: \"Cat Image\",\n  instructions: \"Displays the text over the image of a random cat.\",\n  formulaName: \"CatImage\",\n  formulaNamespace: \"Deprecated\", // Will be removed shortly\n});\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text], context) {\n    let url = \"https://cataas.com/cat/says/\" + encodeURIComponent(text);\n    url = coda.withQueryParams(url, {\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");"
      },
      {
        "name": "Rich Data (Todoist)",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\n\n// Regular expressions that match Todoist task URLs. Used by the column format\n// and also the formula that powers it.\nconst TaskUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showTask\\\\?id=([0-9]+)\"),\n];\n\nexport const pack = coda.newPack();\n\n// Add a column format that displays a task URL as rich metadata.\npack.addColumnFormat({\n  name: \"Task\",\n  // The formula \"GetTask\" below will get run on the cell value.\n  formulaName: \"GetTask\",\n  formulaNamespace: \"Deprecated\",\n  // If the first values entered into a new column match these patterns then\n  // this column format will be automatically applied.\n  matchers: TaskUrlPatterns,\n});\n\n// A schema defining the rich metadata to be returned.\nconst TaskSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.Number,\n      required: true,\n    },\n  },\n  primary: \"name\",\n  id: \"taskId\",\n  identity: {\n    name: \"Task\",\n  },\n});\n\n// Formula that looks up rich metadata about a task given it's URL. This is used\n// by the \"Task\" column format above, but is also a regular formula that can be\n// used elsewhere.\npack.addFormula({\n  name: \"GetTask\",\n  description: \"Gets a Todoist task by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n\n  execute: async function ([url], context) {\n    let taskId = extractTaskId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v1/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    let task = response.body;\n    return {\n      name: task.content,\n      description: task.description,\n      url: task.url,\n      taskId: task.id,\n    };\n  },\n});\n\n// Helper function to extract the Task ID from the URL.\nfunction extractTaskId(taskUrl: string) {\n  for (let pattern of TaskUrlPatterns) {\n    let matches = taskUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid task URL: \" + taskUrl);\n}\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      }
    ]
  },
  {
    "name": "Authentication",
    "category": "Topic",
    "triggerTokens": [
      "setSystemAuthentication",
      "setUserAuthentication"
    ],
    "exampleFooterLink": "https://coda.github.io/packs-sdk/reference/sdk/classes/PackDefinitionBuilder#setSystemAuthentication",
    "content": "The SDK broadly divides authentication into two categories: authentication that is tied to the user of the pack vs authentication that is managed by the system, aka the pack author. In the pack definition the former is known as `defaultAuthentication` and the latter `systemConnectionAuthentication`. You will typically specify one or the other in your pack definition, or neither if your pack does not make http requests or those requests do not require authentication.\n\nDefault authentication is the most common. Specify this if each user of your pack should log in with OAuth, or have their own API key, or whatever user-specific token is necessary for the pack to be able to retrieve data that is specific to that user.\n\nUse system authentication if you as the pack author will provide the necessary tokens to successfully make http requests within your pack. An example would be if your pack returns weather forecasts and the API involved requires an API key, but individual users need not provide their own API key. You as the pack author will register an API key and provide it to Coda, and Coda will apply it to all pack requests regardless of the user.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "",
        "code": "pack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n});"
      },
      {
        "name": "OAuth2 (Todoist)",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Adds OAuth2 authentication for the Todoist API.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // OAuth2 URLs and scopes are found in the the Todoist OAuth guide:\n  // https://developer.todoist.com/guides/#oauth\n  authorizationUrl: \"https://todoist.com/oauth/authorize\",\n  tokenUrl: \"https://todoist.com/oauth/access_token\",\n  scopes: [\"data:read_write\"],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = coda.withQueryParams(\"https://api.todoist.com/sync/v8/sync\", {\n      resource_types: JSON.stringify([\"user\"]),\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.user?.full_name;\n  },\n});"
      }
    ]
  },
  {
    "name": "Dynamic sync tables",
    "category": "Topic",
    "triggerTokens": [
      "addDynamicSyncTable"
    ],
    "exampleFooterLink": "https://coda.github.io/packs-sdk/reference/sdk/classes/PackDefinitionBuilder#addDynamicSyncTable",
    "content": "Most sync tables have schemas that can be statically defined. For example, if you're writing a sync of a user's Google Calendar events, the structure of an Event from the Google Calendar API is well-known and you can write a schema for what your table should contain.\n\nIn certain cases, you may want to sync data whose structure is not known in advance and may depend on the user doing the sync. For example, Coda's Jira pack allows users to sync data from their Jira instance, but Jira lets users create arbitrary custom fields for their Issue objects. So the schema of the Issues sync table is not known in advance; it depends on the Jira account that the user is syncing from.\n\nCoda supports \"dynamic\" sync tables for cases like these. Instead of including a static schema in your sync table definition, you include a formula that returns a schema. This formula can use the fetcher to make authenticated http requests to your Pack's API so that you may retrieve any necessary info from that third-party service needed to construct an appropriate schema.\n\nTo define a dynamic schema, use the `makeDynamicSyncTable()` wrapper function. You will provide a `getSchema` formula that returns a schema definition. You'll also provide some supporting formulas like `getName`, to return a name in the UI for the table, in case even the name of the entities being synced is dynamic.\n\nThere are two subtle variants of dynamic sync tables. A sync table can be dynamic simply because the shape of the entities being synced vary based on who the current user is. For example, in the Jira example, Jira Issues are synced by hitting the same static Jira API url for Issues, but the schema of the issues returned will be different depending on the configuration of the Jira instance of the calling user.\n\nAlternatively, a sync table can be dynamic because the data source is specific to each instance of the table. If you were building a sync table to sync data from a Google Sheet, the data source would be the API url of a specific sheet. In this case, the sync table will be bound to a `dynamicUrl` that defines the data source. This url will be available to all of the formulas to implement the sync table in the sync context, as `context.sync.dynamicUrl`. To create a sync table that uses dynamic urls, you must implement the `listDynamicUrls` metadata formula in your dynamic sync table definition.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "",
        "code": "pack.addDynamicSyncTable({\n  name: \"<User-visible name for the sync table>\",\n  getName: async function (context) {\n    let datasourceUrl = context.sync!.dynamicUrl!;\n    // TODO: Fetch metdata about the datasource and return the name.\n    return \"<Datasource Name>\";\n  },\n  getSchema: async function (context) {\n    let datasourceUrl = context.sync!.dynamicUrl!;\n    // TODO: Fetch metdata about the datasource and get the list of fields.\n    let properties = {\n      // TODO: Create a property for each field.\n    };\n    let id = \"<Determine the field containing a unique ID>\";\n    let primary = \"<Determine the field containing the display value>\";\n    let featured = [\n      // TODO: Determine which fields to show in the table by default.\n    ];\n    return coda.makeSchema({\n      type: coda.ValueType.Array,\n      items: coda.makeObjectSchema({\n        type: coda.ValueType.Object,\n        identity: {\n          name: \"<User-visible name for the column containing the schema>\",\n          dynamicUrl: datasourceUrl,\n        },\n        properties: properties,\n        id: id,\n        primary: primary,\n        featured: featured,\n      }),\n    });\n  },\n  getDisplayUrl: async function (context) {\n    return context.sync!.dynamicUrl!;\n  },\n  formula: {\n    name: \"<Name of the sync formula, not show to the user>\",\n    description: \"<Help text for the sync formula, not show to the user>\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"<User-visible name of parameter>\",\n        description: \"<Help text for the parameter>\",\n      }),\n      // Add more parameters here and in the array below.\n    ],\n    execute: async function ([param], context) {\n      let datasourceUrl = context.sync!.dynamicUrl!;\n      let url = \"<URL to pull data from>\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let items = response.body.items;\n      // Adjust the items to fit the schema if required.\n      return {\n        result: items,\n      }\n    },\n  },\n});"
      }
    ]
  },
  {
    "name": "Formulas",
    "category": "Topic",
    "triggerTokens": [
      "addFormula"
    ],
    "exampleFooterLink": "https://coda.github.io/packs-sdk/reference/sdk/classes/PackDefinitionBuilder#addFormula",
    "content": "A **formula (including a button)** is a JavaScript function that will be exposed as a Coda formula, that you can use anywhere in a Coda doc that you can use any normal formula. Formulas take basic Coda types as input, like strings, numbers, dates, booleans, and arrays of these types, and return any of these types or objects whose properties are any of these types. Buttons are just a flavor of a formula with the flag `isAction` activated.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "",
        "code": "pack.addFormula({\n  name: \"<User-visible name of formula>\",\n  description: \"<Help text for the formula>\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"<User-visible name of parameter>\",\n      description: \"<Help text for the parameter>\",\n    }),\n    // Add more parameters here and in the array below.\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([param], context) {\n    return \"Hello \" + param;\n  },\n});"
      },
      {
        "name": "Image (Cats)",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"filter\",\n      description: \"A filter to apply to the image.\",\n      autocomplete: [\"blur\", \"mono\", \"sepia\", \"negative\", \"paint\", \"pixel\"],\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text, filter], context) {\n    let url = \"https://cataas.com/cat\";\n    if (text) {\n      url += \"/says/\" + encodeURIComponent(text);\n    }\n    url = coda.withQueryParams(url, {\n      filter: filter,\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");"
      },
      {
        "name": "Rich Data (Todoist)",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the rich metadata to be returned about each task.\nconst TaskSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.Number,\n      required: true,\n    },\n  },\n  primary: \"name\",\n  id: \"taskId\",\n  identity: {\n    name: \"Task\",\n  },\n});\n\n// Formula that looks up rich metadata about a task given it's URL.\npack.addFormula({\n  name: \"GetTaskById\",\n  description: \"Gets a Todoist task by ID\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"taskId\",\n      description: \"The ID of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n\n  execute: async function ([taskId], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v1/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    let task = response.body;\n    return {\n      name: task.content,\n      description: task.description,\n      url: task.url,\n      taskId: task.id,\n    };\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      }
    ]
  },
  {
    "name": "Sync tables",
    "category": "Topic",
    "triggerTokens": [
      "addSyncTable"
    ],
    "exampleFooterLink": "https://coda.github.io/packs-sdk/reference/sdk/classes/PackDefinitionBuilder#addSyncTable",
    "content": "A **sync table** is how to bring structured data from a third-party into Coda. A sync table is a table that you can add to a Coda doc that gets its rows from a third-party data source, that can be refreshed regularly to pull in new or updated data. A sync table is powered by a **formula** that takes parameters that represent sync options and returns an array of objects representing row data. A sync table also includes a schema describing the structure of the returned objects.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "",
        "code": "const MySchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    property1: {type: coda.ValueType.Number},\n    property2: {type: coda.ValueType.String},\n    // Add more properties here.\n  },\n  id: \"property1\", // Which property above is a unique ID.\n  primary: \"property2\", // Which property above to display by default.\n  identity: {\n    name: \"<User-visible name for the column containing the schema>\",\n  },\n});\n\npack.addSyncTable({\n  name: \"<User-visible name for the sync table>\",\n  identityName: \"<User-visible name for the column containing the schema>\",\n  schema: MySchema,\n  formula: {\n    name: \"<Name of the sync formula, not show to the user>\",\n    description: \"<Help text for the sync formula, not show to the user>\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"<User-visible name of parameter>\",\n        description: \"<Help text for the parameter>\",\n      }),\n      // Add more parameters here and in the array below.\n    ],\n    execute: async function ([param], context) {\n      let url = \"<URL to pull data from>\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let items = response.body.items;\n      // Adjust the items to fit the schema if required.\n      return {\n        result: items,\n      }\n    },\n  },\n});"
      },
      {
        "name": "Cats",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Schema for a Cat image.\nconst CatSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    image: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n    tags: {\n      type: coda.ValueType.Array,\n      items: { type: coda.ValueType.String },\n    },\n    created: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.DateTime,\n    },\n    id: { type: coda.ValueType.String },\n  },\n  primary: \"image\",\n  id: \"id\",\n  featured: [\"tags\"],\n  identity: {\n    name: \"Cat\",\n  },\n});\n\n// Sync table that retrieves all cat images, optionally filtered by tags.\npack.addSyncTable({\n  name: \"Cats\",\n  identityName: \"Cat\",\n  schema: CatSchema,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  formula: {\n    name: \"SyncCats\",\n    description: \"Syncs the cats.\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"tag\",\n        description: \"Only cats with this tag will be selected.\",\n        optional: true,\n        // Pull the list of tags to use for autocomplete from the API.\n        autocomplete: async function (context, search) {\n          let response = await context.fetcher.fetch({\n            method: \"GET\",\n            url: \"https://cataas.com/api/tags\",\n          });\n          let tags = response.body;\n          // Convert the tags into a list of autocomplete options.\n          return coda.simpleAutocomplete(search, tags);\n        },\n      }),\n    ],\n    execute: async function ([tag], context) {\n      let url = coda.withQueryParams(\"https://cataas.com/api/cats\", {\n        tags: tag\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let cats = response.body;\n      let result: any = [];\n      for (let cat of cats) {\n        result.push({\n          image: \"https://cataas.com/cat/\" + cat.id,\n          tags: cat.tags,\n          created: cat.created_at,\n          id: cat.id,\n        });\n      }\n      return {\n        result: result,\n      };\n    },\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");"
      },
      {
        "name": "Todoist",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the data in the sync table.\nconst TaskSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.Number,\n      required: true,\n    },\n  },\n  primary: \"name\",\n  id: \"taskId\",\n  featured: [\"description\", \"url\"],\n  identity: {\n    name: \"Task\",\n  },\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [],\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v1/tasks\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results: any[] = [];\n      for (let task of response.body) {\n        results.push({\n          name: task.content,\n          description: task.description,\n          url: task.url,\n          taskId: task.id,\n        });\n      }\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      }
    ]
  },
  {
    "name": "Fetcher",
    "category": "Topic",
    "triggerTokens": [
      "fetch"
    ],
    "exampleFooterLink": "https://coda.github.io/packs-sdk/reference/sdk/interfaces/Fetcher",
    "content": "Communicating with an API or external server is done through the `Fetcher`, a custom interface for making HTTP requests. The fetcher is made available through the `context` object passed in to formulas. The fetcher can only send requests to URLs that have have a domain name that's been registered using `addNetworkDomain`. The fetcher runs asynchronously, and is typically run within an `async` function that will `await` the result.",
    "exampleSnippets": [
      {
        "name": "Template (GET)",
        "content": "",
        "code": "let response = await context.fetcher.fetch({\n  method: \"GET\",\n  url: \"<The URL to fetch>\",\n  headers: {\n    \"<HeaderName>\": \"<HeaderValue>\",\n    // Add more headers as needed.\n  },\n});\nlet data = response.body;"
      },
      {
        "name": "Template (POST)",
        "content": "",
        "code": "let payload = {\n  // Whatever JSON structure the API expects.\n};\nlet response = await context.fetcher.fetch({\n  method: \"POST\",\n  url: \"<The URL to send the request to>\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    // Add more headers as needed.\n  },\n  body: JSON.stringify(payload),\n});\nlet data = response.body;"
      },
      {
        "name": "JSON Array (Bacon Ipsum)",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// When using the fetcher, this is the domain of the API that your pack makes\n// fetcher requests to.\npack.addNetworkDomain(\"baconipsum.com\");\n\n// This line adds a new formula to this Pack.\npack.addFormula({\n  name: \"BaconIpsum\",\n  description: \"Returns meat-themed lorem ipsum copy.\",\n  parameters: [], // No parameters required.\n  resultType: coda.ValueType.String,\n\n  // This function is declared async to that is can wait for the fetcher to\n  // complete. The context parameter provides access to the fetcher.\n  execute: async function ([], context) {\n    let url = \"https://baconipsum.com/api/?type=meat-and-filler\";\n\n    // The fetcher's fetch method makes the request. The await keyword is used\n    // to wait for the API's response before continuing on through the code.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url\n    });\n\n    // The API returns an array of strings, which is automatically parsed by\n    // the fetcher into a JavaScript object.\n    let paragraphs = response.body;\n\n    // Return the paragraphs separated by a blank line.\n    return paragraphs.join(\"\\n\\n\");\n  },\n});"
      }
    ]
  },
  {
    "name": "Hello World",
    "category": "Full",
    "triggerTokens": [],
    "exampleFooterLink": "https://coda.io/@coda/make-a-pack-private-alpha/hello-world-16",
    "content": "This is an example which creates a single formula called Hello, that takes in a string called name and returns “Hello, name !“.",
    "exampleSnippets": [
      {
        "name": "Hello World",
        "content": "",
        "code": "/*\nStart making Packs!\nTry out the hello world sample below to create your first build.\n*/\n\n// This import statement gives you access to all parts of the Coda Packs SDK.\nimport * as coda from \"@codahq/packs-sdk\";\n\n// This line creates your new Pack.\nexport const pack = coda.newPack();\n\n// Here, we add a new formula to this Pack.\npack.addFormula({\n  // This is the name that will be called in the formula builder.\n  // Remember, your formula name cannot have spaces in it.\n  name: \"Hello\",\n  description: \"A Hello World example.\",\n\n  // If your formula requires one or more inputs, you’ll define them here.\n  // Here, we're creating a string input called “name”.\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name you would like to say hello to.\",\n    }),\n  ],\n\n  // The resultType defines what will be returned in your Coda doc. Here, we're\n  // returning a simple text string.\n  resultType: coda.ValueType.String,\n\n  // Everything inside this execute statement will happen anytime your Coda\n  // formula is called in a doc. An array of all user inputs is always the 1st\n  // parameter.\n  execute: async function ([name]) {\n    return \"Hello \" + name + \"!\";\n  },\n});"
      }
    ]
  },
  {
    "name": "Daylight",
    "category": "Full",
    "triggerTokens": [],
    "exampleFooterLink": "https://coda.io/@coda/make-a-pack-private-alpha/daylight-29",
    "content": "This Pack provides a `Daylight` formula that determines the daylight, sunrise,\n and sunset at a given location using the [Sunrise Sunset API][api]. It accepts\n a latitude, longitude, an optional date and returns a rich object (schema) as\n a result. It uses the `Fetcher` to pull data from an external API.\n\n [api]: https://sunrise-sunset.org/api",
    "exampleSnippets": [
      {
        "name": "Daylight",
        "content": "",
        "code": "/**\n * This Pack provides a \"Daylight\" formula that determines the daylight,\n * sunrise, and sunset at a given location using the Sunrise Sunset API.\n * The results are returns as a rich object.\n * @see {@link https://sunrise-sunset.org/api|Sunrise Sunset API}\n */\n\n// This import statement provides access to all parts of the Coda Packs SDK.\nimport * as coda from \"@codahq/packs-sdk\";\n\n// This line creates the new Pack.\nexport const pack = coda.newPack();\n\n// The domain that the Pack will match fetcher requests to.\npack.addNetworkDomain(\"sunrise-sunset.org\");\n\n// Define a schema that will be used to bundle up the multiple pieces of data\n// our formula will return. In the Coda doc this will be displayed as a chip.\nconst SunSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    // The values we return are simple strings, but we use the codaType field to\n    // to tell Coda to interpret them as durations and time values.\n    daylight: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Duration,\n    },\n    sunriseUTC: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Time,\n    },\n    sunsetUTC: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Time,\n    },\n  },\n  // Which of the properties defined above will be shown inside the chip.\n  primary: \"daylight\",\n});\n\n// Add a \"Daylight\" formula to the Pack.\npack.addFormula({\n  name: \"Daylight\",\n  description: \"Returns the sunrise and sunset for a given location.\",\n\n  // This formula takes two required numeric inputs (the latitude and longitude)\n  // and one optional date.\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"lat\",\n      description: \"The latitude to use.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"lng\",\n      description: \"The longitude to use.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"date\",\n      description: \"The date to use. Defaults to today.\",\n      // This date parameter is an optional input.\n      optional: true,\n    }),\n  ],\n\n  // In this formula, we're returning an object with multiple properties.\n  resultType: coda.ValueType.Object,\n\n  // This object will be defined according to the schema written above.\n  schema: SunSchema,\n\n  // Everything inside this execute statement will happen anytime the Coda\n  // formula is called in a doc. An array of all user inputs is passed as the\n  // first parameter. The context object is always the second parameter and is\n  // used for fetching data.\n  execute: async function ([lat, lng, date], context) {\n    // Default to today if no date is provided.\n    let lookupDate = date || new Date();\n\n    // Format date to yyyy-mm-dd format as required by this API.\n    let formattedDate = lookupDate.toISOString().split(\"T\")[0];\n\n    // Create the URL to fetch, using the helper function coda.withQueryParams\n    // to add on query parameters (ex: \"?lat=40.123...\").\n    let url = coda.withQueryParams(\"https://api.sunrise-sunset.org/json\", {\n      lat: lat,\n      lng: lng,\n      date: formattedDate\n    });\n\n    // Fetch the URL and get the response.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url\n    });\n\n    // The JSON returned by the API is parsed automatically and available in\n    // `response.body`. Here we pull out the content in the \"results\" key.\n    let results = response.body.results;\n\n    // Re-format the day_length string to [h] hrs [m] mins [s] secs to work as a\n    // duration.\n    let hours = results.day_length.split(\":\")[0];\n    let mins = results.day_length.split(\":\")[1];\n    let secs = results.day_length.split(\":\")[2];\n\n    let daylight = `${hours} hrs ${mins} mins ${secs} secs`;\n\n    // Return the final object. The keys here must match with the properties\n    // defined above in the schema.\n    return {\n      daylight: daylight,\n      sunriseUTC: response.body.results.sunrise,\n      sunsetUTC: response.body.results.sunset,\n    };\n  },\n});"
      }
    ]
  },
  {
    "name": "Number Array",
    "category": "Full",
    "triggerTokens": [],
    "exampleFooterLink": "https://coda.io/@coda/make-a-pack-private-alpha/number-array-27",
    "content": "This is an example which creates two formulas that each take in an array of numbers and return the greatest common denominator and least common multiple.",
    "exampleSnippets": [
      {
        "name": "Number Array",
        "content": "",
        "code": "// This import statement gives you access to all parts of the Coda Packs SDK.\nimport * as coda from \"@codahq/packs-sdk\";\n\n// This import statement gives you access to all parts of the Coda Packs SDK.\nexport const pack = coda.newPack();\n\n// We'll use an array of numbers in *both* formulas.\nconst numberArray = coda.makeParameter({\n  type: coda.ParameterType.NumberArray,\n  name: \"Numbers\",\n  description: \"the numbers you want to calculate\",\n});\n\n// We'll also use this helper function that finds the gcd of two numbers in\n// both formulas.\nfunction gcd(a, b) {\n  if (a === 0) {\n    return b;\n  }\n  return gcd(b % a, a);\n}\n\n// This line adds a new formula.\npack.addFormula({\n  // This is the name that will be called in the formula builder. Remember, your\n  // formula name cannot have spaces in it.\n  name: \"GCD\",\n  description: \"Returns the greatest common denominator for an array\",\n\n  // The needed array of numbers has already been defined above.\n  parameters: [numberArray],\n\n  // In this formula, we're returning a number in the Coda doc.\n  resultType: coda.ValueType.Number,\n\n  // Everything inside this execute statement will happen anytime your Coda\n  // function is called in a doc. An array of all user inputs is always the 1st\n  // parameter.\n  execute: async function ([numberArray]) {\n    let gcdResult = numberArray[0];\n\n    for (let i = 1; i < numberArray.length; i++) {\n      gcdResult = gcd(numberArray[i], gcdResult);\n\n      if (gcdResult === 1) {\n        return 1;\n      }\n    }\n    return gcdResult;\n  },\n});\n\n// Now, we'll define and add the second formula to the pack.\npack.addFormula({\n  name: \"LCM\",\n  description: \"Returns the least common multiple for an array\",\n  parameters: [numberArray],\n  resultType: coda.ValueType.Number,\n  execute: async function ([numberArray]) {\n    let lcmResult = numberArray[0];\n\n    for (let i = 1; i < numberArray.length; i++) {\n      lcmResult = (numberArray[i] * lcmResult) / gcd(numberArray[i], lcmResult);\n    }\n\n    return lcmResult;\n  },\n});"
      }
    ]
  },
  {
    "name": "Todoist",
    "category": "Full",
    "triggerTokens": [],
    "exampleFooterLink": "https://coda.github.io/packs-sdk/samples/full/todoist",
    "content": "This Pack provides an integration with the task tracking app [Todoist][todoist]. It uses a variety of building blocks to allow users to work with their projects and tasks, including:\n\n- Formulas that provide rich data about an item given its URL.\n- Column formats that automatically apply those formulas to matching URLs.\n- Action formulas that create and update items, for use in button and automations.\n- Sync tables for pulling in all of the user's items.\n\nThe Pack uses OAuth2 to connect to a user's Todoist account, which you can create for free.\n\n[todoist]: https://todoist.com/",
    "exampleSnippets": [
      {
        "name": "pack.ts",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\n\n\n// Constants.\n\nconst ProjectUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/project/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showProject\\\\?id=([0-9]+)\"),\n];\n\nconst TaskUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showTask\\\\?id=([0-9]+)\"),\n];\n\n\n// Pack setup.\n\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"todoist.com\");\n\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // OAuth2 URLs and scopes are found in the the Todoist OAuth guide:\n  // https://developer.todoist.com/guides/#oauth\n  authorizationUrl: \"https://todoist.com/oauth/authorize\",\n  tokenUrl: \"https://todoist.com/oauth/access_token\",\n  scopes: [\"data:read_write\"],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = coda.withQueryParams(\"https://api.todoist.com/sync/v8/sync\", {\n      resource_types: JSON.stringify([\"user\"]),\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.user?.full_name;\n  },\n});\n\n// Schemas\n\n// A reference to a synced Project. Usually you can use\n// `coda.makeReferenceSchemaFromObjectSchema` to generate these from the primary\n// schema, but that doesn't work in this case since a Project itself can contain\n// a reference to a parent project.\nconst ProjectReferenceSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  codaType: coda.ValueHintType.Reference,\n  properties: {\n    name: {type: coda.ValueType.String, required: true},\n    projectId: {type: coda.ValueType.Number, required: true},\n  },\n  primary: \"name\",\n  id: \"projectId\",\n  identity: {\n    name: \"Project\",\n  },\n});\n\nconst ProjectSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  codaType: coda.ValueHintType.Reference,\n  properties: {\n    name: {\n      description: \"The name of the project.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    url: {\n      description: \"A link to the project in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    shared: {\n      description: \"Is the project is shared.\",\n      type: coda.ValueType.Boolean,\n    },\n    favorite: {\n      description: \"Is the project a favorite.\",\n      type: coda.ValueType.Boolean,\n    },\n    projectId: {\n      description: \"The ID of the project.\",\n      type: coda.ValueType.Number,\n      required: true,\n    },\n    parentProjectId: {\n      description: \"For sub-projects, the ID of the parent project.\",\n      type: coda.ValueType.Number,\n    },\n    // Add a reference to the sync'ed row of the parent project.\n    // References only work in sync tables.\n    parentProject: ProjectReferenceSchema,\n  },\n  primary: \"name\",\n  id: \"projectId\",\n  featured: [\"url\"],\n  identity: {\n    name: \"Project\",\n  },\n});\n\n// A reference to a synced Task. Usually you can use\n// `coda.makeReferenceSchemaFromObjectSchema` to generate these from the primary\n// schema, but that doesn't work in this case since a Project itself can contain\n// a reference to a parent project.\nconst TaskReferenceSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  codaType: coda.ValueHintType.Reference,\n  properties: {\n    name: {type: coda.ValueType.String, required: true},\n    taskId: {type: coda.ValueType.Number, required: true},\n  },\n  primary: \"name\",\n  id: \"taskId\",\n  identity: {\n    name: \"Task\",\n  },\n});\n\nconst TaskSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url\n    },\n    order: {\n      description: \"The position of the task in the project or parent task.\",\n      type: coda.ValueType.Number,\n    },\n    priority: {\n      description: \"The priority of the task.\",\n      type: coda.ValueType.String,\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.Number,\n      required: true,\n    },\n    projectId: {\n      description: \"The ID of the project that the task belongs to.\",\n      type: coda.ValueType.Number,\n    },\n    parentTaskId: {\n      description: \"For sub-tasks, the ID of the parent task it belongs to.\",\n      type: coda.ValueType.Number,\n    },\n    // A reference to the sync'ed row of the project.\n    // References only work in sync tables.\n    project: ProjectReferenceSchema,\n    // Add a reference to the sync'ed row of the parent task.\n    // References only work in sync tables.\n    parentTask: TaskReferenceSchema,\n  },\n  primary: \"name\",\n  id: \"taskId\",\n  featured: [\"project\", \"url\"],\n  identity: {\n    name: \"Task\",\n  },\n});\n\n/**\n * Convert a Project API response to a Project schema.\n */\nfunction toProject(project: any, withReferences=false) {\n  let result: any = {\n    name: project.name,\n    projectId: project.id,\n    url: project.url,\n    shared: project.shared,\n    favorite: project.favorite,\n    parentProjectId: project.parent_id,\n  };\n  if (withReferences && project.parent_id) {\n    result.parentProject = {\n      projectId: project.parent_id,\n      name: \"Not found\",  // If sync'ed, the real name will be shown instead.\n    };\n  }\n  return result;\n}\n\n/**\n * Convert a Task API response to a Task schema.\n */\nfunction toTask(task: any, withReferences=false) {\n  let result: any = {\n    name: task.content,\n    description: task.description,\n    url: task.url,\n    order: task.order,\n    priority: task.priority,\n    taskId: task.id,\n    projectId: task.project_id,\n    parentTaskId: task.parent_id,\n  };\n  if (withReferences) {\n    // Add a reference to the corresponding row in the Projects sync table.\n    result.project = {\n      projectId: task.project_id,\n      name: \"Not found\",  // If sync'ed, the real name will be shown instead.\n    };\n    if (task.parent_id) {\n      // Add a reference to the corresponding row in the Tasks sync table.\n      result.parentTask = {\n        taskId: task.parent_id,\n        name: \"Not found\",  // If sync'ed, the real name will be shown instead.\n      };\n    }\n  }\n  return result;\n}\n\n\n// Formulas (read-only).\n\npack.addFormula({\n  name: \"GetProject\",\n  description: \"Gets a Todoist project by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the project\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: ProjectSchema,\n\n  execute: async function ([url], context) {\n    let projectId = extractProjectId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v1/projects/\" + projectId,\n      method: \"GET\",\n    });\n    return toProject(response.body);\n  },\n});\n\npack.addFormula({\n  name: \"GetTask\",\n  description: \"Gets a Todoist task by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n\n  execute: async function ([url], context) {\n    let taskId = extractTaskId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v1/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    return toTask(response.body);\n  },\n});\n\n\n// Column Formats.\n\npack.addColumnFormat({\n  name: \"Project\",\n  formulaName: \"GetProject\",\n  formulaNamespace: \"Deprecated\",\n  matchers: ProjectUrlPatterns,\n});\n\npack.addColumnFormat({\n  name: \"Task\",\n  formulaName: \"GetTask\",\n  formulaNamespace: \"Deprecated\",\n  matchers: TaskUrlPatterns,\n});\n\n\n// Action formulas (buttons/automations).\n\npack.addFormula({\n  name: \"AddProject\",\n  description: \"Add a new Todoist project\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the new project\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n\n  execute: async function ([name], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v1/projects\",\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        name: name,\n      }),\n    });\n    return response.body.url;\n  },\n});\n\npack.addFormula({\n  name: \"AddTask\",\n  description: \"Add a new task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the task.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"projectId\",\n      description: \"The ID of the project to add it to. If blank, \" +\n          \"it will be added to the user's Inbox.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n\n  execute: async function ([name, projectId], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v1/tasks\",\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        content: name,\n        project_id: projectId,\n      }),\n    });\n    return response.body.url;\n  },\n});\n\npack.addFormula({\n  name: \"UpdateTask\",\n  description: \"Updates the name of a task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"taskId\",\n      description: \"The ID of the task to update.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The new name of the task.\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n  isAction: true,\n\n  execute: async function ([taskId, name], context) {\n    let url = \"https://api.todoist.com/rest/v1/tasks/\" + taskId;\n    await context.fetcher.fetch({\n      url: url,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        content: name,\n      }),\n    });\n    // Get the updated Task and return it, which will update the row in the sync\n    // table.\n    let response = await context.fetcher.fetch({\n      url: url,\n      method: \"GET\",\n      cacheTtlSecs: 0,  // Ensure we are getting the latest data.\n    });\n    return toTask(response.body);\n  },\n});\n\npack.addFormula({\n  name: \"MarkAsComplete\",\n  description: \"Mark a task as completed.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"taskId\",\n      description: \"The ID of the task to be marked as complete.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n\n  execute: async function ([taskId], context) {\n    let url = \"https://api.todoist.com/rest/v1/tasks/\" + taskId + \"/close\";\n    await context.fetcher.fetch({\n      method: \"POST\",\n      url: url,\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n    return \"OK\";\n  },\n});\n\n\n// Sync tables.\n\npack.addSyncTable({\n  name: \"Projects\",\n  schema: ProjectSchema,\n  identityName: \"Project\",\n  formula: {\n    name: \"SyncProjects\",\n    description: \"Sync projects\",\n    parameters: [],\n\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v1/projects\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results: any[] = [];\n      for (let project of response.body) {\n        results.push(toProject(project, true));\n      }\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [],\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v1/tasks\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results: any[] = [];\n      for (let task of response.body) {\n        results.push(toTask(task, true));\n      }\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n\n// Helper functions.\n\nfunction extractProjectId(projectUrl: string) {\n  for (let pattern of ProjectUrlPatterns) {\n    let matches = projectUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid project URL: \" + projectUrl);\n}\n\nfunction extractTaskId(taskUrl: string) {\n  for (let pattern of TaskUrlPatterns) {\n    let matches = taskUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid task URL: \" + taskUrl);\n}"
      }
    ]
  },
  {
    "name": "Cats",
    "category": "Full",
    "triggerTokens": [],
    "exampleFooterLink": "https://coda.github.io/packs-sdk/samples/full/cats",
    "content": "This Pack provides allows you to fetch random cat photos using the [Cat-as-a-service API][cataas]. You can set various parameters for the cat image, such as the width and height, as well as add a text overlay. The Pack provides:\n\n- A formula for fetching a cat photo.\n- A column format that displays the text on top of a cat photo.\n- A sync table that retrieves all available cat photos.\n\n[cataas]: https://cataas.com/",
    "exampleSnippets": [
      {
        "name": "pack.ts",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"cataas.com\");\n\n// Tag parameter, shared across multiple formulas.\nconst TagParameter = coda.makeParameter({\n  type: coda.ParameterType.String,\n  name: \"tag\",\n  description: \"Only cats with this tag will be selected.\",\n  optional: true,\n  // Pull the list of tags to use for autocomplete from the API.\n  autocomplete: async function (context, search) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://cataas.com/api/tags\",\n    });\n    let tags = response.body;\n    // Convert the tags into a list of autocomplete options.\n    return coda.simpleAutocomplete(search, tags);\n  },\n});\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"size\",\n      description: \"The size of the text, in pixels.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"color\",\n      description: \"The color of the text. Any valid CSS color can be used.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"width\",\n      description: \"The width of the desired image, in pixels.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"height\",\n      description: \"The height of the desired image, in pixels.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"filter\",\n      description: \"A filter to apply to the image.\",\n      autocomplete: [\"blur\", \"mono\", \"sepia\", \"negative\", \"paint\", \"pixel\"],\n      optional: true,\n    }),\n    TagParameter,\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text, size, color, width, height, filter, tag],\n    context) {\n    let url = \"https://cataas.com/cat\";\n    if (tag) {\n      url += \"/\" + tag;\n    }\n    if (text) {\n      url += \"/says/\" + encodeURIComponent(text);\n    }\n    url = coda.withQueryParams(url, {\n      size: size,\n      color: color,\n      width: width,\n      height: height,\n      filter: filter,\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Column format that displays the cell's value within a random cat image,\n// using the CatImage() formula defined above.\npack.addColumnFormat({\n  name: \"Cat Image\",\n  instructions: \"Displays the text over the image of a random cat.\",\n  formulaName: \"CatImage\",\n  formulaNamespace: \"Deprecated\", // Will be removed shortly\n});\n\n// Schema for a Cat image.\nconst CatSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    image: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n    tags: {\n      type: coda.ValueType.Array,\n      items: { type: coda.ValueType.String },\n    },\n    created: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.DateTime,\n    },\n    id: { type: coda.ValueType.String },\n  },\n  primary: \"image\",\n  id: \"id\",\n  featured: [\"tags\"],\n  identity: {\n    name: \"Cat\",\n  },\n});\n\n// Sync table that retrieves all cat images, optionally filtered by tags.\npack.addSyncTable({\n  name: \"Cats\",\n  identityName: \"Cat\",\n  schema: CatSchema,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  formula: {\n    name: \"SyncCats\",\n    description: \"Syncs the cats.\",\n    parameters: [\n      TagParameter,\n    ],\n    execute: async function ([tag], context) {\n      let url = coda.withQueryParams(\"https://cataas.com/api/cats\", {\n        tags: tag\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let cats = response.body;\n      let result: any = [];\n      for (let cat of cats) {\n        result.push({\n          image: \"https://cataas.com/cat/\" + cat.id,\n          tags: cat.tags,\n          created: cat.created_at,\n          id: cat.id,\n        });\n      }\n      return {\n        result: result,\n      };\n    },\n  },\n});"
      }
    ]
  }
]