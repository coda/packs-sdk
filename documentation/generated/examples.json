[
  {
    "name": "Column formats",
    "category": "Topic",
    "triggerTokens": [
      "addColumnFormat"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/blocks/column-formats"
    },
    "exampleFooterLink": "https://coda.github.io/packs-sdk/guides/blocks/column-formats",
    "learnMoreLink": "/guides/blocks/column-formats",
    "content": "A **column format** is a custom column type that you apply to any column in any Coda table. A column format tells Coda to interpret the value in a cell by executing a **formula** using that value, typically looking up data related to that value from an external API.\n\nFor example, the Weather pack has a column format `Current Weather`; when applied to a column, if you type a city or address into a cell in that column, that location will be used an input to a formula that fetches the current weather at that location, and the resulting object with weather info will be shown in the cell.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "The basic structure of a column format.",
        "code": "pack.addColumnFormat({\n  name: \"<User-visible name>\",\n  instructions: \"<Help text for the format>\",\n  formulaName: \"<Name of the formula to run>\",\n  formulaNamespace: \"Deprecated\", // Will be removed shortly\n});"
      },
      {
        "name": "Text (Reverse)",
        "content": "A column format that formats text. This sample displays the text in the cell in reverse.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Adds a column format to the Pack, which will display the contents of the\n// column in reverse order.\npack.addColumnFormat({\n  name: \"Reversed Text\",\n  // The formula \"Reverse()\" (defined below) will be run on the content of the\n  // column to determine it's display value.\n  formulaName: \"Reverse\",\n  formulaNamespace: \"Deprecated\", // Will be removed shortly.\n  instructions: \"Whatever text you enter into this column will be reversed.\",\n});\n\n// Adds a formula to this Pack to reverse text. It is used by the column format\n// above, but can also be used on it's own anywhere in the doc.\npack.addFormula({\n  resultType: coda.ValueType.String,\n  name: \"Reverse\",\n  description: \"Reverses text.\",\n  parameters: [\n    // Formulas used in column formats can have only one required parameter.\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"input\",\n      description: \"The text to reverse.\",\n    }),\n    // Optional parameters can't be set when run as a column format.\n    coda.makeParameter({\n      type: coda.ParameterType.Boolean,\n      name: \"byWord\",\n      description: \"Reverse the text word-by-word.\",\n      defaultValue: false,\n      optional: true,\n    }),\n  ],\n  execute: async function ([input, byWord = false]) {\n    let separator = \"\";\n    if (byWord) {\n      separator = \" \";\n    }\n    return input.split(separator).reverse().join(separator);\n  },\n});"
      },
      {
        "name": "Text (Roman Numeral)",
        "content": "A column format that formats a number as text. This sample displays the number in the cell as a Roman numeral.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Adds a column format to the Pack, which will display the contents of the\n// column as Roman numerals.\npack.addColumnFormat({\n  name: \"Roman Numeral\",\n  instructions: \"Displays the number as a Roman numeral.\",\n  formulaName: \"RomanNumeral\",\n  formulaNamespace: \"Deprecated\", // Will be removed shortly\n});\n\n// Adds a formula to this Pack to convert a number to a Roman numeral. It is\n// used by the column format above, but can also be used on it's own anywhere in\n// the doc.\npack.addFormula({\n  name: \"RomanNumeral\",\n  description: \"Converts a number to the equivalent Roman numeral.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"value\",\n      description: \"The number to convert.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([value], context) {\n    let pairs = Object.entries(NumberMapping);\n    // Sort the pairs by the number, largest to smallest.\n    pairs.sort((a, b) => b[1] - a[1]);\n    let result = \"\";\n    for (let [roman, num] of pairs) {\n      while (value >= num) {\n        result += roman;\n        value -= num;\n      }\n    }\n    return result;\n  },\n});\n\nconst NumberMapping = {\n  I: 1, IV: 4, V: 5, IX: 9, X: 10, XL: 40, L: 50, XC: 90, C: 100, CD: 400,\n  D: 500, CM: 900, M: 1000,\n};"
      },
      {
        "name": "Text (Progress Bar)",
        "content": "A column format that formats a number as graphic. This sample displays the number in the cell as a progress bar.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Adds a column format to the Pack, which will display the contents of the\n// column as a progress bar.\npack.addColumnFormat({\n  name: \"Progress Bar\",\n  instructions: \"Draws a progress bar with the given percentage.\",\n  formulaName: \"ProgressBar\",\n  formulaNamespace: \"Deprecated\", // Will be removed shortly\n});\n\n// Adds a formula to this Pack to draw a number as a progress bar. It is used by\n// the column format above, but can also be used on it's own anywhere in the\n// doc.\npack.addFormula({\n  name: \"ProgressBar\",\n  description: \"Draws a progress bar.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"percentage\",\n      description: \"The percentage complete, as a number between 0 and 1.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([percentage], context) {\n    if (percentage < 0 || percentage > 1) {\n      throw new coda.UserVisibleError(\"Percentage must be between 0 and 1.\")\n    }\n    let chars = Math.floor(percentage * 10);\n    return \"⬛\".repeat(chars) + \"⬜\".repeat(10 - chars);\n  },\n});"
      },
      {
        "name": "Image (Cats)",
        "content": "A column format that formats text as an image. This sample displays the text in the cell as an overlay on a random image of a cat.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Column format that displays the cell's value within a random cat image,\n// using the CatImage() formula defined above.\npack.addColumnFormat({\n  name: \"Cat Image\",\n  instructions: \"Displays the text over the image of a random cat.\",\n  formulaName: \"CatImage\",\n  formulaNamespace: \"Deprecated\", // Will be removed shortly\n});\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text], context) {\n    let url = \"https://cataas.com/cat/says/\" + encodeURIComponent(text);\n    url = coda.withQueryParams(url, {\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");"
      },
      {
        "name": "Rich data (Todoist)",
        "content": "A column format that formats a URL as rich data. This sample displays the URL of the Todoist task in the cell as a rich data chip.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\n\n// Regular expressions that match Todoist task URLs. Used by the column format\n// and also the formula that powers it.\nconst TaskUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showTask\\\\?id=([0-9]+)\"),\n];\n\nexport const pack = coda.newPack();\n\n// Add a column format that displays a task URL as rich metadata.\npack.addColumnFormat({\n  name: \"Task\",\n  // The formula \"GetTask\" below will get run on the cell value.\n  formulaName: \"GetTask\",\n  formulaNamespace: \"Deprecated\",\n  // If the first values entered into a new column match these patterns then\n  // this column format will be automatically applied.\n  matchers: TaskUrlPatterns,\n});\n\n// A schema defining the rich metadata to be returned.\nconst TaskSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.Number,\n      required: true,\n    },\n  },\n  primary: \"name\",\n  id: \"taskId\",\n  identity: {\n    name: \"Task\",\n  },\n});\n\n// Formula that looks up rich metadata about a task given it's URL. This is used\n// by the \"Task\" column format above, but is also a regular formula that can be\n// used elsewhere.\npack.addFormula({\n  name: \"GetTask\",\n  description: \"Gets a Todoist task by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n\n  execute: async function ([url], context) {\n    let taskId = extractTaskId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v1/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    let task = response.body;\n    return {\n      name: task.content,\n      description: task.description,\n      url: task.url,\n      taskId: task.id,\n    };\n  },\n});\n\n// Helper function to extract the Task ID from the URL.\nfunction extractTaskId(taskUrl: string) {\n  for (let pattern of TaskUrlPatterns) {\n    let matches = taskUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid task URL: \" + taskUrl);\n}\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      }
    ]
  },
  {
    "name": "Authentication",
    "category": "Topic",
    "triggerTokens": [
      "setSystemAuthentication",
      "setUserAuthentication"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/reference/sdk/classes/PackDefinitionBuilder#setSystemAuthentication"
    },
    "exampleFooterLink": "https://coda.github.io/packs-sdk/reference/sdk/classes/PackDefinitionBuilder#setSystemAuthentication",
    "learnMoreLink": "/reference/sdk/classes/PackDefinitionBuilder#setSystemAuthentication",
    "content": "The SDK broadly divides authentication into two categories: authentication that is tied to the user of the pack vs authentication that is managed by the system, aka the pack author. In the pack definition the former is known as `defaultAuthentication` and the latter `systemConnectionAuthentication`. You will typically specify one or the other in your pack definition, or neither if your pack does not make http requests or those requests do not require authentication.\n\nDefault authentication is the most common. Specify this if each user of your pack should log in with OAuth, or have their own API key, or whatever user-specific token is necessary for the pack to be able to retrieve data that is specific to that user.\n\nUse system authentication if you as the pack author will provide the necessary tokens to successfully make http requests within your pack. An example would be if your pack returns weather forecasts and the API involved requires an API key, but individual users need not provide their own API key. You as the pack author will register an API key and provide it to Coda, and Coda will apply it to all pack requests regardless of the user.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "",
        "code": "pack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n});"
      },
      {
        "name": "OAuth2 (Todoist)",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Adds OAuth2 authentication for the Todoist API.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // OAuth2 URLs and scopes are found in the the Todoist OAuth guide:\n  // https://developer.todoist.com/guides/#oauth\n  authorizationUrl: \"https://todoist.com/oauth/authorize\",\n  tokenUrl: \"https://todoist.com/oauth/access_token\",\n  scopes: [\"data:read_write\"],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = coda.withQueryParams(\"https://api.todoist.com/sync/v8/sync\", {\n      resource_types: JSON.stringify([\"user\"]),\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.user?.full_name;\n  },\n});"
      }
    ]
  },
  {
    "name": "Dynamic sync tables",
    "category": "Topic",
    "triggerTokens": [
      "addDynamicSyncTable"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/reference/sdk/classes/PackDefinitionBuilder#addDynamicSyncTable"
    },
    "exampleFooterLink": "https://coda.github.io/packs-sdk/reference/sdk/classes/PackDefinitionBuilder#addDynamicSyncTable",
    "learnMoreLink": "/reference/sdk/classes/PackDefinitionBuilder#addDynamicSyncTable",
    "content": "Most sync tables have schemas that can be statically defined. For example, if you're writing a sync of a user's Google Calendar events, the structure of an Event from the Google Calendar API is well-known and you can write a schema for what your table should contain.\n\nIn certain cases, you may want to sync data whose structure is not known in advance and may depend on the user doing the sync. For example, Coda's Jira pack allows users to sync data from their Jira instance, but Jira lets users create arbitrary custom fields for their Issue objects. So the schema of the Issues sync table is not known in advance; it depends on the Jira account that the user is syncing from.\n\nCoda supports \"dynamic\" sync tables for cases like these. Instead of including a static schema in your sync table definition, you include a formula that returns a schema. This formula can use the fetcher to make authenticated http requests to your Pack's API so that you may retrieve any necessary info from that third-party service needed to construct an appropriate schema.\n\nTo define a dynamic schema, use the `makeDynamicSyncTable()` wrapper function. You will provide a `getSchema` formula that returns a schema definition. You'll also provide some supporting formulas like `getName`, to return a name in the UI for the table, in case even the name of the entities being synced is dynamic.\n\nThere are two subtle variants of dynamic sync tables. A sync table can be dynamic simply because the shape of the entities being synced vary based on who the current user is. For example, in the Jira example, Jira Issues are synced by hitting the same static Jira API url for Issues, but the schema of the issues returned will be different depending on the configuration of the Jira instance of the calling user.\n\nAlternatively, a sync table can be dynamic because the data source is specific to each instance of the table. If you were building a sync table to sync data from a Google Sheet, the data source would be the API url of a specific sheet. In this case, the sync table will be bound to a `dynamicUrl` that defines the data source. This url will be available to all of the formulas to implement the sync table in the sync context, as `context.sync.dynamicUrl`. To create a sync table that uses dynamic urls, you must implement the `listDynamicUrls` metadata formula in your dynamic sync table definition.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "",
        "code": "pack.addDynamicSyncTable({\n  name: \"<User-visible name for the sync table>\",\n  getName: async function (context) {\n    let datasourceUrl = context.sync!.dynamicUrl!;\n    // TODO: Fetch metdata about the datasource and return the name.\n    return \"<Datasource Name>\";\n  },\n  getSchema: async function (context) {\n    let datasourceUrl = context.sync!.dynamicUrl!;\n    // TODO: Fetch metdata about the datasource and get the list of fields.\n    let properties = {\n      // TODO: Create a property for each field.\n    };\n    let id = \"<Determine the field containing a unique ID>\";\n    let primary = \"<Determine the field containing the display value>\";\n    let featured = [\n      // TODO: Determine which fields to show in the table by default.\n    ];\n    return coda.makeSchema({\n      type: coda.ValueType.Array,\n      items: coda.makeObjectSchema({\n        type: coda.ValueType.Object,\n        identity: {\n          name: \"<User-visible name for the column containing the schema>\",\n          dynamicUrl: datasourceUrl,\n        },\n        properties: properties,\n        id: id,\n        primary: primary,\n        featured: featured,\n      }),\n    });\n  },\n  getDisplayUrl: async function (context) {\n    return context.sync!.dynamicUrl!;\n  },\n  formula: {\n    name: \"<Name of the sync formula, not show to the user>\",\n    description: \"<Help text for the sync formula, not show to the user>\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"<User-visible name of parameter>\",\n        description: \"<Help text for the parameter>\",\n      }),\n      // Add more parameters here and in the array below.\n    ],\n    execute: async function ([param], context) {\n      let datasourceUrl = context.sync!.dynamicUrl!;\n      let url = \"<URL to pull data from>\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let items = response.body.items;\n      // Adjust the items to fit the schema if required.\n      return {\n        result: items,\n      }\n    },\n  },\n});"
      }
    ]
  },
  {
    "name": "Formulas",
    "category": "Topic",
    "triggerTokens": [
      "addFormula"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/blocks/formulas"
    },
    "exampleFooterLink": "https://coda.github.io/packs-sdk/guides/blocks/formulas",
    "learnMoreLink": "/guides/blocks/formulas",
    "content": "A formula is a JavaScript function that is exposed as a Coda formula, that you can use anywhere in a Coda doc that you can use any built-in formula. Formulas take basic types as input, like strings, numbers, dates, booleans, and arrays of these types, and return any of these types or objects whose properties are any of these types.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "The basic structure of a formula. This sample takes in a single string parameter and returns a string result.",
        "code": "pack.addFormula({\n  name: \"<User-visible name of formula>\",\n  description: \"<Help text for the formula>\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"<User-visible name of parameter>\",\n      description: \"<Help text for the parameter>\",\n    }),\n    // Add more parameters here and in the array below.\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([param], context) {\n    return \"Hello \" + param;\n  },\n});"
      },
      {
        "name": "Image result",
        "content": "A formula that returns an image. This sample gets a random cat image with an optional text overlay or filter applied.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"filter\",\n      description: \"A filter to apply to the image.\",\n      autocomplete: [\"blur\", \"mono\", \"sepia\", \"negative\", \"paint\", \"pixel\"],\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text, filter], context) {\n    let url = \"https://cataas.com/cat\";\n    if (text) {\n      url += \"/says/\" + encodeURIComponent(text);\n    }\n    url = coda.withQueryParams(url, {\n      filter: filter,\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");"
      },
      {
        "name": "Rich data result",
        "content": "A formula that returns rich data (a schema). This sample gets information about a task in the Todoist application.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the rich metadata to be returned about each task.\nconst TaskSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.Number,\n      required: true,\n    },\n  },\n  primary: \"name\",\n  id: \"taskId\",\n  identity: {\n    name: \"Task\",\n  },\n});\n\n// Formula that looks up rich metadata about a task given it's URL.\npack.addFormula({\n  name: \"GetTaskById\",\n  description: \"Gets a Todoist task by ID\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"taskId\",\n      description: \"The ID of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n\n  execute: async function ([taskId], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v1/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    let task = response.body;\n    return {\n      name: task.content,\n      description: task.description,\n      url: task.url,\n      taskId: task.id,\n    };\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      }
    ]
  },
  {
    "name": "Actions",
    "category": "Topic",
    "triggerTokens": [
      "isAction"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/blocks/actions"
    },
    "exampleFooterLink": "https://coda.github.io/packs-sdk/guides/blocks/actions",
    "learnMoreLink": "/guides/blocks/actions",
    "content": "Actions are special types of formulas that power buttons and automations. They usually send data to an external API, but can also be used for other one-time calculations.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "The basic structure of an action. This sample takes in a single string parameter and returns the string \"OK\" when the action is complete.",
        "code": "pack.addFormula({\n  name: \"<User-visible name of formula>\",\n  description: \"<Help text for the formula>\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"<User-visible name of parameter>\",\n      description: \"<Help text for the parameter>\",\n    }),\n    // Add more parameters here and in the array below.\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n  execute: async function ([param], context) {\n    // TODO: Do something.\n    return \"OK\";\n  },\n});"
      },
      {
        "name": "Random value",
        "content": "A formula that returns a random value. This sample rolls virtual dice and returns the results.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Rolls virtual dice and returns the resulting numbers. Use it with a button in\n// table and store the results in another column.\npack.addFormula({\n  name: \"RollDice\",\n  description: \"Roll some virtual dice.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"quantity\",\n      description: \"How many dice to roll.\",\n      defaultValue: 1,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"sides\",\n      description: \"How many sides the dice have.\",\n      defaultValue: 6,\n    }),\n  ],\n  resultType: coda.ValueType.Array,\n  items: {\n    type: coda.ValueType.Number,\n  },\n  isAction: true,\n  execute: async function ([quantity, sides], context) {\n    let results = [];\n    for (let i = 0; i < quantity; i++) {\n      let roll = Math.ceil(Math.random() * sides);\n      results.push(roll);\n    }\n    return results;\n  },\n});"
      },
      {
        "name": "Post to API",
        "content": "A formula that posts data to an external API. This sample creates a new task in the Todoist app.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Action formula (for buttons and automations) that adds a new task in Todoist.\npack.addFormula({\n  name: \"AddTask\",\n  description: \"Add a new task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the task.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n\n  execute: async function ([name], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v1/tasks\",\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        content: name,\n      }),\n    });\n    // Return values are optional but recommended. Returning a URL or other\n    // unique identifier is recommended when creating a new entity.\n    return response.body.url;\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      }
    ]
  },
  {
    "name": "Parameters",
    "category": "Topic",
    "triggerTokens": [
      "makeParameter"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/basics/parameters"
    },
    "exampleFooterLink": "https://coda.github.io/packs-sdk/guides/basics/parameters",
    "learnMoreLink": "/guides/basics/parameters",
    "content": "Coda formulas, actions, and sync tables receive take in user input via parameters. They are required by default, but can by made optional. Variable argument (vararg) parameters can be used to allow for parameters to be set more than once.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "The basic structure of a parameter. This sample is for a string parameter.",
        "code": "coda.makeParameter({\n  type: coda.ParameterType.String,\n  name: \"<User-visible name of parameter>\",\n  description: \"<Help text for the parameter>\",\n});"
      },
      {
        "name": "No parameters",
        "content": "A formula without any parameters. This sample returns the name of the current day of the week.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formula that gets the current weekday, for example \"Monday\".\npack.addFormula({\n  name: \"CurrentWeekday\",\n  description: \"Get the current day of the week.\",\n  parameters: [],\n  resultType: coda.ValueType.String,\n  execute: async function ([], context) {\n    let now = new Date();\n    let formatter = Intl.DateTimeFormat(\"us-US\", {weekday: \"long\"});\n    return formatter.format(now);\n  },\n});"
      },
      {
        "name": "Optional parameters",
        "content": "A formula with some required and some optional parameters. This sample formats text to look like screaming, with a optional parameters to override how many exclamation points to use and an alternate character to use.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Formats text to look like screaming. For example, \"Hello\" => \"HELLO!!!\".\npack.addFormula({\n  name: \"Scream\",\n  description: \"Make text uppercase and add exclamation points.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"The text to scream.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"volume\",\n      description: \"The number of exclamation points to add.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"character\",\n      description: \"The character to repeat.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([text, volume = 3, character = \"!\"], context) {\n    return text.toUpperCase() + character.repeat(volume);\n  },\n});"
      },
      {
        "name": "Variable argument parameters",
        "content": "A formula that accepts a variable number of arguments. This sample draws a simple diagram using text, with an unknown number of arrow labels and steps.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Takes an unknown number of steps and labels and outputs a simple diagram.\n// Example: Steps(\"Idea\", \"Experiment\", \"Prototype\", \"Refine\", \"Product\")\n// Result: Idea --Experiment--> Prototype --Refine--> Product\npack.addFormula({\n  name: \"Steps\",\n  description: \"Draws a simple step diagram using text.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"start\",\n      description: \"The starting step.\",\n    }),\n  ],\n  varargParameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"label\",\n      description: \"The label for the arrow.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"step\",\n      description: \"The next step.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([start, ...varargs], context) {\n    let result = start;\n    while (varargs.length > 0) {\n      let label; let step;\n      // Pull the first set of varargs off the list, and leave the rest.\n      [label, step, ...varargs] = varargs;\n      result += ` --${label}--> ${step}`;\n    }\n    return result;\n  },\n});"
      }
    ]
  },
  {
    "name": "Autocomplete",
    "category": "Topic",
    "triggerTokens": [
      "autocomplete"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/advanced/autocomplete"
    },
    "exampleFooterLink": "https://coda.github.io/packs-sdk/guides/advanced/autocomplete",
    "learnMoreLink": "/guides/advanced/autocomplete",
    "content": "Autocomplete can be configured for a parameter to provide a defined set of options for the user to select from. You can can pass either a static array or use a function to dynamically generate the options.",
    "exampleSnippets": [
      {
        "name": "Simple autocomplete",
        "content": "A formula with a parameter that provides autocomplete for acceptable values. This sample returns the noise that an animal makes, for a limited set of animals.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Returns the noise an animal makes. Ex) \"cow\" => \"moo\".\npack.addFormula({\n  name: \"AnimalNoise\",\n  description: \"Gets the noise than an animal makes.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"animal\",\n      description: \"The selected animal.\",\n      autocomplete: [\"cow\", \"pig\", \"sheep\"],\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([animal], context) {\n    switch (animal) {\n      case \"cow\":\n        return \"moo\";\n      case \"pig\":\n        return \"oink\";\n      case \"sheep\":\n        return \"baa\";\n      default:\n        throw new coda.UserVisibleError(\"Unknown animal: \" + animal);\n    }\n  },\n});"
      },
      {
        "name": "Dynamic autocomplete",
        "content": "A formula with a parameter that provides autocomplete for acceptable values, where the options are pulled dynamically from an API. This sample returns the price for a board game listed on the site Board Game Atlas.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Gets the price of a board game by ID, with autocomplete on the ID.\npack.addFormula({\n  name: \"GetPrice\",\n  description: \"Gets the price of a board game.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"gameId\",\n      description: \"The ID of the game on boardgameatlas.com\",\n      autocomplete: async function (context, search, parameters) {\n        let url = coda.withQueryParams(\n          \"https://api.boardgameatlas.com/api/search\",\n          { fuzzy_match: true, name: search });\n        let response = await context.fetcher.fetch({ method: \"GET\", url: url });\n        let results = response.body.games;\n        // Generate an array of autocomplete objects, using the game's name as\n        // the label and its ID for the value.\n        return coda.autocompleteSearchObjects(search, results, \"name\", \"id\");\n      },\n    }),\n  ],\n  resultType: coda.ValueType.Number,\n  codaType: coda.ValueHintType.Currency,\n  execute: async function ([gameId], context) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://api.boardgameatlas.com/api/search?ids=\" + gameId,\n    });\n    return response.body.games[0].price;\n  },\n});\n\npack.addNetworkDomain(\"boardgameatlas.com\");\n\n// Authenticate using a client ID.\n// See: https://www.boardgameatlas.com/api/docs/apps\npack.setSystemAuthentication({\n  type: coda.AuthenticationType.QueryParamToken,\n  paramName: \"client_id\",\n});"
      },
      {
        "name": "Autocomplete on previous parameter",
        "content": "A formula with a parameter that provides autocomplete for acceptable values, where the options depend on the value of a previous parameter. This sample generates a greeting in either English or Spanish.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Greet someone in their language, with the greeting autocomplete adjusting\n// based on the language selected.\npack.addFormula({\n  name: \"Greeting\",\n  description: \"Greet someone.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"language\",\n      description: \"The language to greet them in.\",\n      autocomplete: [\n        { display: \"English\", value: \"en\" },\n        { display: \"Spanish\", value: \"es\" },\n      ],\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"greeting\",\n      description: \"The greeting to use.\",\n      autocomplete: async function (context, search, {language}) {\n        let options;\n        if (language === \"es\") {\n          options = [\"Hola\", \"Buenos días\"];\n        } else {\n          options = [\"Hello\", \"Howdy\"];\n        }\n        return coda.simpleAutocomplete(search, options);\n      },\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name to greet.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  execute: async function ([language, greeting, name], context) {\n    let result = greeting + \" \" + name + \"!\";\n    if (language === \"es\") {\n      // Add upside-down exclamation point in the front.\n      result = \"¡\" + result;\n    }\n    return result;\n  },\n});"
      }
    ]
  },
  {
    "name": "Sync tables",
    "category": "Topic",
    "triggerTokens": [
      "addSyncTable"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/reference/sdk/classes/PackDefinitionBuilder#addSyncTable"
    },
    "exampleFooterLink": "https://coda.github.io/packs-sdk/reference/sdk/classes/PackDefinitionBuilder#addSyncTable",
    "learnMoreLink": "/reference/sdk/classes/PackDefinitionBuilder#addSyncTable",
    "content": "A **sync table** is how to bring structured data from a third-party into Coda. A sync table is a table that you can add to a Coda doc that gets its rows from a third-party data source, that can be refreshed regularly to pull in new or updated data. A sync table is powered by a **formula** that takes parameters that represent sync options and returns an array of objects representing row data. A sync table also includes a schema describing the structure of the returned objects.",
    "exampleSnippets": [
      {
        "name": "Template",
        "content": "",
        "code": "const MySchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    property1: {type: coda.ValueType.Number},\n    property2: {type: coda.ValueType.String},\n    // Add more properties here.\n  },\n  id: \"property1\", // Which property above is a unique ID.\n  primary: \"property2\", // Which property above to display by default.\n  identity: {\n    name: \"<User-visible name for the column containing the schema>\",\n  },\n});\n\npack.addSyncTable({\n  name: \"<User-visible name for the sync table>\",\n  identityName: \"<User-visible name for the column containing the schema>\",\n  schema: MySchema,\n  formula: {\n    name: \"<Name of the sync formula, not show to the user>\",\n    description: \"<Help text for the sync formula, not show to the user>\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"<User-visible name of parameter>\",\n        description: \"<Help text for the parameter>\",\n      }),\n      // Add more parameters here and in the array below.\n    ],\n    execute: async function ([param], context) {\n      let url = \"<URL to pull data from>\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let items = response.body.items;\n      // Adjust the items to fit the schema if required.\n      return {\n        result: items,\n      }\n    },\n  },\n});"
      },
      {
        "name": "Cats",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Schema for a Cat image.\nconst CatSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    image: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n    tags: {\n      type: coda.ValueType.Array,\n      items: { type: coda.ValueType.String },\n    },\n    created: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.DateTime,\n    },\n    id: { type: coda.ValueType.String },\n  },\n  primary: \"image\",\n  id: \"id\",\n  featured: [\"tags\"],\n  identity: {\n    name: \"Cat\",\n  },\n});\n\n// Sync table that retrieves all cat images, optionally filtered by tags.\npack.addSyncTable({\n  name: \"Cats\",\n  identityName: \"Cat\",\n  schema: CatSchema,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  formula: {\n    name: \"SyncCats\",\n    description: \"Syncs the cats.\",\n    parameters: [\n      coda.makeParameter({\n        type: coda.ParameterType.String,\n        name: \"tag\",\n        description: \"Only cats with this tag will be selected.\",\n        optional: true,\n        // Pull the list of tags to use for autocomplete from the API.\n        autocomplete: async function (context, search) {\n          let response = await context.fetcher.fetch({\n            method: \"GET\",\n            url: \"https://cataas.com/api/tags\",\n          });\n          let tags = response.body;\n          // Convert the tags into a list of autocomplete options.\n          return coda.simpleAutocomplete(search, tags);\n        },\n      }),\n    ],\n    execute: async function ([tag], context) {\n      let url = coda.withQueryParams(\"https://cataas.com/api/cats\", {\n        tags: tag\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let cats = response.body;\n      let result: any = [];\n      for (let cat of cats) {\n        result.push({\n          image: \"https://cataas.com/cat/\" + cat.id,\n          tags: cat.tags,\n          created: cat.created_at,\n          id: cat.id,\n        });\n      }\n      return {\n        result: result,\n      };\n    },\n  },\n});\n\n// Allow the pack to make requests to Cat-as-a-service API.\npack.addNetworkDomain(\"cataas.com\");"
      },
      {
        "name": "Todoist",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// A schema defining the data in the sync table.\nconst TaskSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.Number,\n      required: true,\n    },\n  },\n  primary: \"name\",\n  id: \"taskId\",\n  featured: [\"description\", \"url\"],\n  identity: {\n    name: \"Task\",\n  },\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [],\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v1/tasks\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results: any[] = [];\n      for (let task of response.body) {\n        results.push({\n          name: task.content,\n          description: task.description,\n          url: task.url,\n          taskId: task.id,\n        });\n      }\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n// Allow the pack to make requests to Todoist.\npack.addNetworkDomain(\"todoist.com\");\n\n// Setup authentication using a Todoist API token.\npack.setUserAuthentication({\n  type: coda.AuthenticationType.HeaderBearerToken,\n  instructionsUrl: \"https://todoist.com/app/settings/integrations\",\n});"
      }
    ]
  },
  {
    "name": "Fetcher",
    "category": "Topic",
    "triggerTokens": [
      "fetch"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/advanced/fetcher"
    },
    "exampleFooterLink": "https://coda.github.io/packs-sdk/guides/advanced/fetcher",
    "learnMoreLink": "/guides/advanced/fetcher",
    "content": "Communicating with an API or external server is done through the `Fetcher`, a custom interface for making HTTP requests. The fetcher is made available through the `context` object passed in to formulas. The fetcher can only send requests to URLs that have have a domain name that's been registered using `addNetworkDomain`. The fetcher runs asynchronously, and is typically run within an `async` function that will `await` the result.",
    "exampleSnippets": [
      {
        "name": "Template (GET)",
        "content": "",
        "code": "let response = await context.fetcher.fetch({\n  method: \"GET\",\n  url: \"<The URL to fetch>\",\n  headers: {\n    \"<HeaderName>\": \"<HeaderValue>\",\n    // Add more headers as needed.\n  },\n});\nlet data = response.body;"
      },
      {
        "name": "Template (POST)",
        "content": "",
        "code": "let payload = {\n  // Whatever JSON structure the API expects.\n};\nlet response = await context.fetcher.fetch({\n  method: \"POST\",\n  url: \"<The URL to send the request to>\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    // Add more headers as needed.\n  },\n  body: JSON.stringify(payload),\n});\nlet data = response.body;"
      },
      {
        "name": "JSON Array (Bacon Ipsum)",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// When using the fetcher, this is the domain of the API that your pack makes\n// fetcher requests to.\npack.addNetworkDomain(\"baconipsum.com\");\n\n// This line adds a new formula to this Pack.\npack.addFormula({\n  name: \"BaconIpsum\",\n  description: \"Returns meat-themed lorem ipsum copy.\",\n  parameters: [], // No parameters required.\n  resultType: coda.ValueType.String,\n\n  // This function is declared async to that is can wait for the fetcher to\n  // complete. The context parameter provides access to the fetcher.\n  execute: async function ([], context) {\n    let url = \"https://baconipsum.com/api/?type=meat-and-filler\";\n\n    // The fetcher's fetch method makes the request. The await keyword is used\n    // to wait for the API's response before continuing on through the code.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url\n    });\n\n    // The API returns an array of strings, which is automatically parsed by\n    // the fetcher into a JavaScript object.\n    let paragraphs = response.body;\n\n    // Return the paragraphs separated by a blank line.\n    return paragraphs.join(\"\\n\\n\");\n  },\n});"
      }
    ]
  },
  {
    "name": "Data types",
    "category": "Topic",
    "triggerTokens": [
      "resultType",
      "type"
    ],
    "linkData": {
      "type": "SdkReferencePath",
      "url": "/guides/basics/data-types"
    },
    "exampleFooterLink": "https://coda.github.io/packs-sdk/guides/basics/data-types",
    "learnMoreLink": "/guides/basics/data-types",
    "content": "Packs can return various types of values, and apply hints that tell Coda how to display that data. Formulas and schema properties must declare the these types upfront, and the values you return in your code must match.",
    "exampleSnippets": [
      {
        "name": "Template (String)",
        "content": "The basic structure of a formula that returns a string.",
        "code": "pack.addFormula({\n  name: \"<User-visible name of formula>\",\n  description: \"<Help text for the formula>\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"<User-visible name of parameter>\",\n      description: \"<Help text for the parameter>\",\n    }),\n    // Add more parameters here and in the array below.\n  ],\n  resultType: coda.ValueType.String,\n  execute: async function ([param], context) {\n    return \"Hello \" + param;\n  },\n});"
      },
      {
        "name": "Template (Number)",
        "content": "The basic structure of a formula that returns a number.",
        "code": "pack.addFormula({\n  name: \"<User-visible name of formula>\",\n  description: \"<Help text for the formula>\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"<User-visible name of parameter>\",\n      description: \"<Help text for the parameter>\",\n    }),\n    // Add more parameters here and in the array below.\n  ],\n  resultType: coda.ValueType.Number,\n  execute: async function ([param], context) {\n    return param.length;\n  },\n});"
      },
      {
        "name": "Template (boolean)",
        "content": "The basic structure of a formula that returns a boolean.",
        "code": "pack.addFormula({\n  name: \"<User-visible name of formula>\",\n  description: \"<Help text for the formula>\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"<User-visible name of parameter>\",\n      description: \"<Help text for the parameter>\",\n    }),\n    // Add more parameters here and in the array below.\n  ],\n  resultType: coda.ValueType.Boolean,\n  execute: async function ([param], context) {\n    return param === \"true\";\n  },\n});"
      },
      {
        "name": "Template (Array)",
        "content": "The basic structure of a formula that returns an array.",
        "code": "pack.addFormula({\n  name: \"<User-visible name of formula>\",\n  description: \"<Help text for the formula>\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"<User-visible name of parameter>\",\n      description: \"<Help text for the parameter>\",\n    }),\n    // Add more parameters here and in the array below.\n  ],\n  resultType: coda.ValueType.Array,\n  items: {\n    type: coda.ValueType.String,\n  },\n  execute: async function ([param], context) {\n    return [\"Hello\", param];\n  },\n});"
      },
      {
        "name": "Template (Object)",
        "content": "The basic structure of a formula that returns an object.",
        "code": "const MySchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    property1: {type: coda.ValueType.Number},\n    property2: {type: coda.ValueType.String},\n    // Add more properties here.\n  },\n  id: \"property1\", // Which property above is a unique ID.\n  primary: \"property2\", // Which property above to display by default.\n  identity: {\n    name: \"<User-visible name>\",\n  },\n});\n\npack.addFormula({\n  name: \"<User-visible name of formula>\",\n  description: \"<Help text for the formula>\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"<User-visible name of parameter>\",\n      description: \"<Help text for the parameter>\",\n    }),\n    // Add more parameters here and in the array below.\n  ],\n  resultType: coda.ValueType.Object,\n  schema: MySchema,\n  execute: async function ([param], context) {\n    return {\n      property1: 123,\n      property2: param,\n    };\n  },\n});"
      },
      {
        "name": "Markdown",
        "content": "A formula that returns markdown content. This sample returns the contents of the README.md file from a GitHub repository.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Returns the contents of GitHub repo's README.md file as markdown.\npack.addFormula({\n  name: \"GetReadme\",\n  description: \"Gets the content of a GitHub repo's README.md file.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"repo\",\n      description: \"The repo to read from.\",\n      defaultValue: \"coda/packs-sdk\"\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.Markdown,\n  execute: async function ([repo], context) {\n    let url = `https://raw.githubusercontent.com/${repo}/HEAD/README.md`\n    let result = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return result.body;\n  },\n});\n\npack.addNetworkDomain(\"raw.githubusercontent.com\");"
      },
      {
        "name": "HTML",
        "content": "A formula that returns HTML content. This sample returns HTML with every word of the input string bolded.",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\n// Returns HTML with every other word of the input text bolded.\npack.addFormula({\n  name: \"AlternatingBold\",\n  description: \"Bold every other word.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"The text to bold.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.Html,\n  execute: async function ([text], context) {\n    let words = text.split(\" \");\n    for (let i = 0; i < words.length; i++) {\n      if (i % 2 == 0) {\n        words[i] = `<b>${words[i]}</b>`\n      }\n    }\n    return words.join(\" \");\n  },\n});"
      }
    ]
  },
  {
    "name": "Hello World",
    "category": "Full",
    "triggerTokens": [],
    "linkData": {
      "type": "Web",
      "url": "https://coda.io/@coda/make-a-pack-private-alpha/hello-world-16"
    },
    "exampleFooterLink": "https://coda.io/@coda/make-a-pack-private-alpha/hello-world-16",
    "content": "This is an example which creates a single formula called Hello, that takes in a string called name and returns “Hello, name !“.",
    "exampleSnippets": [
      {
        "name": "Hello World",
        "content": "",
        "code": "/*\nStart making Packs!\nTry out the hello world sample below to create your first build.\n*/\n\n// This import statement gives you access to all parts of the Coda Packs SDK.\nimport * as coda from \"@codahq/packs-sdk\";\n\n// This line creates your new Pack.\nexport const pack = coda.newPack();\n\n// Here, we add a new formula to this Pack.\npack.addFormula({\n  // This is the name that will be called in the formula builder.\n  // Remember, your formula name cannot have spaces in it.\n  name: \"Hello\",\n  description: \"A Hello World example.\",\n\n  // If your formula requires one or more inputs, you’ll define them here.\n  // Here, we're creating a string input called “name”.\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name you would like to say hello to.\",\n    }),\n  ],\n\n  // The resultType defines what will be returned in your Coda doc. Here, we're\n  // returning a simple text string.\n  resultType: coda.ValueType.String,\n\n  // Everything inside this execute statement will happen anytime your Coda\n  // formula is called in a doc. An array of all user inputs is always the 1st\n  // parameter.\n  execute: async function ([name], context) {\n    return \"Hello \" + name + \"!\";\n  },\n});"
      }
    ]
  },
  {
    "name": "Daylight",
    "category": "Full",
    "triggerTokens": [],
    "linkData": {
      "type": "Web",
      "url": "https://coda.io/@coda/make-a-pack-private-alpha/daylight-29"
    },
    "exampleFooterLink": "https://coda.io/@coda/make-a-pack-private-alpha/daylight-29",
    "content": "This Pack provides a `Daylight` formula that determines the daylight, sunrise,\n and sunset at a given location using the [Sunrise Sunset API][api]. It accepts\n a latitude, longitude, an optional date and returns a rich object (schema) as\n a result. It uses the `Fetcher` to pull data from an external API.\n\n [api]: https://sunrise-sunset.org/api",
    "exampleSnippets": [
      {
        "name": "Daylight",
        "content": "",
        "code": "/**\n * This Pack provides a \"Daylight\" formula that determines the daylight,\n * sunrise, and sunset at a given location using the Sunrise Sunset API.\n * The results are returns as a rich object.\n * @see {@link https://sunrise-sunset.org/api|Sunrise Sunset API}\n */\n\n// This import statement provides access to all parts of the Coda Packs SDK.\nimport * as coda from \"@codahq/packs-sdk\";\n\n// This line creates the new Pack.\nexport const pack = coda.newPack();\n\n// The domain that the Pack will match fetcher requests to.\npack.addNetworkDomain(\"sunrise-sunset.org\");\n\n// Define a schema that will be used to bundle up the multiple pieces of data\n// our formula will return. In the Coda doc this will be displayed as a chip.\nconst SunSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    // The values we return are simple strings, but we use the codaType field to\n    // to tell Coda to interpret them as durations and time values.\n    daylight: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Duration,\n    },\n    sunriseUTC: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Time,\n    },\n    sunsetUTC: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Time,\n    },\n  },\n  // Which of the properties defined above will be shown inside the chip.\n  primary: \"daylight\",\n});\n\n// Add a \"Daylight\" formula to the Pack.\npack.addFormula({\n  name: \"Daylight\",\n  description: \"Returns the sunrise and sunset for a given location.\",\n\n  // This formula takes two required numeric inputs (the latitude and longitude)\n  // and one optional date.\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"lat\",\n      description: \"The latitude to use.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"lng\",\n      description: \"The longitude to use.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Date,\n      name: \"date\",\n      description: \"The date to use. Defaults to today.\",\n      // This date parameter is an optional input.\n      optional: true,\n    }),\n  ],\n\n  // In this formula, we're returning an object with multiple properties.\n  resultType: coda.ValueType.Object,\n\n  // This object will be defined according to the schema written above.\n  schema: SunSchema,\n\n  // Everything inside this execute statement will happen anytime the Coda\n  // formula is called in a doc. An array of all user inputs is passed as the\n  // first parameter. The context object is always the second parameter and is\n  // used for fetching data.\n  execute: async function ([lat, lng, date], context) {\n    // Default to today if no date is provided.\n    let lookupDate = date || new Date();\n\n    // Format date to yyyy-mm-dd format as required by this API.\n    let formattedDate = lookupDate.toISOString().split(\"T\")[0];\n\n    // Create the URL to fetch, using the helper function coda.withQueryParams\n    // to add on query parameters (ex: \"?lat=40.123...\").\n    let url = coda.withQueryParams(\"https://api.sunrise-sunset.org/json\", {\n      lat: lat,\n      lng: lng,\n      date: formattedDate\n    });\n\n    // Fetch the URL and get the response.\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url\n    });\n\n    // The JSON returned by the API is parsed automatically and available in\n    // `response.body`. Here we pull out the content in the \"results\" key.\n    let results = response.body.results;\n\n    // Re-format the day_length string to [h] hrs [m] mins [s] secs to work as a\n    // duration.\n    let hours = results.day_length.split(\":\")[0];\n    let mins = results.day_length.split(\":\")[1];\n    let secs = results.day_length.split(\":\")[2];\n\n    let daylight = `${hours} hrs ${mins} mins ${secs} secs`;\n\n    // Return the final object. The keys here must match with the properties\n    // defined above in the schema.\n    return {\n      daylight: daylight,\n      sunriseUTC: response.body.results.sunrise,\n      sunsetUTC: response.body.results.sunset,\n    };\n  },\n});"
      }
    ]
  },
  {
    "name": "Number Array",
    "category": "Full",
    "triggerTokens": [],
    "linkData": {
      "type": "Web",
      "url": "https://coda.io/@coda/make-a-pack-private-alpha/number-array-27"
    },
    "exampleFooterLink": "https://coda.io/@coda/make-a-pack-private-alpha/number-array-27",
    "content": "This is an example which creates two formulas that each take in an array of numbers and return the greatest common denominator and least common multiple.",
    "exampleSnippets": [
      {
        "name": "Number Array",
        "content": "",
        "code": "// This import statement gives you access to all parts of the Coda Packs SDK.\nimport * as coda from \"@codahq/packs-sdk\";\n\n// This import statement gives you access to all parts of the Coda Packs SDK.\nexport const pack = coda.newPack();\n\n// We'll use an array of numbers in *both* formulas.\nconst numberArray = coda.makeParameter({\n  type: coda.ParameterType.NumberArray,\n  name: \"Numbers\",\n  description: \"the numbers you want to calculate\",\n});\n\n// We'll also use this helper function that finds the gcd of two numbers in\n// both formulas.\nfunction gcd(a, b) {\n  if (a === 0) {\n    return b;\n  }\n  return gcd(b % a, a);\n}\n\n// This line adds a new formula.\npack.addFormula({\n  // This is the name that will be called in the formula builder. Remember, your\n  // formula name cannot have spaces in it.\n  name: \"GCD\",\n  description: \"Returns the greatest common denominator for an array\",\n\n  // The needed array of numbers has already been defined above.\n  parameters: [numberArray],\n\n  // In this formula, we're returning a number in the Coda doc.\n  resultType: coda.ValueType.Number,\n\n  // Everything inside this execute statement will happen anytime your Coda\n  // function is called in a doc. An array of all user inputs is always the 1st\n  // parameter.\n  execute: async function ([numberArray]) {\n    let gcdResult = numberArray[0];\n\n    for (let i = 1; i < numberArray.length; i++) {\n      gcdResult = gcd(numberArray[i], gcdResult);\n\n      if (gcdResult === 1) {\n        return 1;\n      }\n    }\n    return gcdResult;\n  },\n});\n\n// Now, we'll define and add the second formula to the pack.\npack.addFormula({\n  name: \"LCM\",\n  description: \"Returns the least common multiple for an array\",\n  parameters: [numberArray],\n  resultType: coda.ValueType.Number,\n  execute: async function ([numberArray]) {\n    let lcmResult = numberArray[0];\n\n    for (let i = 1; i < numberArray.length; i++) {\n      lcmResult = (numberArray[i] * lcmResult) / gcd(numberArray[i], lcmResult);\n    }\n\n    return lcmResult;\n  },\n});"
      }
    ]
  },
  {
    "name": "Todoist",
    "category": "Full",
    "triggerTokens": [],
    "linkData": {
      "type": "SamplePage"
    },
    "exampleFooterLink": "https://coda.github.io/packs-sdk/samples/full/todoist",
    "content": "This Pack provides an integration with the task tracking app [Todoist][todoist]. It uses a variety of building blocks to allow users to work with their projects and tasks, including:\n\n- Formulas that provide rich data about an item given its URL.\n- Column formats that automatically apply those formulas to matching URLs.\n- Action formulas that create and update items, for use in button and automations.\n- Sync tables for pulling in all of the user's items.\n\nThe Pack uses OAuth2 to connect to a user's Todoist account, which you can create for free.\n\n[todoist]: https://todoist.com/",
    "exampleSnippets": [
      {
        "name": "pack.ts",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\n\n\n// Constants.\n\nconst ProjectUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/project/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showProject\\\\?id=([0-9]+)\"),\n];\n\nconst TaskUrlPatterns: RegExp[] = [\n  new RegExp(\"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\"),\n  new RegExp(\"^https://todoist.com/showTask\\\\?id=([0-9]+)\"),\n];\n\n\n// Pack setup.\n\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"todoist.com\");\n\npack.setUserAuthentication({\n  type: coda.AuthenticationType.OAuth2,\n  // OAuth2 URLs and scopes are found in the the Todoist OAuth guide:\n  // https://developer.todoist.com/guides/#oauth\n  authorizationUrl: \"https://todoist.com/oauth/authorize\",\n  tokenUrl: \"https://todoist.com/oauth/access_token\",\n  scopes: [\"data:read_write\"],\n\n  // Determines the display name of the connected account.\n  getConnectionName: async function (context) {\n    let url = coda.withQueryParams(\"https://api.todoist.com/sync/v8/sync\", {\n      resource_types: JSON.stringify([\"user\"]),\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n    });\n    return response.body.user?.full_name;\n  },\n});\n\n// Schemas\n\n// A reference to a synced Project. Usually you can use\n// `coda.makeReferenceSchemaFromObjectSchema` to generate these from the primary\n// schema, but that doesn't work in this case since a Project itself can contain\n// a reference to a parent project.\nconst ProjectReferenceSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  codaType: coda.ValueHintType.Reference,\n  properties: {\n    name: {type: coda.ValueType.String, required: true},\n    projectId: {type: coda.ValueType.Number, required: true},\n  },\n  primary: \"name\",\n  id: \"projectId\",\n  identity: {\n    name: \"Project\",\n  },\n});\n\nconst ProjectSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  codaType: coda.ValueHintType.Reference,\n  properties: {\n    name: {\n      description: \"The name of the project.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    url: {\n      description: \"A link to the project in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url,\n    },\n    shared: {\n      description: \"Is the project is shared.\",\n      type: coda.ValueType.Boolean,\n    },\n    favorite: {\n      description: \"Is the project a favorite.\",\n      type: coda.ValueType.Boolean,\n    },\n    projectId: {\n      description: \"The ID of the project.\",\n      type: coda.ValueType.Number,\n      required: true,\n    },\n    parentProjectId: {\n      description: \"For sub-projects, the ID of the parent project.\",\n      type: coda.ValueType.Number,\n    },\n    // Add a reference to the sync'ed row of the parent project.\n    // References only work in sync tables.\n    parentProject: ProjectReferenceSchema,\n  },\n  primary: \"name\",\n  id: \"projectId\",\n  featured: [\"url\"],\n  identity: {\n    name: \"Project\",\n  },\n});\n\n// A reference to a synced Task. Usually you can use\n// `coda.makeReferenceSchemaFromObjectSchema` to generate these from the primary\n// schema, but that doesn't work in this case since a Project itself can contain\n// a reference to a parent project.\nconst TaskReferenceSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  codaType: coda.ValueHintType.Reference,\n  properties: {\n    name: {type: coda.ValueType.String, required: true},\n    taskId: {type: coda.ValueType.Number, required: true},\n  },\n  primary: \"name\",\n  id: \"taskId\",\n  identity: {\n    name: \"Task\",\n  },\n});\n\nconst TaskSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    name: {\n      description: \"The name of the task.\",\n      type: coda.ValueType.String,\n      required: true,\n    },\n    description: {\n      description: \"A detailed description of the task.\",\n      type: coda.ValueType.String,\n    },\n    url: {\n      description: \"A link to the task in the Todoist app.\",\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.Url\n    },\n    order: {\n      description: \"The position of the task in the project or parent task.\",\n      type: coda.ValueType.Number,\n    },\n    priority: {\n      description: \"The priority of the task.\",\n      type: coda.ValueType.String,\n    },\n    taskId: {\n      description: \"The ID of the task.\",\n      type: coda.ValueType.Number,\n      required: true,\n    },\n    projectId: {\n      description: \"The ID of the project that the task belongs to.\",\n      type: coda.ValueType.Number,\n    },\n    parentTaskId: {\n      description: \"For sub-tasks, the ID of the parent task it belongs to.\",\n      type: coda.ValueType.Number,\n    },\n    // A reference to the sync'ed row of the project.\n    // References only work in sync tables.\n    project: ProjectReferenceSchema,\n    // Add a reference to the sync'ed row of the parent task.\n    // References only work in sync tables.\n    parentTask: TaskReferenceSchema,\n  },\n  primary: \"name\",\n  id: \"taskId\",\n  featured: [\"project\", \"url\"],\n  identity: {\n    name: \"Task\",\n  },\n});\n\n/**\n * Convert a Project API response to a Project schema.\n */\nfunction toProject(project: any, withReferences=false) {\n  let result: any = {\n    name: project.name,\n    projectId: project.id,\n    url: project.url,\n    shared: project.shared,\n    favorite: project.favorite,\n    parentProjectId: project.parent_id,\n  };\n  if (withReferences && project.parent_id) {\n    result.parentProject = {\n      projectId: project.parent_id,\n      name: \"Not found\",  // If sync'ed, the real name will be shown instead.\n    };\n  }\n  return result;\n}\n\n/**\n * Convert a Task API response to a Task schema.\n */\nfunction toTask(task: any, withReferences=false) {\n  let result: any = {\n    name: task.content,\n    description: task.description,\n    url: task.url,\n    order: task.order,\n    priority: task.priority,\n    taskId: task.id,\n    projectId: task.project_id,\n    parentTaskId: task.parent_id,\n  };\n  if (withReferences) {\n    // Add a reference to the corresponding row in the Projects sync table.\n    result.project = {\n      projectId: task.project_id,\n      name: \"Not found\",  // If sync'ed, the real name will be shown instead.\n    };\n    if (task.parent_id) {\n      // Add a reference to the corresponding row in the Tasks sync table.\n      result.parentTask = {\n        taskId: task.parent_id,\n        name: \"Not found\",  // If sync'ed, the real name will be shown instead.\n      };\n    }\n  }\n  return result;\n}\n\n\n// Formulas (read-only).\n\npack.addFormula({\n  name: \"GetProject\",\n  description: \"Gets a Todoist project by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the project\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: ProjectSchema,\n\n  execute: async function ([url], context) {\n    let projectId = extractProjectId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v1/projects/\" + projectId,\n      method: \"GET\",\n    });\n    return toProject(response.body);\n  },\n});\n\npack.addFormula({\n  name: \"GetTask\",\n  description: \"Gets a Todoist task by URL\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"url\",\n      description: \"The URL of the task\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n\n  execute: async function ([url], context) {\n    let taskId = extractTaskId(url);\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v1/tasks/\" + taskId,\n      method: \"GET\",\n    });\n    return toTask(response.body);\n  },\n});\n\n\n// Column Formats.\n\npack.addColumnFormat({\n  name: \"Project\",\n  formulaName: \"GetProject\",\n  formulaNamespace: \"Deprecated\",\n  matchers: ProjectUrlPatterns,\n});\n\npack.addColumnFormat({\n  name: \"Task\",\n  formulaName: \"GetTask\",\n  formulaNamespace: \"Deprecated\",\n  matchers: TaskUrlPatterns,\n});\n\n\n// Action formulas (buttons/automations).\n\npack.addFormula({\n  name: \"AddProject\",\n  description: \"Add a new Todoist project\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the new project\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n\n  execute: async function ([name], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v1/projects\",\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        name: name,\n      }),\n    });\n    return response.body.url;\n  },\n});\n\npack.addFormula({\n  name: \"AddTask\",\n  description: \"Add a new task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The name of the task.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"projectId\",\n      description: \"The ID of the project to add it to. If blank, \" +\n          \"it will be added to the user's Inbox.\",\n      optional: true,\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n\n  execute: async function ([name, projectId], context) {\n    let response = await context.fetcher.fetch({\n      url: \"https://api.todoist.com/rest/v1/tasks\",\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        content: name,\n        project_id: projectId,\n      }),\n    });\n    return response.body.url;\n  },\n});\n\npack.addFormula({\n  name: \"UpdateTask\",\n  description: \"Updates the name of a task.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"taskId\",\n      description: \"The ID of the task to update.\",\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"name\",\n      description: \"The new name of the task.\",\n    }),\n  ],\n  resultType: coda.ValueType.Object,\n  schema: TaskSchema,\n  isAction: true,\n\n  execute: async function ([taskId, name], context) {\n    let url = \"https://api.todoist.com/rest/v1/tasks/\" + taskId;\n    await context.fetcher.fetch({\n      url: url,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        content: name,\n      }),\n    });\n    // Get the updated Task and return it, which will update the row in the sync\n    // table.\n    let response = await context.fetcher.fetch({\n      url: url,\n      method: \"GET\",\n      cacheTtlSecs: 0,  // Ensure we are getting the latest data.\n    });\n    return toTask(response.body);\n  },\n});\n\npack.addFormula({\n  name: \"MarkAsComplete\",\n  description: \"Mark a task as completed.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"taskId\",\n      description: \"The ID of the task to be marked as complete.\",\n    }),\n  ],\n  resultType: coda.ValueType.String,\n  isAction: true,\n\n  execute: async function ([taskId], context) {\n    let url = \"https://api.todoist.com/rest/v1/tasks/\" + taskId + \"/close\";\n    await context.fetcher.fetch({\n      method: \"POST\",\n      url: url,\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n    return \"OK\";\n  },\n});\n\n\n// Sync tables.\n\npack.addSyncTable({\n  name: \"Projects\",\n  schema: ProjectSchema,\n  identityName: \"Project\",\n  formula: {\n    name: \"SyncProjects\",\n    description: \"Sync projects\",\n    parameters: [],\n\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v1/projects\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results: any[] = [];\n      for (let project of response.body) {\n        results.push(toProject(project, true));\n      }\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\npack.addSyncTable({\n  name: \"Tasks\",\n  schema: TaskSchema,\n  identityName: \"Task\",\n  formula: {\n    name: \"SyncTasks\",\n    description: \"Sync tasks\",\n    parameters: [],\n    execute: async function ([], context) {\n      let url = \"https://api.todoist.com/rest/v1/tasks\";\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n\n      let results: any[] = [];\n      for (let task of response.body) {\n        results.push(toTask(task, true));\n      }\n      return {\n        result: results,\n      };\n    },\n  },\n});\n\n\n// Helper functions.\n\nfunction extractProjectId(projectUrl: string) {\n  for (let pattern of ProjectUrlPatterns) {\n    let matches = projectUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid project URL: \" + projectUrl);\n}\n\nfunction extractTaskId(taskUrl: string) {\n  for (let pattern of TaskUrlPatterns) {\n    let matches = taskUrl.match(pattern);\n    if (matches && matches[1]) {\n      return matches[1];\n    }\n  }\n  throw new coda.UserVisibleError(\"Invalid task URL: \" + taskUrl);\n}"
      }
    ]
  },
  {
    "name": "Cats",
    "category": "Full",
    "triggerTokens": [],
    "linkData": {
      "type": "SamplePage"
    },
    "exampleFooterLink": "https://coda.github.io/packs-sdk/samples/full/cats",
    "content": "This Pack provides allows you to fetch random cat photos using the [Cat-as-a-service API][cataas]. You can set various parameters for the cat image, such as the width and height, as well as add a text overlay. The Pack provides:\n\n- A formula for fetching a cat photo.\n- A column format that displays the text on top of a cat photo.\n- A sync table that retrieves all available cat photos.\n\n[cataas]: https://cataas.com/",
    "exampleSnippets": [
      {
        "name": "pack.ts",
        "content": "",
        "code": "import * as coda from \"@codahq/packs-sdk\";\nexport const pack = coda.newPack();\n\npack.addNetworkDomain(\"cataas.com\");\n\n// Tag parameter, shared across multiple formulas.\nconst TagParameter = coda.makeParameter({\n  type: coda.ParameterType.String,\n  name: \"tag\",\n  description: \"Only cats with this tag will be selected.\",\n  optional: true,\n  // Pull the list of tags to use for autocomplete from the API.\n  autocomplete: async function (context, search) {\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: \"https://cataas.com/api/tags\",\n    });\n    let tags = response.body;\n    // Convert the tags into a list of autocomplete options.\n    return coda.simpleAutocomplete(search, tags);\n  },\n});\n\n// Formula that fetches a random cat image, with various options.\npack.addFormula({\n  name: \"CatImage\",\n  description: \"Gets a random cat image.\",\n  parameters: [\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"text\",\n      description: \"Text to display over the image.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"size\",\n      description: \"The size of the text, in pixels.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"color\",\n      description: \"The color of the text. Any valid CSS color can be used.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"width\",\n      description: \"The width of the desired image, in pixels.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.Number,\n      name: \"height\",\n      description: \"The height of the desired image, in pixels.\",\n      optional: true,\n    }),\n    coda.makeParameter({\n      type: coda.ParameterType.String,\n      name: \"filter\",\n      description: \"A filter to apply to the image.\",\n      autocomplete: [\"blur\", \"mono\", \"sepia\", \"negative\", \"paint\", \"pixel\"],\n      optional: true,\n    }),\n    TagParameter,\n  ],\n  resultType: coda.ValueType.String,\n  codaType: coda.ValueHintType.ImageReference,\n  execute: async function ([text, size, color, width, height, filter, tag],\n    context) {\n    let url = \"https://cataas.com/cat\";\n    if (tag) {\n      url += \"/\" + tag;\n    }\n    if (text) {\n      url += \"/says/\" + encodeURIComponent(text);\n    }\n    url = coda.withQueryParams(url, {\n      size: size,\n      color: color,\n      width: width,\n      height: height,\n      filter: filter,\n      json: true,\n    });\n    let response = await context.fetcher.fetch({\n      method: \"GET\",\n      url: url,\n      cacheTtlSecs: 0, // Don't cache the result, so we can get a fresh cat.\n    });\n    return \"https://cataas.com\" + response.body.url;\n  },\n});\n\n// Column format that displays the cell's value within a random cat image,\n// using the CatImage() formula defined above.\npack.addColumnFormat({\n  name: \"Cat Image\",\n  instructions: \"Displays the text over the image of a random cat.\",\n  formulaName: \"CatImage\",\n  formulaNamespace: \"Deprecated\", // Will be removed shortly\n});\n\n// Schema for a Cat image.\nconst CatSchema = coda.makeObjectSchema({\n  type: coda.ValueType.Object,\n  properties: {\n    image: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.ImageReference,\n    },\n    tags: {\n      type: coda.ValueType.Array,\n      items: { type: coda.ValueType.String },\n    },\n    created: {\n      type: coda.ValueType.String,\n      codaType: coda.ValueHintType.DateTime,\n    },\n    id: { type: coda.ValueType.String },\n  },\n  primary: \"image\",\n  id: \"id\",\n  featured: [\"tags\"],\n  identity: {\n    name: \"Cat\",\n  },\n});\n\n// Sync table that retrieves all cat images, optionally filtered by tags.\npack.addSyncTable({\n  name: \"Cats\",\n  identityName: \"Cat\",\n  schema: CatSchema,\n  connectionRequirement: coda.ConnectionRequirement.None,\n  formula: {\n    name: \"SyncCats\",\n    description: \"Syncs the cats.\",\n    parameters: [\n      TagParameter,\n    ],\n    execute: async function ([tag], context) {\n      let url = coda.withQueryParams(\"https://cataas.com/api/cats\", {\n        tags: tag\n      });\n      let response = await context.fetcher.fetch({\n        method: \"GET\",\n        url: url,\n      });\n      let cats = response.body;\n      let result: any = [];\n      for (let cat of cats) {\n        result.push({\n          image: \"https://cataas.com/cat/\" + cat.id,\n          tags: cat.tags,\n          created: cat.created_at,\n          id: cat.id,\n        });\n      }\n      return {\n        result: result,\n      };\n    },\n  },\n});"
      }
    ]
  }
]